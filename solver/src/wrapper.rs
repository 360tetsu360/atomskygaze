/* automatically generated by rust-bindgen 0.69.4 */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _SGIDEFS_H: u32 = 1;
pub const _MIPS_ISA_MIPS1: u32 = 1;
pub const _MIPS_ISA_MIPS2: u32 = 2;
pub const _MIPS_ISA_MIPS3: u32 = 3;
pub const _MIPS_ISA_MIPS4: u32 = 4;
pub const _MIPS_ISA_MIPS5: u32 = 5;
pub const _MIPS_ISA_MIPS32: u32 = 6;
pub const _MIPS_ISA_MIPS64: u32 = 7;
pub const _ABIN32: u32 = 2;
pub const _MIPS_SIM_NABI32: u32 = 2;
pub const _ABI64: u32 = 3;
pub const _MIPS_SIM_ABI64: u32 = 3;
pub const _ABIO64: u32 = 4;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 0;
pub const __WORDSIZE32_SIZE_ULONG: u32 = 0;
pub const __WORDSIZE32_PTRDIFF_LONG: u32 = 0;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 38;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __NO_LONG_DOUBLE_MATH: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 0;
pub const __STATFS_MATCHES_STATFS64: u32 = 0;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 0;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 0;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 0;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 4321;
pub const __FLOAT_WORD_ORDER: u32 = 4321;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 0;
pub const __FP_LOGBNAN_IS_MIN: u32 = 0;
pub const FP_ILOGB0: i32 = -2147483647;
pub const FP_ILOGBNAN: u32 = 2147483647;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const DIM_STARS: u32 = 3;
pub const DIM_XY: u32 = 2;
pub const DQMAX: u32 = 5;
pub const DCMAX: u32 = 6;
pub const ONE_OVER_SIXTY: f64 = 0.016666666666666666;
pub const RAD_PER_DEG: f64 = 0.017453292519943295;
pub const RAD_PER_ARCMIN: f64 = 0.0002908882086657216;
pub const DEG_PER_RAD: f64 = 57.29577951308232;
pub const DEG_PER_ARCMIN: f64 = 0.016666666666666666;
pub const DEG_PER_ARCSEC: f64 = 0.0002777777777777778;
pub const ARCMIN_PER_RAD: f64 = 3437.7467707849396;
pub const ARCMIN_PER_DEG: f64 = 60.0;
pub const ARCMIN_PER_ARCSEC: f64 = 0.016666666666666666;
pub const ARCSEC_PER_RAD: f64 = 206264.80624709636;
pub const ARCSEC_PER_DEG: f64 = 3600.0;
pub const ARCSEC_PER_ARCMIN: f64 = 60.0;
pub const MJD_JD_OFFSET: f64 = 2400000.5;
pub const HELP_ERR: i32 = -101;
pub const OPT_ERR: i32 = -201;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 4321;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 36;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 24;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 20;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 0;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const DEFINE_SORT: u32 = 1;
pub const KDTREE_MAX_LEVELS: u32 = 1000;
pub const KDT_DATA_MASK: u32 = 15;
pub const KDT_TREE_MASK: u32 = 3840;
pub const KDT_EXT_MASK: u32 = 196608;
pub const KD_DIM_GENERIC: u32 = 1;
pub const SIP_MAXORDER: u32 = 10;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_ILP32_OFF32: u32 = 1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: u32 = 1;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: u32 = 1;
pub const _XBS5_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_LP64_OFF64: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 43] = b"-D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const FITSVALSZ: u32 = 60;
pub const QFITS_INVALIDTABLE: u32 = 0;
pub const QFITS_BINTABLE: u32 = 1;
pub const QFITS_ASCIITABLE: u32 = 2;
pub const _SYS_PARAM_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 131072;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_H: u32 = 1;
pub const SIGEMT: u32 = 7;
pub const SIGPWR: u32 = 19;
pub const SIGBUS: u32 = 10;
pub const SIGSYS: u32 = 12;
pub const SIGURG: u32 = 21;
pub const SIGSTOP: u32 = 23;
pub const SIGTSTP: u32 = 24;
pub const SIGCONT: u32 = 25;
pub const SIGCHLD: u32 = 18;
pub const SIGTTIN: u32 = 26;
pub const SIGTTOU: u32 = 27;
pub const SIGPOLL: u32 = 22;
pub const SIGXCPU: u32 = 30;
pub const SIGVTALRM: u32 = 28;
pub const SIGPROF: u32 = 29;
pub const SIGXFSZ: u32 = 31;
pub const SIGUSR1: u32 = 16;
pub const SIGUSR2: u32 = 17;
pub const SIGWINCH: u32 = 20;
pub const SIGIO: u32 = 22;
pub const SIGCLD: u32 = 18;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 127;
pub const _NSIG: u32 = 128;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 0;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 0;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 128;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 65536;
pub const SA_SIGINFO: u32 = 8;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_NOP: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SIG_SETMASK32: u32 = 256;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 32;
pub const __NFPREG: u32 = 32;
pub const NGREG: u32 = 32;
pub const NFPREG: u32 = 32;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const EXEC_PAGESIZE: u32 = 65536;
pub const HZ: u32 = 100;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const MAXSYMLINKS: u32 = 20;
pub const NOFILE: u32 = 256;
pub const NCARGS: u32 = 131072;
pub const NGROUPS: u32 = 65536;
pub const CANBSIZ: u32 = 255;
pub const MAXPATHLEN: u32 = 4096;
pub const DEV_BSIZE: u32 = 512;
pub const FITS_BLOCK_SIZE: u32 = 2880;
pub const FITS_NCARDS: u32 = 36;
pub const FITS_LINESZ: u32 = 80;
pub const PTYPE_FLOAT: u32 = 0;
pub const PTYPE_INT: u32 = 1;
pub const PTYPE_DOUBLE: u32 = 2;
pub const PTYPE_UINT8: u32 = 3;
pub const PTYPE_INT16: u32 = 4;
pub const BPP_8_UNSIGNED: u32 = 8;
pub const BPP_16_SIGNED: u32 = 16;
pub const BPP_32_SIGNED: u32 = 32;
pub const BPP_IEEE_FLOAT: i32 = -32;
pub const BPP_IEEE_DOUBLE: i32 = -64;
pub const BPP_DEFAULT: i32 = -32;
pub const QFITS_UNKNOWN: u32 = 0;
pub const QFITS_BOOLEAN: u32 = 1;
pub const QFITS_INT: u32 = 2;
pub const QFITS_FLOAT: u32 = 3;
pub const QFITS_COMPLEX: u32 = 4;
pub const QFITS_STRING: u32 = 5;
pub const KD_STR_HEADER: &[u8; 14] = b"kdtree_header\0";
pub const KD_STR_LR: &[u8; 10] = b"kdtree_lr\0";
pub const KD_STR_PERM: &[u8; 12] = b"kdtree_perm\0";
pub const KD_STR_BB: &[u8; 10] = b"kdtree_bb\0";
pub const KD_STR_SPLIT: &[u8; 13] = b"kdtree_split\0";
pub const KD_STR_SPLITDIM: &[u8; 16] = b"kdtree_splitdim\0";
pub const KD_STR_DATA: &[u8; 12] = b"kdtree_data\0";
pub const KD_STR_RANGE: &[u8; 13] = b"kdtree_range\0";
pub const AN_FILETYPE_STARTREE: &[u8; 5] = b"SKDT\0";
pub const AN_FILETYPE_TAGALONG: &[u8; 9] = b"TAGALONG\0";
pub const STARTREE_NAME: &[u8; 6] = b"stars\0";
pub const AN_FILETYPE_CODETREE: &[u8; 5] = b"CKDT\0";
pub const CODETREE_NAME: &[u8; 6] = b"codes\0";
pub const DEFAULT_INDEX_JITTER: f64 = 1.0;
pub const INDEX_ONLY_LOAD_METADATA: u32 = 2;
pub const THETA_DISTRACTOR: i32 = -1;
pub const THETA_CONFLICT: i32 = -2;
pub const THETA_FILTERED: i32 = -3;
pub const THETA_BAILEDOUT: i32 = -4;
pub const THETA_STOPPEDLOOKING: i32 = -5;
pub const DEFAULT_CODE_TOL: f64 = 0.01;
pub const DEFAULT_TWEAK_ABORDER: u32 = 3;
pub const DEFAULT_TWEAK_ABPORDER: u32 = 3;
pub const DEFAULT_DISTRACTOR_RATIO: f64 = 0.25;
pub const DEFAULT_VERIFY_PIX: f64 = 1.0;
pub const DEFAULT_BAIL_THRESHOLD : f64 = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 ;
pub const SOLVER_TWEAK2_AVAILABLE: u32 = 1;
pub const DEFAULT_QSF_LO: f64 = 0.1;
pub const DEFAULT_QSF_HI: f64 = 1.0;
pub const SEP_TBYTE: u32 = 11;
pub const SEP_TINT: u32 = 31;
pub const SEP_TFLOAT: u32 = 42;
pub const SEP_TDOUBLE: u32 = 82;
pub const SEP_OBJ_MERGED: u32 = 1;
pub const SEP_OBJ_TRUNC: u32 = 2;
pub const SEP_OBJ_DOVERFLOW: u32 = 4;
pub const SEP_OBJ_SINGU: u32 = 8;
pub const SEP_APER_TRUNC: u32 = 16;
pub const SEP_APER_HASMASKED: u32 = 32;
pub const SEP_APER_ALLMASKED: u32 = 64;
pub const SEP_APER_NONPOSITIVE: u32 = 128;
pub const SEP_NOISE_NONE: u32 = 0;
pub const SEP_NOISE_STDDEV: u32 = 1;
pub const SEP_NOISE_VAR: u32 = 2;
pub const SEP_MASK_IGNORE: u32 = 4;
pub const SEP_THRESH_REL: u32 = 0;
pub const SEP_THRESH_ABS: u32 = 1;
pub const SEP_FILTER_CONV: u32 = 0;
pub const SEP_FILTER_MATCHED: u32 = 1;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_longlong;
pub type __u_quad_t = ::std::os::raw::c_ulonglong;
pub type __intmax_t = ::std::os::raw::c_longlong;
pub type __uintmax_t = ::std::os::raw::c_ulonglong;
pub type __dev_t = __uint64_t;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = __uint64_t;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = __int64_t;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = __uint64_t;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = __int64_t;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = __int64_t;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = __uint64_t;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = __uint64_t;
pub type __fsword_t = ::std::os::raw::c_int;
pub type __ssize_t = ::std::os::raw::c_int;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_int;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type __time64_t = __int64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 40usize],
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type anbool = ::std::os::raw::c_uchar;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
pub type float_t = f32;
pub type double_t = f64;
pub type uchar = ::std::os::raw::c_uchar;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 32usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 32usize],
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __kind: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: __pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_mutex_s__bindgen_ty_1 {
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_slist_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __pad1: ::std::os::raw::c_uchar,
    pub __pad2: ::std::os::raw::c_uchar,
    pub __shared: ::std::os::raw::c_uchar,
    pub __flags: ::std::os::raw::c_uchar,
    pub __cur_writer: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 36usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 24usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 20usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bl_node {
    pub N: ::std::os::raw::c_int,
    pub next: *mut bl_node,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bl {
    pub head: *mut bl_node,
    pub tail: *mut bl_node,
    pub N: usize,
    pub blocksize: ::std::os::raw::c_int,
    pub datasize: ::std::os::raw::c_int,
    pub last_access: *mut bl_node,
    pub last_access_n: usize,
}
pub type sl = bl;
pub type il = bl;
pub type ll = bl;
pub type dl = bl;
pub type fl = bl;
pub type pl = bl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct starxy_t {
    pub x: *mut f64,
    pub y: *mut f64,
    pub flux: *mut f64,
    pub background: *mut f64,
    pub N: ::std::os::raw::c_int,
    pub xlo: f64,
    pub xhi: f64,
    pub ylo: f64,
    pub yhi: f64,
}
pub const kd_rangesearch_options_KD_OPTIONS_COMPUTE_DISTS: kd_rangesearch_options = 1;
pub const kd_rangesearch_options_KD_OPTIONS_RETURN_POINTS: kd_rangesearch_options = 2;
pub const kd_rangesearch_options_KD_OPTIONS_SORT_DISTS: kd_rangesearch_options = 4;
pub const kd_rangesearch_options_KD_OPTIONS_SMALL_RADIUS: kd_rangesearch_options = 8;
pub const kd_rangesearch_options_KD_OPTIONS_USE_SPLIT: kd_rangesearch_options = 16;
pub const kd_rangesearch_options_KD_OPTIONS_NO_BIG_INT_MATH: kd_rangesearch_options = 32;
pub const kd_rangesearch_options_KD_OPTIONS_SPLIT_PRECHECK: kd_rangesearch_options = 64;
pub const kd_rangesearch_options_KD_OPTIONS_L1_PRECHECK: kd_rangesearch_options = 128;
pub const kd_rangesearch_options_KD_OPTIONS_NO_RESIZE_RESULTS: kd_rangesearch_options = 256;
pub type kd_rangesearch_options = ::std::os::raw::c_uint;
pub const kd_build_options_KD_BUILD_BBOX: kd_build_options = 1;
pub const kd_build_options_KD_BUILD_SPLIT: kd_build_options = 2;
pub const kd_build_options_KD_BUILD_SPLITDIM: kd_build_options = 4;
pub const kd_build_options_KD_BUILD_NO_LR: kd_build_options = 8;
pub const kd_build_options_KD_BUILD_LINEAR_LR: kd_build_options = 16;
pub const kd_build_options_KD_BUILD_FORCE_SORT: kd_build_options = 32;
pub type kd_build_options = ::std::os::raw::c_uint;
pub type u64_ = u64;
pub type u32_ = u32;
pub type u16_ = u16;
pub type u8_ = u8;
pub const kd_types_KDT_NULL: kd_types = 0;
pub const kd_types_KDT_DATA_NULL: kd_types = 0;
pub const kd_types_KDT_DATA_DOUBLE: kd_types = 1;
pub const kd_types_KDT_DATA_FLOAT: kd_types = 2;
pub const kd_types_KDT_DATA_U32: kd_types = 4;
pub const kd_types_KDT_DATA_U16: kd_types = 8;
pub const kd_types_KDT_TREE_NULL: kd_types = 0;
pub const kd_types_KDT_TREE_DOUBLE: kd_types = 256;
pub const kd_types_KDT_TREE_FLOAT: kd_types = 512;
pub const kd_types_KDT_TREE_U32: kd_types = 1024;
pub const kd_types_KDT_TREE_U16: kd_types = 2048;
pub const kd_types_KDT_EXT_NULL: kd_types = 0;
pub const kd_types_KDT_EXT_DOUBLE: kd_types = 65536;
pub const kd_types_KDT_EXT_FLOAT: kd_types = 131072;
pub type kd_types = ::std::os::raw::c_uint;
pub const kd_tree_types_KDTT_NULL: kd_tree_types = 0;
pub const kd_tree_types_KDTT_DOUBLE: kd_tree_types = 65793;
pub const kd_tree_types_KDTT_FLOAT: kd_tree_types = 131586;
pub const kd_tree_types_KDTT_DOUBLE_U32: kd_tree_types = 66561;
pub const kd_tree_types_KDTT_DOUBLE_U16: kd_tree_types = 67585;
pub const kd_tree_types_KDTT_DUU: kd_tree_types = 66564;
pub const kd_tree_types_KDTT_DSS: kd_tree_types = 67592;
pub const kd_tree_types_KDTT_DDU: kd_tree_types = 66561;
pub type kd_tree_types = ::std::os::raw::c_uint;
pub type kdtree_t = kdtree;
pub type kdtree_qres_t = kdtree_qres;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kdtree_funcs {
    pub get_data: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            i: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub copy_data_double: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            start: ::std::os::raw::c_int,
            N: ::std::os::raw::c_int,
            dest: *mut f64,
        ),
    >,
    pub get_splitval: ::std::option::Option<
        unsafe extern "C" fn(kd: *const kdtree_t, nodeid: ::std::os::raw::c_int) -> f64,
    >,
    pub get_bboxes: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            node: ::std::os::raw::c_int,
            bblo: *mut ::std::os::raw::c_void,
            bbhi: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub check:
        ::std::option::Option<unsafe extern "C" fn(kd: *const kdtree_t) -> ::std::os::raw::c_int>,
    pub fix_bounding_boxes: ::std::option::Option<unsafe extern "C" fn(kd: *mut kdtree_t)>,
    pub nearest_neighbour_internal: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            query: *const ::std::os::raw::c_void,
            bestd2: *mut f64,
            pbest: *mut ::std::os::raw::c_int,
        ),
    >,
    pub rangesearch: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            res: *mut kdtree_qres_t,
            pt: *const ::std::os::raw::c_void,
            maxd2: f64,
            options: ::std::os::raw::c_int,
        ) -> *mut kdtree_qres_t,
    >,
    pub nodes_contained: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            querylow: *const ::std::os::raw::c_void,
            queryhi: *const ::std::os::raw::c_void,
            callback_contained: ::std::option::Option<
                unsafe extern "C" fn(
                    kd: *const kdtree_t,
                    node: ::std::os::raw::c_int,
                    extra: *mut ::std::os::raw::c_void,
                ),
            >,
            callback_overlap: ::std::option::Option<
                unsafe extern "C" fn(
                    kd: *const kdtree_t,
                    node: ::std::os::raw::c_int,
                    extra: *mut ::std::os::raw::c_void,
                ),
            >,
            cb_extra: *mut ::std::os::raw::c_void,
        ),
    >,
    pub nn_enqueue: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            nodeid: ::std::os::raw::c_int,
            place: ::std::os::raw::c_int,
        ),
    >,
    pub nn_prune: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            nodeid: ::std::os::raw::c_int,
            d2: f64,
            bestd2: f64,
            place: ::std::os::raw::c_int,
        ),
    >,
    pub nn_explore: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            nodeid: ::std::os::raw::c_int,
            d2: f64,
            bestd2: f64,
        ),
    >,
    pub nn_point: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            nodeid: ::std::os::raw::c_int,
            pointindex: ::std::os::raw::c_int,
        ),
    >,
    pub nn_new_best: ::std::option::Option<
        unsafe extern "C" fn(
            kd: *const kdtree_t,
            nodeid: ::std::os::raw::c_int,
            pointindex: ::std::os::raw::c_int,
            d2: f64,
        ),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kdtree {
    pub treetype: u32_,
    pub lr: *mut i32,
    pub perm: *mut u32_,
    pub bb: kdtree__bindgen_ty_1,
    pub n_bb: ::std::os::raw::c_int,
    pub split: kdtree__bindgen_ty_2,
    pub splitdim: *mut u8_,
    pub dimbits: u8_,
    pub dimmask: u32_,
    pub splitmask: u32_,
    pub data: kdtree__bindgen_ty_3,
    pub free_data: ::std::os::raw::c_int,
    pub minval: *mut f64,
    pub maxval: *mut f64,
    pub scale: f64,
    pub invscale: f64,
    pub ndata: ::std::os::raw::c_int,
    pub ndim: ::std::os::raw::c_int,
    pub nnodes: ::std::os::raw::c_int,
    pub nbottom: ::std::os::raw::c_int,
    pub ninterior: ::std::os::raw::c_int,
    pub nlevels: ::std::os::raw::c_int,
    pub has_linear_lr: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub io: *mut ::std::os::raw::c_void,
    pub fun: kdtree_funcs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kdtree__bindgen_ty_1 {
    pub f: *mut f32,
    pub d: *mut f64,
    pub u: *mut u32_,
    pub s: *mut u16_,
    pub any: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kdtree__bindgen_ty_2 {
    pub f: *mut f32,
    pub d: *mut f64,
    pub u: *mut u32_,
    pub s: *mut u16_,
    pub any: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kdtree__bindgen_ty_3 {
    pub f: *mut f32,
    pub d: *mut f64,
    pub u: *mut u32_,
    pub s: *mut u16_,
    pub any: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kdtree_qres {
    pub nres: ::std::os::raw::c_uint,
    pub capacity: ::std::os::raw::c_uint,
    pub results: kdtree_qres__bindgen_ty_1,
    pub sdists: *mut f64,
    pub inds: *mut u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kdtree_qres__bindgen_ty_1 {
    pub d: *mut f64,
    pub f: *mut f32,
    pub u: *mut u32_,
    pub s: *mut u16_,
    pub any: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tan_t {
    pub crval: [f64; 2usize],
    pub crpix: [f64; 2usize],
    pub cd: [[f64; 2usize]; 2usize],
    pub imagew: f64,
    pub imageh: f64,
    pub sin: anbool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sip_t {
    pub wcstan: tan_t,
    pub a_order: ::std::os::raw::c_int,
    pub b_order: ::std::os::raw::c_int,
    pub a: [[f64; 10usize]; 10usize],
    pub b: [[f64; 10usize]; 10usize],
    pub ap_order: ::std::os::raw::c_int,
    pub bp_order: ::std::os::raw::c_int,
    pub ap: [[f64; 10usize]; 10usize],
    pub bp: [[f64; 10usize]; 10usize],
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
pub const _PC_LINK_MAX: _bindgen_ty_2 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_2 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_2 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_2 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_2 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_2 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_2 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_2 = 7;
pub const _PC_VDISABLE: _bindgen_ty_2 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_2 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_2 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_2 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_2 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_2 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_2 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_2 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_2 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_2 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_2 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_2 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_2 = 20;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_3 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_3 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_3 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_3 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_3 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_3 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_3 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_3 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_3 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_3 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_3 = 10;
pub const _SC_TIMERS: _bindgen_ty_3 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_3 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_3 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_3 = 14;
pub const _SC_FSYNC: _bindgen_ty_3 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_3 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_3 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_3 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_3 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_3 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_3 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_3 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_3 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_3 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_3 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_3 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_3 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_3 = 28;
pub const _SC_VERSION: _bindgen_ty_3 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_3 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_3 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_3 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_3 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_3 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_3 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_3 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_3 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_3 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_3 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_3 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_3 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_3 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_3 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_3 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_3 = 45;
pub const _SC_2_VERSION: _bindgen_ty_3 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_3 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_3 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_3 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_3 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_3 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_3 = 52;
pub const _SC_PII: _bindgen_ty_3 = 53;
pub const _SC_PII_XTI: _bindgen_ty_3 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_3 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_3 = 56;
pub const _SC_PII_OSI: _bindgen_ty_3 = 57;
pub const _SC_POLL: _bindgen_ty_3 = 58;
pub const _SC_SELECT: _bindgen_ty_3 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_3 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_3 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_3 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_3 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_3 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_3 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_3 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_3 = 66;
pub const _SC_THREADS: _bindgen_ty_3 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_3 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_3 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_3 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_3 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_3 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_3 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_3 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_3 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_3 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_3 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_3 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_3 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_3 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_3 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_3 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_3 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_3 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_3 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_3 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_3 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_3 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_3 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_3 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_3 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_3 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_3 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_3 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_3 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_3 = 96;
pub const _SC_2_UPE: _bindgen_ty_3 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_3 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_3 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_3 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_3 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_3 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_3 = 103;
pub const _SC_INT_MAX: _bindgen_ty_3 = 104;
pub const _SC_INT_MIN: _bindgen_ty_3 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_3 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_3 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_3 = 108;
pub const _SC_NZERO: _bindgen_ty_3 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_3 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_3 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_3 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_3 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_3 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_3 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_3 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_3 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_3 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_3 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_3 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_3 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_3 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_3 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_3 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_3 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_3 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_3 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_3 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_3 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_3 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_3 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_3 = 132;
pub const _SC_BARRIERS: _bindgen_ty_3 = 133;
pub const _SC_BASE: _bindgen_ty_3 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_3 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_3 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_3 = 137;
pub const _SC_CPUTIME: _bindgen_ty_3 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_3 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_3 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_3 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_3 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_3 = 143;
pub const _SC_FIFO: _bindgen_ty_3 = 144;
pub const _SC_PIPE: _bindgen_ty_3 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_3 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_3 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_3 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_3 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_3 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_3 = 151;
pub const _SC_NETWORKING: _bindgen_ty_3 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_3 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_3 = 154;
pub const _SC_REGEXP: _bindgen_ty_3 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_3 = 156;
pub const _SC_SHELL: _bindgen_ty_3 = 157;
pub const _SC_SIGNALS: _bindgen_ty_3 = 158;
pub const _SC_SPAWN: _bindgen_ty_3 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_3 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_3 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_3 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_3 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_3 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_3 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_3 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_3 = 167;
pub const _SC_2_PBS: _bindgen_ty_3 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_3 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_3 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_3 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_3 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_3 = 173;
pub const _SC_STREAMS: _bindgen_ty_3 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_3 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_3 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_3 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_3 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_3 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_3 = 180;
pub const _SC_TRACE: _bindgen_ty_3 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_3 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_3 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_3 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_3 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_3 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_3 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_3 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_3 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_3 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_3 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_3 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_3 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_3 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_3 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_3 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_3 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_3 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_3 = 199;
pub const _SC_IPV6: _bindgen_ty_3 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_3 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_3 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_3 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_3 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_3 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_3 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_3 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_3 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_3 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_3 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_3 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_3 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_3 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_3 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_3 = 250;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_4 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_4 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_4 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_4 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_4 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_4 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_4 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_4 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_4 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_4 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_4 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_4 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_4 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_4 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_4 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_4 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_4 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_4 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_4 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_4 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_4 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_4 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_4 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_4 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_4 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_4 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_4 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_4 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_4 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_4 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_4 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_4 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_4 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_4 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_4 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_4 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_4 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_4 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_4 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_4 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_4 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_4 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_4 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_4 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_4 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_4 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_4 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_4 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_4 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_4 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_4 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_4 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_4 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_4 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_4 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_4 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_4 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_4 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_4 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_4 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_4 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_4 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_4 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_4 = 1149;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = "@brief    FITS header object\n\nThis structure represents a FITS header in memory. It is actually no\nmore than a thin layer on top of the keytuple object. No field in this\nstructure should be directly modifiable by the user, only through\naccessor functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qfits_header {
    _unused: [u8; 0],
}
pub const _TFITS_DATA_TYPE__TFITS_ASCII_TYPE_A: _TFITS_DATA_TYPE_ = 0;
pub const _TFITS_DATA_TYPE__TFITS_ASCII_TYPE_D: _TFITS_DATA_TYPE_ = 1;
pub const _TFITS_DATA_TYPE__TFITS_ASCII_TYPE_E: _TFITS_DATA_TYPE_ = 2;
pub const _TFITS_DATA_TYPE__TFITS_ASCII_TYPE_F: _TFITS_DATA_TYPE_ = 3;
pub const _TFITS_DATA_TYPE__TFITS_ASCII_TYPE_I: _TFITS_DATA_TYPE_ = 4;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_A: _TFITS_DATA_TYPE_ = 5;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_B: _TFITS_DATA_TYPE_ = 6;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_C: _TFITS_DATA_TYPE_ = 7;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_D: _TFITS_DATA_TYPE_ = 8;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_E: _TFITS_DATA_TYPE_ = 9;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_I: _TFITS_DATA_TYPE_ = 10;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_J: _TFITS_DATA_TYPE_ = 11;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_K: _TFITS_DATA_TYPE_ = 12;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_L: _TFITS_DATA_TYPE_ = 13;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_M: _TFITS_DATA_TYPE_ = 14;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_P: _TFITS_DATA_TYPE_ = 15;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_X: _TFITS_DATA_TYPE_ = 16;
pub const _TFITS_DATA_TYPE__TFITS_BIN_TYPE_UNKNOWN: _TFITS_DATA_TYPE_ = 17;
#[doc = "@brief    Column data type"]
pub type _TFITS_DATA_TYPE_ = ::std::os::raw::c_uint;
#[doc = "@brief    Column data type"]
pub use self::_TFITS_DATA_TYPE_ as tfits_type;
#[doc = "@brief    Column object\n\nThis structure contains all information needed to read a column in a table.\nThese informations come from the header.\nThe qfits_table object contains a list of qfits_col objects.\n\nThis structure has to be created from scratch and filled if one want to\ngenerate a FITS table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qfits_col {
    #[doc = "Number of atoms in one field.\nIn ASCII tables, it is the number of characters in the field as defined\nin TFORM%d keyword.\nIn BIN tables, it is the number of atoms in each field. For type 'A',\nit is the number of characters. A field with two complex object will\nhave atom_nb = 4."]
    pub atom_nb: ::std::os::raw::c_int,
    #[doc = "Number of decimals in a ASCII field.\nThis value is always 0 for BIN tables"]
    pub atom_dec_nb: ::std::os::raw::c_int,
    #[doc = "Size of one element in bytes. In ASCII tables, atom_size is the size\nof the element once it has been converted in its 'destination' type.\nFor example, if \"123\" is contained in an ASCII table in a column\ndefined as I type, atom_nb=3, atom_size=4.\nIn ASCII tables:\n- type 'A' : atom_size = atom_nb = number of chars\n- type 'I', 'F' or 'E' : atom_size = 4\n- type 'D' : atom_size = 8\nIn BIN tables :\n- type 'A', 'L', 'X', 'B': atom_size = 1\n- type 'I' : atom_size = 2\n- type 'E', 'J', 'C', 'P' : atom_size = 4\n- type 'D', 'M' : atom_size = 8\nIn ASCII table, there is one element per field. The size in bytes and\nin number of characters is atom_nb, and the size in bytes after\nconversion of the field is atom_size.\nIn BIN tables, the size in bytes of a field is always atom_nb*atom_size."]
    pub atom_size: ::std::os::raw::c_int,
    #[doc = "Type of data in the column as specified in TFORM keyword\nIn ASCII tables : TFITS_ASCII_TYPE_* with *=A, I, F, E or D\nIn BIN tables : TFITS_BIN_TYPE_* with *=L, X, B, I, J, A, E, D, C, M or P"]
    pub atom_type: tfits_type,
    #[doc = " Label of the column"]
    pub tlabel: [::std::os::raw::c_char; 60usize],
    #[doc = " Unit of the data"]
    pub tunit: [::std::os::raw::c_char; 60usize],
    #[doc = " Null value"]
    pub nullval: [::std::os::raw::c_char; 60usize],
    #[doc = " Display format"]
    pub tdisp: [::std::os::raw::c_char; 60usize],
    #[doc = "zero and scale are used when the quantity in the field does not\nrepresent a true physical quantity. Basically, thez should be used\nwhen they are present: physical_value = zero + scale * field_value\nThey are read from TZERO and TSCAL in the header"]
    pub zero_present: ::std::os::raw::c_int,
    pub zero: f32,
    pub scale_present: ::std::os::raw::c_int,
    pub scale: f32,
    #[doc = " Offset between the beg. of the table and the beg. of the column.\nNOTE, THIS IS NOT THE OFFSET FROM THE BEGINNING OF THE *ROW*!"]
    pub off_beg: ::std::os::raw::c_int,
    #[doc = " Flag to know if the column is readable. An empty col is not readable"]
    pub readable: ::std::os::raw::c_int,
}
#[doc = "@brief    Table object\n\nThis structure contains all information needed to read a FITS table.\nThese information come from the header. The object is created by\nqfits_open().\n\nTo read a FITS table, here is a code example:\n@code\nint main(int argc, char* argv[])\n{\nqfits_table     *   table;\nint                    n_ext;\nint                    i;\n\n// Query the number of extensions\nn_ext = qfits_query_n_ext(argv[1]);\n\n// For each extension\nfor (i=0; i<n_ext; i++) {\n// Read all the infos about the current table\ntable = qfits_table_open(argv[1], i+1);\n// Display the current table\ndump_extension(table, stdout, '|', 1, 1);\n}\nreturn;\n}\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qfits_table {
    #[doc = "Name of the file the table comes from or it is intended to end to"]
    pub filename: [::std::os::raw::c_char; 512usize],
    #[doc = "Table type.\nPossible values: QFITS_INVALIDTABLE, QFITS_BINTABLE, QFITS_ASCIITABLE"]
    pub tab_t: ::std::os::raw::c_int,
    #[doc = " Width in bytes of the table"]
    pub tab_w: ::std::os::raw::c_int,
    #[doc = " Number of columns"]
    pub nc: ::std::os::raw::c_int,
    #[doc = " Number of rows"]
    pub nr: ::std::os::raw::c_int,
    #[doc = " Array of qfits_col objects"]
    pub col: *mut qfits_col,
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 29usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
pub const SI_ASYNCNL: _bindgen_ty_5 = -60;
pub const SI_DETHREAD: _bindgen_ty_5 = -7;
pub const SI_TKILL: _bindgen_ty_5 = -6;
pub const SI_SIGIO: _bindgen_ty_5 = -5;
pub const SI_MESGQ: _bindgen_ty_5 = -4;
pub const SI_TIMER: _bindgen_ty_5 = -3;
pub const SI_ASYNCIO: _bindgen_ty_5 = -2;
pub const SI_QUEUE: _bindgen_ty_5 = -1;
pub const SI_USER: _bindgen_ty_5 = 0;
pub const SI_KERNEL: _bindgen_ty_5 = 128;
pub type _bindgen_ty_5 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_6 = 1;
pub const ILL_ILLOPN: _bindgen_ty_6 = 2;
pub const ILL_ILLADR: _bindgen_ty_6 = 3;
pub const ILL_ILLTRP: _bindgen_ty_6 = 4;
pub const ILL_PRVOPC: _bindgen_ty_6 = 5;
pub const ILL_PRVREG: _bindgen_ty_6 = 6;
pub const ILL_COPROC: _bindgen_ty_6 = 7;
pub const ILL_BADSTK: _bindgen_ty_6 = 8;
pub const ILL_BADIADDR: _bindgen_ty_6 = 9;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_7 = 1;
pub const FPE_INTOVF: _bindgen_ty_7 = 2;
pub const FPE_FLTDIV: _bindgen_ty_7 = 3;
pub const FPE_FLTOVF: _bindgen_ty_7 = 4;
pub const FPE_FLTUND: _bindgen_ty_7 = 5;
pub const FPE_FLTRES: _bindgen_ty_7 = 6;
pub const FPE_FLTINV: _bindgen_ty_7 = 7;
pub const FPE_FLTSUB: _bindgen_ty_7 = 8;
pub const FPE_FLTUNK: _bindgen_ty_7 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_7 = 15;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_8 = 1;
pub const SEGV_ACCERR: _bindgen_ty_8 = 2;
pub const SEGV_BNDERR: _bindgen_ty_8 = 3;
pub const SEGV_PKUERR: _bindgen_ty_8 = 4;
pub const SEGV_ACCADI: _bindgen_ty_8 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_8 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_8 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_8 = 8;
pub const SEGV_MTESERR: _bindgen_ty_8 = 9;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_9 = 1;
pub const BUS_ADRERR: _bindgen_ty_9 = 2;
pub const BUS_OBJERR: _bindgen_ty_9 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_9 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_9 = 5;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_10 = 1;
pub const CLD_KILLED: _bindgen_ty_10 = 2;
pub const CLD_DUMPED: _bindgen_ty_10 = 3;
pub const CLD_TRAPPED: _bindgen_ty_10 = 4;
pub const CLD_STOPPED: _bindgen_ty_10 = 5;
pub const CLD_CONTINUED: _bindgen_ty_10 = 6;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_11 = 1;
pub const POLL_OUT: _bindgen_ty_11 = 2;
pub const POLL_MSG: _bindgen_ty_11 = 3;
pub const POLL_ERR: _bindgen_ty_11 = 4;
pub const POLL_PRI: _bindgen_ty_11 = 5;
pub const POLL_HUP: _bindgen_ty_11 = 6;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 13usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_12 = 0;
pub const SIGEV_NONE: _bindgen_ty_12 = 1;
pub const SIGEV_THREAD: _bindgen_ty_12 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_12 = 4;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type sig_t = __sighandler_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub sa_flags: ::std::os::raw::c_int,
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
    pub sa_resv: [::std::os::raw::c_int; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext {
    pub sc_regmask: ::std::os::raw::c_uint,
    pub sc_status: ::std::os::raw::c_uint,
    pub sc_pc: ::std::os::raw::c_ulonglong,
    pub sc_regs: [::std::os::raw::c_ulonglong; 32usize],
    pub sc_fpregs: [::std::os::raw::c_ulonglong; 32usize],
    pub sc_ownedfp: ::std::os::raw::c_uint,
    pub sc_fpc_csr: ::std::os::raw::c_uint,
    pub sc_fpc_eir: ::std::os::raw::c_uint,
    pub sc_used_math: ::std::os::raw::c_uint,
    pub sc_dsp: ::std::os::raw::c_uint,
    pub sc_mdhi: ::std::os::raw::c_ulonglong,
    pub sc_mdlo: ::std::os::raw::c_ulonglong,
    pub sc_hi1: ::std::os::raw::c_ulong,
    pub sc_lo1: ::std::os::raw::c_ulong,
    pub sc_hi2: ::std::os::raw::c_ulong,
    pub sc_lo2: ::std::os::raw::c_ulong,
    pub sc_hi3: ::std::os::raw::c_ulong,
    pub sc_lo3: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: usize,
    pub ss_flags: ::std::os::raw::c_int,
}
pub type greg_t = ::std::os::raw::c_ulonglong;
pub type gregset_t = [greg_t; 32usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fpregset_t {
    pub fp_r: fpregset_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fpregset_t__bindgen_ty_1 {
    pub fp_dregs: [f64; 32usize],
    pub fp_fregs: [fpregset_t__bindgen_ty_1__bindgen_ty_1; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpregset_t__bindgen_ty_1__bindgen_ty_1 {
    pub _fp_fregs: f32,
    pub _fp_pad: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mcontext_t {
    pub regmask: ::std::os::raw::c_uint,
    pub status: ::std::os::raw::c_uint,
    pub pc: greg_t,
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub fp_owned: ::std::os::raw::c_uint,
    pub fpc_csr: ::std::os::raw::c_uint,
    pub fpc_eir: ::std::os::raw::c_uint,
    pub used_math: ::std::os::raw::c_uint,
    pub dsp: ::std::os::raw::c_uint,
    pub mdhi: greg_t,
    pub mdlo: greg_t,
    pub hi1: ::std::os::raw::c_ulong,
    pub lo1: ::std::os::raw::c_ulong,
    pub hi2: ::std::os::raw::c_ulong,
    pub lo2: ::std::os::raw::c_ulong,
    pub hi3: ::std::os::raw::c_ulong,
    pub lo3: ::std::os::raw::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
}
pub const SS_ONSTACK: _bindgen_ty_13 = 1;
pub const SS_DISABLE: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[doc = "@brief    Alias for unsigned char\n\nA 'byte' is just an alias for an unsigned char. It is only defined\nfor readability."]
pub type byte = ::std::os::raw::c_uchar;
#[doc = "@brief    qfits dumper control object\n\nThis structure offers various control parameters to dump a pixel\nbuffer to a FITS file. The buffer will be dumped as requested\nto the requested file in append mode. Of course, the requested file\nmust be writeable for the operation to succeed.\n\nThe following example demonstrates how to save a linear ramp sized\n100x100 to a FITS file with BITPIX=16. Notice that this code only\ndumps the pixel buffer, no header information is provided in this\ncase.\n\n@code\nint   i, j;\nint * ibuf;\nqfitsdumper    qd;\n\n// Fill a buffer with 100x100 int pixels\nibuf = malloc(100 * 100 * sizeof(int));\nfor (j=0; j<100; j++) {\nfor (i=0; i<100; i++) {\nibuf[i+j*100] = i+j;\n}\n}\n\nqd.filename  = \"out.fits\";     // Output file name\nqd.npix      = 100 * 100;      // Number of pixels\nqd.ptype     = PTYPE_INT;      // Input buffer type\nqd.ibuf      = ibuf;           // Set buffer pointer\nqd.out_ptype = BPP_16_SIGNED;  // Save with BITPIX=16\n\n// Dump buffer to file (error checking omitted for clarity)\nqfits_pixdump(&qd);\n\nfree(ibuf);\n@endcode\n\nIf the provided output file name is \"STDOUT\" (all capitals), the\nfunction will dump the pixels to the stdout steam (usually the console,\ncould have been re-directed)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qfitsdumper {
    #[doc = " Name of the file to dump to, \"STDOUT\" to dump to stdout"]
    pub filename: *const ::std::os::raw::c_char,
    #[doc = " Number of pixels in the buffer to dump"]
    pub npix: ::std::os::raw::c_int,
    #[doc = " Buffer type: PTYPE_FLOAT, PTYPE_INT or PTYPE_DOUBLE"]
    pub ptype: ::std::os::raw::c_int,
    #[doc = " Pointer to input integer pixel buffer"]
    pub ibuf: *const ::std::os::raw::c_int,
    #[doc = " Pointer to input float pixel buffer"]
    pub fbuf: *const f32,
    #[doc = " Pointer to input double pixel buffer"]
    pub dbuf: *const f64,
    #[doc = " Pointer to generic pixel buffer."]
    pub vbuf: *const ::std::os::raw::c_void,
    #[doc = " Requested BITPIX in output FITS file"]
    pub out_ptype: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anqfits_image_t {
    pub naxis: ::std::os::raw::c_int,
    pub width: off_t,
    pub height: off_t,
    pub planes: off_t,
    pub bpp: ::std::os::raw::c_int,
    pub bitpix: ::std::os::raw::c_int,
    pub bscale: f64,
    pub bzero: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anqfits_ext_t {
    pub hdr_start: ::std::os::raw::c_int,
    pub hdr_size: ::std::os::raw::c_int,
    pub data_start: ::std::os::raw::c_int,
    pub data_size: ::std::os::raw::c_int,
    pub header: *mut qfits_header,
    pub table: *mut qfits_table,
    pub image: *mut anqfits_image_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anqfits_t {
    pub filename: *mut ::std::os::raw::c_char,
    pub Nexts: ::std::os::raw::c_int,
    pub exts: *mut anqfits_ext_t,
    pub filesize: off_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fitsbin_chunk_t {
    pub tablename: *mut ::std::os::raw::c_char,
    pub tablename_copy: *mut ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub itemsize: ::std::os::raw::c_int,
    pub nrows: ::std::os::raw::c_int,
    pub required: ::std::os::raw::c_int,
    pub callback_read_header: ::std::option::Option<
        unsafe extern "C" fn(
            fb: *mut fitsbin_t,
            chunk: *mut fitsbin_chunk_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub userdata: *mut ::std::os::raw::c_void,
    pub header: *mut qfits_header,
    pub header_start: off_t,
    pub header_end: off_t,
    pub forced_type: tfits_type,
    pub map: *mut ::std::os::raw::c_char,
    pub mapsize: usize,
}
#[doc = "\"fitsbin\" is our abuse of FITS binary tables to hold raw binary data,\nwithout endian flips*, by storing the data as characters/bytes.\nThis has the advantage that they can be directly mmap()'d, but of\ncourse means that they aren't endian-independent.  We accept that\ntradeoff in the interest of speed and the recognition that x86 is\npretty much all we care about.\n\n\nTypical usage patterns:\n\n-Reading:\nfitsbin_open();\nfitsbin_add_chunk();\nfitsbin_add_chunk();\n...\nfitsbin_read();\n...\nfitsbin_close();\n\nOR:\nfb = fitsbin_open();\nfitsbin_chunk_init(&chunk);\nchunk.tablename = \"hello\";\nfitsbin_read_chunk(fb, &chunk);\n// chunk.data;\n//NO fitsbin_add_chunk(fb, &chunk);\nfitsbin_close();\n\n-Writing:\nfitsbin_open_for_writing();\nfitsbin_add_chunk();\nfitsbin_add_chunk();\n...\nfitsbin_write_primary_header();\n...\nfitsbin_write_chunk_header();\nfitsbin_write_items();\n...\nfitsbin_fix_chunk_header();\n\nfitsbin_write_chunk_header();\nfitsbin_write_items();\n...\nfitsbin_fix_chunk_header();\n...\nfitsbin_fix_primary_header();\nfitsbin_close();\n\nOR:\n\nfb = fitsbin_open_for_writing();\nfitsbin_write_primary_header();\n\nfitsbin_chunk_init(&chunk);\nchunk.tablename = \"whatever\";\nchunk.data = ...;\nchunk.itemsize = 4;\nchunk.nrows = 1000;\nfitsbin_write_chunk(fb, &chunk);\nfitsbin_chunk_clean(&chunk);\n\nfitsbin_fix_primary_header();\nfitsbin_close(fb);\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fitsbin_t {
    pub filename: *mut ::std::os::raw::c_char,
    pub fits: *mut anqfits_t,
    pub chunks: *mut bl,
    pub fid: *mut FILE,
    pub inmemory: anbool,
    pub items: *mut bl,
    pub extensions: *mut bl,
    pub primheader: *mut qfits_header,
    pub primheader_end: off_t,
    pub tables: *mut *mut qfits_table,
    pub Next: ::std::os::raw::c_int,
    pub userdata: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quadfile_t {
    pub numquads: ::std::os::raw::c_uint,
    pub numstars: ::std::os::raw::c_uint,
    pub dimquads: ::std::os::raw::c_int,
    pub index_scale_upper: f64,
    pub index_scale_lower: f64,
    pub indexid: ::std::os::raw::c_int,
    pub healpix: ::std::os::raw::c_int,
    pub hpnside: ::std::os::raw::c_int,
    pub fb: *mut fitsbin_t,
    pub quadarray: *mut u32,
}
#[doc = "Usage patterns:\n\nkdtree_fits_t* io = kdtree_fits_open(\"in.kd.fits\");\nkdtree_t* kd = kdtree_fits_read_tree(io, \"mytree\");\n// kd contains the tree that was read.\n// io->fb->primheader is the primary header\n\nfitsbin_chunk_t chunk;\nchunk.tablename = \"my_extra_data\";\nchunk.itemsize = sizeof(int32_t);\nchunk.nrows = kd->ndata;\nkdtree_fits_read_chunk(io, &chunk);\n\n// chunk->header\n// chunk->data\n\nkdtree_fits_close();\n\n\n\n\nkdtree_fits_t* io = kdtree_fits_open_for_writing(\"out.kd.fits\");\n\nkdtree_t* mytree = ...;\nkdtree_fits_write_tree(io, mytree);\n\nfitsbin_chunk_t chunk;\nchunk.tablename = \"my_extra\";\nchunk.data = ...;\nchunk.itemsize = sizeof(int32_t);\nchunk.nrows = mytree->ndata;\nkdtree_fits_write_chunk(io, &chunk)\n\nkdtree_fits_close();\n"]
pub type kdtree_fits_t = fitsbin_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buffered_read_data {
    pub buffer: *mut ::std::os::raw::c_void,
    pub blocksize: ::std::os::raw::c_int,
    pub elementsize: ::std::os::raw::c_int,
    pub ntotal: ::std::os::raw::c_int,
    pub nbuff: ::std::os::raw::c_int,
    pub off: ::std::os::raw::c_int,
    pub buffind: ::std::os::raw::c_int,
    pub refill_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            userdata: *mut ::std::os::raw::c_void,
            buffer: *mut ::std::os::raw::c_void,
            offs: ::std::os::raw::c_uint,
            nelems: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub userdata: *mut ::std::os::raw::c_void,
}
pub type bread_t = buffered_read_data;
#[doc = "For quick-n-easy(-ish) access to a column of data in a FITS BINTABLE.\n\nSome example usage scenarios:\n\n// Writing:\n\nchar* filename = \"/tmp/xxx\";\nfitstable_t* tab = fitstable_open_for_writing(filename);\n// Add column \"X\", a scalar double (FITS type D)\nfitstable_add_write_column(tab, fitscolumn_double_type(), \"X\", \"xunits\");\n// Add column \"Y\", a 2-D float (FITS type E), but the data to be\n// written is in C doubles.\nfitstable_add_write_column_array_convert(tab, fitscolumn_float_type(), fitscolumn_double_type(), 2, \"Y\", \"yunits\");\n// Add some stuff to the primary header...\nqfits_header* hdr = fitstable_get_primary_header(tab);\nfits_header_add_int(hdr, \"KEYVAL\", 42, \"Comment\");\n// Add some stuff to the extension header...\nhdr = fitstable_get_header(tab);\nfits_header_add_int(hdr, \"KEYVAL2\", 43, \"Comment\");\n// Write...\nif (fitstable_write_primary_header(tab) ||\nfitstable_write_header(tab)) {\n// error...\n}\n// Write data...\ndouble x[] = { 1,2,3 };\ndouble y[] = { 3,4, 5,6, 7,8 };\nint i, N = 3;\nfor (i=0; i<N; i++)\nfitstable_write_row(tab, x + i, y + 2*i);\nif (fitstable_fix_header(tab)) {\n// error...\n}\n// Write some data to another extension.\nfitstable_next_extension(tab);\nfitstable_clear_table(tab);\n// Add column \"Z\", a scalar double\nfitstable_add_write_column(tab, fitscolumn_double_type(), \"Z\", \"zunits\");\n// Add some stuff to the extension header...\nhdr = fitstable_get_header(tab);\nfits_header_add_int(hdr, \"KEYVAL3\", 44, \"Comment\");\nif (fitstable_write_header(tab)) {\n// error...\n}\n// Write data...\ndouble z[] = { 9, 10, 11 };\nN = 3;\nfor (i=0; i<N; i++)\nfitstable_write_row(tab, z + i);\nif (fitstable_fix_header(tab) ||\nfitstable_close(tab)) {\n// error...\n}\n\n\n// Reading:\n\nchar* filename = \"/tmp/xxx\";\nfitstable_t* tab = fitstable_open(filename);\n// Read the primary header.\nqfits_header* hdr = fitstable_get_primary_header(tab);\nint val = qfits_header_getint(hdr, \"KEYVAL\", -1);\n// Read a value from the extension header.\nhdr = fitstable_get_header(tab);\nint val2 = qfits_header_getint(hdr, \"KEYVAL2\", -1);\n// Read the arrays.\nint N = fitstable_nrows(tab);\n// Read a column in the first extension table as a scalar double.\ntfits_type dubl = fitscolumn_double_type();\ndouble* x = fitstable_read_column(tab, \"X\", dubl);\n// Read a column into a double array.\nint D = fitstable_get_array_size(tab, \"Y\");\ndouble* y = fitstable_read_column_array(tab, \"Y\", dubl);\n// Read the second extension...\nfitstable_open_next_extension(tab);\n// Read a value from the extension header...\nhdr = fitstable_get_header(tab);\nint val3 = qfits_header_getint(hdr, \"KEYVAL3\", -1);\n// Read the arrays.\nN = fitstable_nrows(tab);\ndouble* z = fitstable_read_column(tab, \"Z\", dubl);\n// Done.\nfitstable_close(tab);\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fitstable_t {
    pub anq: *mut anqfits_t,
    pub table: *mut qfits_table,
    pub header: *mut qfits_header,
    pub primheader: *mut qfits_header,
    pub cols: *mut bl,
    pub extension: ::std::os::raw::c_int,
    pub fn_: *mut ::std::os::raw::c_char,
    pub inmemory: anbool,
    pub rows: *mut bl,
    pub extensions: *mut bl,
    pub fid: *mut FILE,
    pub end_header_offset: off_t,
    pub table_offset: off_t,
    pub end_table_offset: off_t,
    pub br: *mut bread_t,
    pub readfid: *mut FILE,
    pub postprocess_read_structs: ::std::option::Option<
        unsafe extern "C" fn(
            table: *mut fitstable_t,
            struc: *mut ::std::os::raw::c_void,
            stride: ::std::os::raw::c_int,
            offset: ::std::os::raw::c_int,
            N: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct startree_t {
    pub tree: *mut kdtree_t,
    pub header: *mut qfits_header,
    pub inverse_perm: *mut ::std::os::raw::c_int,
    pub sweep: *mut u8,
    pub writing: ::std::os::raw::c_int,
    pub tagalong: *mut fitstable_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct codetree_t {
    pub tree: *mut kdtree_t,
    pub header: *mut qfits_header,
    pub inverse_perm: *mut ::std::os::raw::c_int,
}
#[doc = "Info about an index, including part of the sky it covers, size of\nquads, etc.; plus the code kdtree, quad list, and star kdtree.\n\nSome of the functions below only read the metadata, leaving the\n\"codekd\", \"quads\", and \"starkd\" fields NULL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct index_t {
    pub codekd: *mut codetree_t,
    pub quads: *mut quadfile_t,
    pub starkd: *mut startree_t,
    pub fits: *mut anqfits_t,
    pub codefn: *mut ::std::os::raw::c_char,
    pub quadfn: *mut ::std::os::raw::c_char,
    pub starfn: *mut ::std::os::raw::c_char,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexid: ::std::os::raw::c_int,
    pub healpix: ::std::os::raw::c_int,
    pub hpnside: ::std::os::raw::c_int,
    pub index_jitter: f64,
    pub cutnside: ::std::os::raw::c_int,
    pub cutnsweep: ::std::os::raw::c_int,
    pub cutdedup: f64,
    pub cutband: *mut ::std::os::raw::c_char,
    pub cutmargin: ::std::os::raw::c_int,
    pub circle: anbool,
    pub cx_less_than_dx: anbool,
    pub meanx_less_than_half: anbool,
    pub index_scale_upper: f64,
    pub index_scale_lower: f64,
    pub dimquads: ::std::os::raw::c_int,
    pub nstars: ::std::os::raw::c_int,
    pub nquads: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct match_struct {
    pub quadno: ::std::os::raw::c_uint,
    pub star: [::std::os::raw::c_uint; 5usize],
    pub field: [::std::os::raw::c_uint; 5usize],
    pub ids: [u64; 5usize],
    pub code_err: f32,
    pub quadpix: [f64; 10usize],
    pub quadxyz: [f64; 15usize],
    pub dimquads: u8,
    pub center: [f64; 3usize],
    pub radius: f64,
    pub radius_deg: f64,
    pub wcs_valid: anbool,
    pub wcstan: tan_t,
    pub scale: f64,
    pub quad_npeers: i16,
    pub nmatch: ::std::os::raw::c_int,
    pub ndistractor: ::std::os::raw::c_int,
    pub nconflict: ::std::os::raw::c_int,
    pub nfield: ::std::os::raw::c_int,
    pub nindex: ::std::os::raw::c_int,
    pub nbest: ::std::os::raw::c_int,
    pub logodds: f32,
    pub worstlogodds: f32,
    pub nagree: i16,
    pub fieldnum: ::std::os::raw::c_int,
    pub fieldfile: ::std::os::raw::c_int,
    pub indexid: i16,
    pub healpix: i16,
    pub hpnside: i16,
    pub fieldname: [::std::os::raw::c_char; 32usize],
    pub parity: anbool,
    pub quads_tried: ::std::os::raw::c_int,
    pub quads_matched: ::std::os::raw::c_int,
    pub quads_scaleok: ::std::os::raw::c_int,
    pub objs_tried: ::std::os::raw::c_int,
    pub nverified: ::std::os::raw::c_int,
    pub timeused: f32,
    pub sip: *mut sip_t,
    pub refradec: *mut f64,
    pub fieldxy: *mut f64,
    pub tagalong: *mut bl,
    pub field_tagalong: *mut bl,
    pub index_jitter: f64,
    pub index: *mut index_t,
    pub theta: *mut ::std::os::raw::c_int,
    pub matchodds: *mut f64,
    pub testperm: *mut ::std::os::raw::c_int,
    pub refxyz: *mut f64,
    pub refxy: *mut f64,
    pub refstarid: *mut ::std::os::raw::c_int,
}
pub type MatchObj = match_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct verify_field_t {
    pub field: *const starxy_t,
    pub xy: *mut f64,
    pub fieldcopy: *mut f64,
    pub ftree: *mut kdtree_t,
    pub do_uniformize: anbool,
    pub do_dedup: anbool,
    pub do_ror: anbool,
}
pub const PARITY_NORMAL: _bindgen_ty_14 = 0;
pub const PARITY_FLIP: _bindgen_ty_14 = 1;
pub const PARITY_BOTH: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct solver_t {
    pub indexes: *mut pl,
    pub fieldxy: *mut starxy_t,
    pub predistort: *mut sip_t,
    pub funits_lower: f64,
    pub funits_upper: f64,
    pub logratio_toprint: f64,
    pub logratio_tokeep: f64,
    pub logratio_totune: f64,
    pub record_match_callback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut MatchObj, arg2: *mut ::std::os::raw::c_void) -> anbool,
    >,
    pub userdata: *mut ::std::os::raw::c_void,
    pub distance_from_quad_bonus: anbool,
    pub verify_uniformize: anbool,
    pub verify_dedup: anbool,
    pub do_tweak: anbool,
    pub tweak_aborder: ::std::os::raw::c_int,
    pub tweak_abporder: ::std::os::raw::c_int,
    pub verify_pix: f64,
    pub distractor_ratio: f64,
    pub codetol: f64,
    pub quadsize_min: f64,
    pub quadsize_max: f64,
    pub startobj: ::std::os::raw::c_int,
    pub endobj: ::std::os::raw::c_int,
    pub parity: ::std::os::raw::c_int,
    pub use_radec: anbool,
    pub centerxyz: [f64; 3usize],
    pub r2: f64,
    pub logratio_bail_threshold: f64,
    pub logratio_stoplooking: f64,
    pub maxquads: ::std::os::raw::c_int,
    pub maxmatches: ::std::os::raw::c_int,
    pub set_crpix: anbool,
    pub set_crpix_center: anbool,
    pub crpix: [f64; 2usize],
    pub mo_template: *mut MatchObj,
    pub timer_callback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> time_t>,
    pub quit_now: anbool,
    pub numtries: ::std::os::raw::c_int,
    pub nummatches: ::std::os::raw::c_int,
    pub numscaleok: ::std::os::raw::c_int,
    pub last_examined_object: ::std::os::raw::c_int,
    pub num_cxdx_skipped: ::std::os::raw::c_int,
    pub num_meanx_skipped: ::std::os::raw::c_int,
    pub num_radec_skipped: ::std::os::raw::c_int,
    pub num_abscale_skipped: ::std::os::raw::c_int,
    pub num_verified: ::std::os::raw::c_int,
    pub index: *mut index_t,
    pub minminAB2: f64,
    pub maxmaxAB2: f64,
    pub rel_index_noise2: f64,
    pub rel_field_noise2: f64,
    pub abscale_low: f64,
    pub abscale_high: f64,
    pub field_minx: f64,
    pub field_maxx: f64,
    pub field_miny: f64,
    pub field_maxy: f64,
    pub field_diag: f64,
    pub cxdx_margin: f64,
    pub starttime: f64,
    pub timeused: f64,
    pub best_logodds: f64,
    pub best_match: MatchObj,
    pub best_index: *mut index_t,
    pub best_match_solves: anbool,
    pub have_best_match: anbool,
    pub vf: *mut verify_field_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blind_params {
    pub solver: solver_t,
    pub indexes_inparallel: anbool,
    pub logratio_tosolve: f64,
    pub nsolves: ::std::os::raw::c_int,
    pub nsolves_sofar: ::std::os::raw::c_int,
    pub fieldfname: *mut ::std::os::raw::c_char,
    pub matchfname: *mut ::std::os::raw::c_char,
    pub indexrdlsfname: *mut ::std::os::raw::c_char,
    pub corr_fname: *mut ::std::os::raw::c_char,
    pub scamp_fname: *mut ::std::os::raw::c_char,
    pub wcs_template: *mut ::std::os::raw::c_char,
    pub verify_wcsfiles: *mut sl,
    pub verify_wcs_list: *mut bl,
    pub solved_out: *mut ::std::os::raw::c_char,
    pub solved_in: *mut ::std::os::raw::c_char,
    pub solvedserver: *mut ::std::os::raw::c_char,
    pub firstfield: ::std::os::raw::c_int,
    pub lastfield: ::std::os::raw::c_int,
    pub indexnames: *mut sl,
    pub indexes: *mut pl,
    pub index_options: ::std::os::raw::c_int,
    pub quad_size_fraction_lo: f64,
    pub quad_size_fraction_hi: f64,
    pub fieldlist: *mut il,
    pub fieldnum: ::std::os::raw::c_int,
    pub fieldid: ::std::os::raw::c_int,
    pub xcolname: *mut ::std::os::raw::c_char,
    pub ycolname: *mut ::std::os::raw::c_char,
    pub fieldid_key: *mut ::std::os::raw::c_char,
    pub rdls_tagalong: *mut sl,
    pub rdls_tagalong_all: anbool,
    pub solutions: *mut bl,
    pub cpulimit: f32,
    pub cpu_start: f32,
    pub hit_cpulimit: anbool,
    pub timelimit: ::std::os::raw::c_int,
    pub time_start: time_t,
    pub hit_timelimit: anbool,
    pub total_cpulimit: f32,
    pub cpu_total_start: f32,
    pub hit_total_cpulimit: anbool,
    pub total_timelimit: f64,
    pub time_total_start: f64,
    pub hit_total_timelimit: anbool,
    pub single_field_solved: anbool,
    pub cancelfname: *mut ::std::os::raw::c_char,
    pub cancelled: anbool,
    pub best_hit_only: anbool,
}
pub type blind_t = blind_params;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct engine {
    pub index_paths: *mut sl,
    pub indexes: *mut pl,
    pub free_indexes: *mut pl,
    pub ibiggest: *mut il,
    pub ismallest: *mut il,
    pub default_depths: *mut il,
    pub sizesmallest: f64,
    pub sizebiggest: f64,
    pub inparallel: anbool,
    pub minwidth: f64,
    pub maxwidth: f64,
    pub cpulimit: f32,
}
pub type engine_t = engine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct job_t {
    pub scales: *mut dl,
    pub depths: *mut il,
    pub include_default_scales: anbool,
    pub ra_center: f64,
    pub dec_center: f64,
    pub search_radius: f64,
    pub use_radec_center: anbool,
    pub bp: blind_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sep_image {
    pub data: *const ::std::os::raw::c_void,
    pub noise: *const ::std::os::raw::c_void,
    pub mask: *const ::std::os::raw::c_void,
    pub segmap: *const ::std::os::raw::c_void,
    pub dtype: ::std::os::raw::c_int,
    pub ndtype: ::std::os::raw::c_int,
    pub mdtype: ::std::os::raw::c_int,
    pub sdtype: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    pub noiseval: f64,
    pub noise_type: ::std::os::raw::c_short,
    pub gain: f64,
    pub maskthresh: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sep_bkg {
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
    pub bw: ::std::os::raw::c_int,
    pub bh: ::std::os::raw::c_int,
    pub nx: ::std::os::raw::c_int,
    pub ny: ::std::os::raw::c_int,
    pub n: ::std::os::raw::c_int,
    pub global: f32,
    pub globalrms: f32,
    pub back: *mut f32,
    pub dback: *mut f32,
    pub sigma: *mut f32,
    pub dsigma: *mut f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sep_catalog {
    pub nobj: ::std::os::raw::c_int,
    pub thresh: *mut f32,
    pub npix: *mut ::std::os::raw::c_int,
    pub tnpix: *mut ::std::os::raw::c_int,
    pub xmin: *mut ::std::os::raw::c_int,
    pub xmax: *mut ::std::os::raw::c_int,
    pub ymin: *mut ::std::os::raw::c_int,
    pub ymax: *mut ::std::os::raw::c_int,
    pub x: *mut f64,
    pub y: *mut f64,
    pub x2: *mut f64,
    pub y2: *mut f64,
    pub xy: *mut f64,
    pub errx2: *mut f64,
    pub erry2: *mut f64,
    pub errxy: *mut f64,
    pub a: *mut f32,
    pub b: *mut f32,
    pub theta: *mut f32,
    pub cxx: *mut f32,
    pub cyy: *mut f32,
    pub cxy: *mut f32,
    pub cflux: *mut f32,
    pub flux: *mut f32,
    pub cpeak: *mut f32,
    pub peak: *mut f32,
    pub xcpeak: *mut ::std::os::raw::c_int,
    pub ycpeak: *mut ::std::os::raw::c_int,
    pub xpeak: *mut ::std::os::raw::c_int,
    pub ypeak: *mut ::std::os::raw::c_int,
    pub flag: *mut ::std::os::raw::c_short,
    pub pix: *mut *mut ::std::os::raw::c_int,
    pub objectspix: *mut ::std::os::raw::c_int,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
extern "C" {
    pub static mut stdin: *mut FILE;
    pub static mut stdout: *mut FILE;
    pub static mut stderr: *mut FILE;
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn tmpfile() -> *mut FILE;
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
    pub fn setlinebuf(__stream: *mut FILE);
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_uint,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_uint,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar() -> ::std::os::raw::c_int;
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_uint,
        __n: ::std::os::raw::c_uint,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_uint;
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_uint,
        __n: ::std::os::raw::c_uint,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_uint;
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
    pub fn rewind(__stream: *mut FILE);
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ftello(__stream: *mut FILE) -> __off_t;
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
    pub fn clearerr(__stream: *mut FILE);
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn clearerr_unlocked(__stream: *mut FILE);
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn perror(__s: *const ::std::os::raw::c_char);
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn flockfile(__stream: *mut FILE);
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn funlockfile(__stream: *mut FILE);
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
    pub fn mktime(__tp: *mut tm) -> time_t;
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
    pub fn localtime(__timer: *const time_t) -> *mut tm;
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
    pub static mut __daylight: ::std::os::raw::c_int;
    pub static mut __timezone: ::std::os::raw::c_long;
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
    pub fn tzset();
    pub static mut daylight: ::std::os::raw::c_int;
    pub static mut timezone: ::std::os::raw::c_long;
    pub fn timegm(__tp: *mut tm) -> time_t;
    pub fn timelocal(__tp: *mut tm) -> time_t;
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
    pub fn acos(__x: f64) -> f64;
    pub fn __acos(__x: f64) -> f64;
    pub fn asin(__x: f64) -> f64;
    pub fn __asin(__x: f64) -> f64;
    pub fn atan(__x: f64) -> f64;
    pub fn __atan(__x: f64) -> f64;
    pub fn atan2(__y: f64, __x: f64) -> f64;
    pub fn __atan2(__y: f64, __x: f64) -> f64;
    pub fn cos(__x: f64) -> f64;
    pub fn __cos(__x: f64) -> f64;
    pub fn sin(__x: f64) -> f64;
    pub fn __sin(__x: f64) -> f64;
    pub fn tan(__x: f64) -> f64;
    pub fn __tan(__x: f64) -> f64;
    pub fn cosh(__x: f64) -> f64;
    pub fn __cosh(__x: f64) -> f64;
    pub fn sinh(__x: f64) -> f64;
    pub fn __sinh(__x: f64) -> f64;
    pub fn tanh(__x: f64) -> f64;
    pub fn __tanh(__x: f64) -> f64;
    pub fn acosh(__x: f64) -> f64;
    pub fn __acosh(__x: f64) -> f64;
    pub fn asinh(__x: f64) -> f64;
    pub fn __asinh(__x: f64) -> f64;
    pub fn atanh(__x: f64) -> f64;
    pub fn __atanh(__x: f64) -> f64;
    pub fn exp(__x: f64) -> f64;
    pub fn __exp(__x: f64) -> f64;
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
    pub fn log(__x: f64) -> f64;
    pub fn __log(__x: f64) -> f64;
    pub fn log10(__x: f64) -> f64;
    pub fn __log10(__x: f64) -> f64;
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
    pub fn expm1(__x: f64) -> f64;
    pub fn __expm1(__x: f64) -> f64;
    pub fn log1p(__x: f64) -> f64;
    pub fn __log1p(__x: f64) -> f64;
    pub fn logb(__x: f64) -> f64;
    pub fn __logb(__x: f64) -> f64;
    pub fn exp2(__x: f64) -> f64;
    pub fn __exp2(__x: f64) -> f64;
    pub fn log2(__x: f64) -> f64;
    pub fn __log2(__x: f64) -> f64;
    pub fn pow(__x: f64, __y: f64) -> f64;
    pub fn __pow(__x: f64, __y: f64) -> f64;
    pub fn sqrt(__x: f64) -> f64;
    pub fn __sqrt(__x: f64) -> f64;
    pub fn hypot(__x: f64, __y: f64) -> f64;
    pub fn __hypot(__x: f64, __y: f64) -> f64;
    pub fn cbrt(__x: f64) -> f64;
    pub fn __cbrt(__x: f64) -> f64;
    pub fn ceil(__x: f64) -> f64;
    pub fn __ceil(__x: f64) -> f64;
    pub fn fabs(__x: f64) -> f64;
    pub fn __fabs(__x: f64) -> f64;
    pub fn floor(__x: f64) -> f64;
    pub fn __floor(__x: f64) -> f64;
    pub fn fmod(__x: f64, __y: f64) -> f64;
    pub fn __fmod(__x: f64, __y: f64) -> f64;
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
    pub fn drem(__x: f64, __y: f64) -> f64;
    pub fn __drem(__x: f64, __y: f64) -> f64;
    pub fn significand(__x: f64) -> f64;
    pub fn __significand(__x: f64) -> f64;
    pub fn copysign(__x: f64, __y: f64) -> f64;
    pub fn __copysign(__x: f64, __y: f64) -> f64;
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
    pub fn j0(arg1: f64) -> f64;
    pub fn __j0(arg1: f64) -> f64;
    pub fn j1(arg1: f64) -> f64;
    pub fn __j1(arg1: f64) -> f64;
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn y0(arg1: f64) -> f64;
    pub fn __y0(arg1: f64) -> f64;
    pub fn y1(arg1: f64) -> f64;
    pub fn __y1(arg1: f64) -> f64;
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn erf(arg1: f64) -> f64;
    pub fn __erf(arg1: f64) -> f64;
    pub fn erfc(arg1: f64) -> f64;
    pub fn __erfc(arg1: f64) -> f64;
    pub fn lgamma(arg1: f64) -> f64;
    pub fn __lgamma(arg1: f64) -> f64;
    pub fn tgamma(arg1: f64) -> f64;
    pub fn __tgamma(arg1: f64) -> f64;
    pub fn gamma(arg1: f64) -> f64;
    pub fn __gamma(arg1: f64) -> f64;
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
    pub fn rint(__x: f64) -> f64;
    pub fn __rint(__x: f64) -> f64;
    pub fn nextafter(__x: f64, __y: f64) -> f64;
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
    pub fn remainder(__x: f64, __y: f64) -> f64;
    pub fn __remainder(__x: f64, __y: f64) -> f64;
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
    pub fn nearbyint(__x: f64) -> f64;
    pub fn __nearbyint(__x: f64) -> f64;
    pub fn round(__x: f64) -> f64;
    pub fn __round(__x: f64) -> f64;
    pub fn trunc(__x: f64) -> f64;
    pub fn __trunc(__x: f64) -> f64;
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn fdim(__x: f64, __y: f64) -> f64;
    pub fn __fdim(__x: f64, __y: f64) -> f64;
    pub fn fmax(__x: f64, __y: f64) -> f64;
    pub fn __fmax(__x: f64, __y: f64) -> f64;
    pub fn fmin(__x: f64, __y: f64) -> f64;
    pub fn __fmin(__x: f64, __y: f64) -> f64;
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
    pub fn scalb(__x: f64, __n: f64) -> f64;
    pub fn __scalb(__x: f64, __n: f64) -> f64;
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
    pub fn acosf(__x: f32) -> f32;
    pub fn __acosf(__x: f32) -> f32;
    pub fn asinf(__x: f32) -> f32;
    pub fn __asinf(__x: f32) -> f32;
    pub fn atanf(__x: f32) -> f32;
    pub fn __atanf(__x: f32) -> f32;
    pub fn atan2f(__y: f32, __x: f32) -> f32;
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
    pub fn cosf(__x: f32) -> f32;
    pub fn __cosf(__x: f32) -> f32;
    pub fn sinf(__x: f32) -> f32;
    pub fn __sinf(__x: f32) -> f32;
    pub fn tanf(__x: f32) -> f32;
    pub fn __tanf(__x: f32) -> f32;
    pub fn coshf(__x: f32) -> f32;
    pub fn __coshf(__x: f32) -> f32;
    pub fn sinhf(__x: f32) -> f32;
    pub fn __sinhf(__x: f32) -> f32;
    pub fn tanhf(__x: f32) -> f32;
    pub fn __tanhf(__x: f32) -> f32;
    pub fn acoshf(__x: f32) -> f32;
    pub fn __acoshf(__x: f32) -> f32;
    pub fn asinhf(__x: f32) -> f32;
    pub fn __asinhf(__x: f32) -> f32;
    pub fn atanhf(__x: f32) -> f32;
    pub fn __atanhf(__x: f32) -> f32;
    pub fn expf(__x: f32) -> f32;
    pub fn __expf(__x: f32) -> f32;
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
    pub fn logf(__x: f32) -> f32;
    pub fn __logf(__x: f32) -> f32;
    pub fn log10f(__x: f32) -> f32;
    pub fn __log10f(__x: f32) -> f32;
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
    pub fn expm1f(__x: f32) -> f32;
    pub fn __expm1f(__x: f32) -> f32;
    pub fn log1pf(__x: f32) -> f32;
    pub fn __log1pf(__x: f32) -> f32;
    pub fn logbf(__x: f32) -> f32;
    pub fn __logbf(__x: f32) -> f32;
    pub fn exp2f(__x: f32) -> f32;
    pub fn __exp2f(__x: f32) -> f32;
    pub fn log2f(__x: f32) -> f32;
    pub fn __log2f(__x: f32) -> f32;
    pub fn powf(__x: f32, __y: f32) -> f32;
    pub fn __powf(__x: f32, __y: f32) -> f32;
    pub fn sqrtf(__x: f32) -> f32;
    pub fn __sqrtf(__x: f32) -> f32;
    pub fn hypotf(__x: f32, __y: f32) -> f32;
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
    pub fn cbrtf(__x: f32) -> f32;
    pub fn __cbrtf(__x: f32) -> f32;
    pub fn ceilf(__x: f32) -> f32;
    pub fn __ceilf(__x: f32) -> f32;
    pub fn fabsf(__x: f32) -> f32;
    pub fn __fabsf(__x: f32) -> f32;
    pub fn floorf(__x: f32) -> f32;
    pub fn __floorf(__x: f32) -> f32;
    pub fn fmodf(__x: f32, __y: f32) -> f32;
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
    pub fn dremf(__x: f32, __y: f32) -> f32;
    pub fn __dremf(__x: f32, __y: f32) -> f32;
    pub fn significandf(__x: f32) -> f32;
    pub fn __significandf(__x: f32) -> f32;
    pub fn copysignf(__x: f32, __y: f32) -> f32;
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
    pub fn j0f(arg1: f32) -> f32;
    pub fn __j0f(arg1: f32) -> f32;
    pub fn j1f(arg1: f32) -> f32;
    pub fn __j1f(arg1: f32) -> f32;
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
    pub fn y0f(arg1: f32) -> f32;
    pub fn __y0f(arg1: f32) -> f32;
    pub fn y1f(arg1: f32) -> f32;
    pub fn __y1f(arg1: f32) -> f32;
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
    pub fn erff(arg1: f32) -> f32;
    pub fn __erff(arg1: f32) -> f32;
    pub fn erfcf(arg1: f32) -> f32;
    pub fn __erfcf(arg1: f32) -> f32;
    pub fn lgammaf(arg1: f32) -> f32;
    pub fn __lgammaf(arg1: f32) -> f32;
    pub fn tgammaf(arg1: f32) -> f32;
    pub fn __tgammaf(arg1: f32) -> f32;
    pub fn gammaf(arg1: f32) -> f32;
    pub fn __gammaf(arg1: f32) -> f32;
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
    pub fn rintf(__x: f32) -> f32;
    pub fn __rintf(__x: f32) -> f32;
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
    pub fn remainderf(__x: f32, __y: f32) -> f32;
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
    pub fn nearbyintf(__x: f32) -> f32;
    pub fn __nearbyintf(__x: f32) -> f32;
    pub fn roundf(__x: f32) -> f32;
    pub fn __roundf(__x: f32) -> f32;
    pub fn truncf(__x: f32) -> f32;
    pub fn __truncf(__x: f32) -> f32;
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
    pub fn fdimf(__x: f32, __y: f32) -> f32;
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
    pub fn fminf(__x: f32, __y: f32) -> f32;
    pub fn __fminf(__x: f32, __y: f32) -> f32;
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
    pub fn scalbf(__x: f32, __n: f32) -> f32;
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
    pub fn __fpclassifyl(__value: f64) -> ::std::os::raw::c_int;
    pub fn __signbitl(__value: f64) -> ::std::os::raw::c_int;
    pub fn __isinfl(__value: f64) -> ::std::os::raw::c_int;
    pub fn __finitel(__value: f64) -> ::std::os::raw::c_int;
    pub fn __isnanl(__value: f64) -> ::std::os::raw::c_int;
    pub fn __iseqsigl(__x: f64, __y: f64) -> ::std::os::raw::c_int;
    pub fn __issignalingl(__value: f64) -> ::std::os::raw::c_int;
    pub fn acosl(__x: f64) -> f64;
    pub fn __acosl(__x: f64) -> f64;
    pub fn asinl(__x: f64) -> f64;
    pub fn __asinl(__x: f64) -> f64;
    pub fn atanl(__x: f64) -> f64;
    pub fn __atanl(__x: f64) -> f64;
    pub fn atan2l(__y: f64, __x: f64) -> f64;
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
    pub fn cosl(__x: f64) -> f64;
    pub fn __cosl(__x: f64) -> f64;
    pub fn sinl(__x: f64) -> f64;
    pub fn __sinl(__x: f64) -> f64;
    pub fn tanl(__x: f64) -> f64;
    pub fn __tanl(__x: f64) -> f64;
    pub fn coshl(__x: f64) -> f64;
    pub fn __coshl(__x: f64) -> f64;
    pub fn sinhl(__x: f64) -> f64;
    pub fn __sinhl(__x: f64) -> f64;
    pub fn tanhl(__x: f64) -> f64;
    pub fn __tanhl(__x: f64) -> f64;
    pub fn acoshl(__x: f64) -> f64;
    pub fn __acoshl(__x: f64) -> f64;
    pub fn asinhl(__x: f64) -> f64;
    pub fn __asinhl(__x: f64) -> f64;
    pub fn atanhl(__x: f64) -> f64;
    pub fn __atanhl(__x: f64) -> f64;
    pub fn expl(__x: f64) -> f64;
    pub fn __expl(__x: f64) -> f64;
    pub fn frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
    pub fn __frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
    pub fn ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
    pub fn __ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
    pub fn logl(__x: f64) -> f64;
    pub fn __logl(__x: f64) -> f64;
    pub fn log10l(__x: f64) -> f64;
    pub fn __log10l(__x: f64) -> f64;
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
    pub fn expm1l(__x: f64) -> f64;
    pub fn __expm1l(__x: f64) -> f64;
    pub fn log1pl(__x: f64) -> f64;
    pub fn __log1pl(__x: f64) -> f64;
    pub fn logbl(__x: f64) -> f64;
    pub fn __logbl(__x: f64) -> f64;
    pub fn exp2l(__x: f64) -> f64;
    pub fn __exp2l(__x: f64) -> f64;
    pub fn log2l(__x: f64) -> f64;
    pub fn __log2l(__x: f64) -> f64;
    pub fn powl(__x: f64, __y: f64) -> f64;
    pub fn __powl(__x: f64, __y: f64) -> f64;
    pub fn sqrtl(__x: f64) -> f64;
    pub fn __sqrtl(__x: f64) -> f64;
    pub fn hypotl(__x: f64, __y: f64) -> f64;
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
    pub fn cbrtl(__x: f64) -> f64;
    pub fn __cbrtl(__x: f64) -> f64;
    pub fn ceill(__x: f64) -> f64;
    pub fn __ceill(__x: f64) -> f64;
    pub fn fabsl(__x: f64) -> f64;
    pub fn __fabsl(__x: f64) -> f64;
    pub fn floorl(__x: f64) -> f64;
    pub fn __floorl(__x: f64) -> f64;
    pub fn fmodl(__x: f64, __y: f64) -> f64;
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
    pub fn isinfl(__value: f64) -> ::std::os::raw::c_int;
    pub fn finitel(__value: f64) -> ::std::os::raw::c_int;
    pub fn dreml(__x: f64, __y: f64) -> f64;
    pub fn __dreml(__x: f64, __y: f64) -> f64;
    pub fn significandl(__x: f64) -> f64;
    pub fn __significandl(__x: f64) -> f64;
    pub fn copysignl(__x: f64, __y: f64) -> f64;
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
    pub fn isnanl(__value: f64) -> ::std::os::raw::c_int;
    pub fn j0l(arg1: f64) -> f64;
    pub fn __j0l(arg1: f64) -> f64;
    pub fn j1l(arg1: f64) -> f64;
    pub fn __j1l(arg1: f64) -> f64;
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn y0l(arg1: f64) -> f64;
    pub fn __y0l(arg1: f64) -> f64;
    pub fn y1l(arg1: f64) -> f64;
    pub fn __y1l(arg1: f64) -> f64;
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn erfl(arg1: f64) -> f64;
    pub fn __erfl(arg1: f64) -> f64;
    pub fn erfcl(arg1: f64) -> f64;
    pub fn __erfcl(arg1: f64) -> f64;
    pub fn lgammal(arg1: f64) -> f64;
    pub fn __lgammal(arg1: f64) -> f64;
    pub fn tgammal(arg1: f64) -> f64;
    pub fn __tgammal(arg1: f64) -> f64;
    pub fn gammal(arg1: f64) -> f64;
    pub fn __gammal(arg1: f64) -> f64;
    pub fn lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
    pub fn rintl(__x: f64) -> f64;
    pub fn __rintl(__x: f64) -> f64;
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
    pub fn remainderl(__x: f64, __y: f64) -> f64;
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
    pub fn scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
    pub fn __scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
    pub fn ilogbl(__x: f64) -> ::std::os::raw::c_int;
    pub fn __ilogbl(__x: f64) -> ::std::os::raw::c_int;
    pub fn scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
    pub fn __scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
    pub fn nearbyintl(__x: f64) -> f64;
    pub fn __nearbyintl(__x: f64) -> f64;
    pub fn roundl(__x: f64) -> f64;
    pub fn __roundl(__x: f64) -> f64;
    pub fn truncl(__x: f64) -> f64;
    pub fn __truncl(__x: f64) -> f64;
    pub fn remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
    pub fn lrintl(__x: f64) -> ::std::os::raw::c_long;
    pub fn __lrintl(__x: f64) -> ::std::os::raw::c_long;
    pub fn llrintl(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn __llrintl(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn lroundl(__x: f64) -> ::std::os::raw::c_long;
    pub fn __lroundl(__x: f64) -> ::std::os::raw::c_long;
    pub fn llroundl(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn __llroundl(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn fdiml(__x: f64, __y: f64) -> f64;
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
    pub fn fminl(__x: f64, __y: f64) -> f64;
    pub fn __fminl(__x: f64, __y: f64) -> f64;
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
    pub fn scalbl(__x: f64, __n: f64) -> f64;
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
    pub static mut signgam: ::std::os::raw::c_int;
    pub fn dimquad2dimcode(dimquad: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn rad2deg(x: f64) -> f64;
    pub fn rad2arcmin(x: f64) -> f64;
    pub fn rad2arcsec(x: f64) -> f64;
    pub fn deg2rad(x: f64) -> f64;
    pub fn deg2arcmin(x: f64) -> f64;
    pub fn deg2arcsec(x: f64) -> f64;
    pub fn arcmin2rad(x: f64) -> f64;
    pub fn arcmin2deg(x: f64) -> f64;
    pub fn arcmin2arcsec(x: f64) -> f64;
    pub fn arcsec2rad(x: f64) -> f64;
    pub fn arcsec2deg(x: f64) -> f64;
    pub fn arcsec2arcmin(x: f64) -> f64;
    pub fn mjdtojd(mjd: f64) -> f64;
    pub fn jdtomjd(jd: f64) -> f64;
    pub fn xy2ra(x: f64, y: f64) -> f64;
    pub fn z2dec(z: f64) -> f64;
    pub fn atora(str_: *const ::std::os::raw::c_char) -> f64;
    pub fn atodec(str_: *const ::std::os::raw::c_char) -> f64;
    pub fn mag2flux(mag: f64) -> f64;
    pub fn radecrange2xyzrange(
        ralow: f64,
        declow: f64,
        rahigh: f64,
        dechigh: f64,
        xyzlow: *mut f64,
        xyzhigh: *mut f64,
    );
    pub fn radec2xyz(ra: f64, dec: f64, x: *mut f64, y: *mut f64, z: *mut f64);
    pub fn xyz2radec(x: f64, y: f64, z: f64, ra: *mut f64, dec: *mut f64);
    pub fn xyzarr2radec(xyz: *const f64, ra: *mut f64, dec: *mut f64);
    pub fn xyzarr2radecarr(xyz: *const f64, radec: *mut f64);
    pub fn radec2xyzarr(ra: f64, dec: f64, p_xyz: *mut f64);
    pub fn radec2xyzarrmany(ra: *mut f64, dec: *mut f64, xyz: *mut f64, n: ::std::os::raw::c_int);
    pub fn radecdeg2xyz(ra: f64, dec: f64, x: *mut f64, y: *mut f64, z: *mut f64);
    pub fn xyzarr2radecdeg(xyz: *const f64, ra: *mut f64, dec: *mut f64);
    pub fn xyzarr2radecdegarr(xyz: *mut f64, radec: *mut f64);
    pub fn radecdeg2xyzarr(ra: f64, dec: f64, p_xyz: *mut f64);
    pub fn radecdegarr2xyzarr(radec: *mut f64, xyz: *mut f64);
    pub fn radecdeg2xyzarrmany(
        ra: *mut f64,
        dec: *mut f64,
        xyz: *mut f64,
        n: ::std::os::raw::c_int,
    );
    pub fn radec_derivatives(ra: f64, dec: f64, dra: *mut f64, ddec: *mut f64);
    pub fn distsq_between_radecdeg(ra1: f64, dec1: f64, ra2: f64, dec2: f64) -> f64;
    pub fn arcsec_between_radecdeg(ra1: f64, dec1: f64, ra2: f64, dec2: f64) -> f64;
    pub fn deg_between_radecdeg(ra1: f64, dec1: f64, ra2: f64, dec2: f64) -> f64;
    pub fn ra2mercx(ra: f64) -> f64;
    pub fn dec2mercy(dec: f64) -> f64;
    pub fn ra2hms(
        ra: f64,
        h: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        s: *mut f64,
    );
    #[doc = "inline void ra2hms(double ra, int* h, int* m, double* s) {\ndouble rem;\nra = fmod(ra, 360.0);\nif (ra < 0.0)\nra += 360.0;\nrem = ra / 15.0;\nh = floor(rem);\n// remaining (fractional) hours\nrem -= *h;\n// -> minutes\nrem *= 60.0;\nm = floor(rem);\n// remaining (fractional) minutes\nrem -= *m;\n// -> seconds\nrem *= 60.0;\ns = rem;\n}"]
    pub fn dec2dms(
        dec: f64,
        sign: *mut ::std::os::raw::c_int,
        d: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
        s: *mut f64,
    );
    pub fn hms2ra(h: ::std::os::raw::c_int, m: ::std::os::raw::c_int, s: f64) -> f64;
    pub fn dms2dec(
        sgn: ::std::os::raw::c_int,
        d: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        s: f64,
    ) -> f64;
    pub fn ra2hmsstring(ra: f64, str_: *mut ::std::os::raw::c_char);
    pub fn dec2dmsstring(dec: f64, str_: *mut ::std::os::raw::c_char);
    pub fn project_hammer_aitoff_x(x: f64, y: f64, z: f64, projx: *mut f64, projy: *mut f64);
    pub fn project_equal_area(x: f64, y: f64, z: f64, projx: *mut f64, projy: *mut f64);
    pub fn distsq2arc(dist2: f64) -> f64;
    pub fn distsq2rad(dist2: f64) -> f64;
    pub fn distsq2deg(dist2: f64) -> f64;
    pub fn dist2rad(dist: f64) -> f64;
    pub fn distsq2arcsec(dist2: f64) -> f64;
    pub fn dist2arcsec(dist: f64) -> f64;
    pub fn rad2distsq(arcInRadians: f64) -> f64;
    pub fn rad2dist(arcInRadians: f64) -> f64;
    pub fn arcsec2distsq(arcInArcSec: f64) -> f64;
    pub fn arcsec2dist(arcInArcSec: f64) -> f64;
    pub fn deg2dist(arcInDegrees: f64) -> f64;
    pub fn deg2distsq(d: f64) -> f64;
    pub fn arcmin2dist(arcmin: f64) -> f64;
    pub fn arcmin2distsq(arcmin: f64) -> f64;
    pub fn dist2deg(dist: f64) -> f64;
    pub fn make_rand_star(star: *mut f64, ramin: f64, ramax: f64, decmin: f64, decmax: f64);
    pub fn star_coords(
        s: *const f64,
        r: *const f64,
        tangent: anbool,
        x: *mut f64,
        y: *mut f64,
    ) -> anbool;
    pub fn star_midpoint(mid: *mut f64, A: *const f64, B: *const f64);
    pub fn __ctype_get_mb_cur_max() -> usize;
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
    pub fn random() -> ::std::os::raw::c_long;
    pub fn srandom(__seed: ::std::os::raw::c_uint);
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
    pub fn rand() -> ::std::os::raw::c_int;
    pub fn srand(__seed: ::std::os::raw::c_uint);
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn drand48() -> f64;
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
    pub fn lrand48() -> ::std::os::raw::c_long;
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
    pub fn mrand48() -> ::std::os::raw::c_long;
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
    pub fn srand48(__seedval: ::std::os::raw::c_long);
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
    pub fn arc4random() -> __uint32_t;
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
    pub fn malloc(__size: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
    pub fn calloc(
        __nmemb: ::std::os::raw::c_uint,
        __size: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
    pub fn alloca(__size: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void;
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_uint,
        __size: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn abort() -> !;
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn clearenv() -> ::std::os::raw::c_int;
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn qecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn qfcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn qgcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
    pub fn qecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    pub fn bl_new(blocksize: ::std::os::raw::c_int, datasize: ::std::os::raw::c_int) -> *mut bl;
    pub fn bl_init(l: *mut bl, blocksize: ::std::os::raw::c_int, datasize: ::std::os::raw::c_int);
    pub fn bl_free(list: *mut bl);
    pub fn bl_remove_all(list: *mut bl);
    pub fn bl_size(list: *const bl) -> usize;
    pub fn bl_datasize(list: *const bl) -> ::std::os::raw::c_int;
    #[doc = " Appends an element, returning the location whereto it was copied."]
    pub fn bl_append(
        list: *mut bl,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
    pub fn bl_get(list: *mut bl, n: usize, dest: *mut ::std::os::raw::c_void);
    pub fn bl_access(list: *mut bl, n: usize) -> *mut ::std::os::raw::c_void;
    pub fn bl_access_const(list: *const bl, n: usize) -> *mut ::std::os::raw::c_void;
    pub fn bl_push(
        list: *mut bl,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
    pub fn bl_pop(list: *mut bl, into: *mut ::std::os::raw::c_void);
    pub fn bl_extend(list: *mut bl) -> *mut ::std::os::raw::c_void;
    #[doc = "Removes elements from \\c split\nto the end of the list from \\c src and appends them to \\c dest."]
    pub fn bl_split(src: *mut bl, dest: *mut bl, split: usize);
    pub fn bl_reverse(list: *mut bl);
    pub fn bl_append_list(list1: *mut bl, list2: *mut bl);
    pub fn bl_insert(list: *mut bl, indx: usize, data: *const ::std::os::raw::c_void);
    pub fn bl_set(list: *mut bl, indx: usize, data: *const ::std::os::raw::c_void);
    pub fn bl_print_structure(list: *mut bl);
    pub fn bl_copy(list: *mut bl, start: usize, length: usize, vdest: *mut ::std::os::raw::c_void);
    #[doc = " Inserts the given datum into the list in such a way that the list\n stays sorted in ascending order according to the given comparison\n function (assuming it was sorted to begin with!).\n\n The inserted element will be placed _after_ existing elements with\n the same value.\n\n The comparison function is the same as qsort's: it should return\n 1 if the first arg is greater than the second arg\n 0 if they're equal\n -1 if the first arg is smaller.\n\n The index where the element was inserted is returned."]
    pub fn bl_insert_sorted(
        list: *mut bl,
        data: *const ::std::os::raw::c_void,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                v1: *const ::std::os::raw::c_void,
                v2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> usize;
    #[doc = "If the item already existed in the list (ie, the compare function\nreturned zero), then -1 is returned.  Otherwise, the index at which\nthe item was inserted is returned."]
    pub fn bl_insert_unique_sorted(
        list: *mut bl,
        data: *const ::std::os::raw::c_void,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                v1: *const ::std::os::raw::c_void,
                v2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> isize;
    pub fn bl_remove_all_but_first(list: *mut bl);
    pub fn bl_remove_index(list: *mut bl, indx: usize);
    pub fn bl_remove_index_range(list: *mut bl, start: usize, length: usize);
    pub fn bl_find(
        list: *mut bl,
        data: *const ::std::os::raw::c_void,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                v1: *const ::std::os::raw::c_void,
                v2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
    pub fn bl_find_index(
        list: *mut bl,
        data: *const ::std::os::raw::c_void,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                v1: *const ::std::os::raw::c_void,
                v2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> isize;
    pub fn bl_check_consistency(list: *mut bl) -> ::std::os::raw::c_int;
    pub fn bl_check_sorted(
        list: *mut bl,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                v1: *const ::std::os::raw::c_void,
                v2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sl_new(blocksize: ::std::os::raw::c_int) -> *mut sl;
    pub fn sl_init2(list: *mut sl, blocksize: ::std::os::raw::c_int);
    pub fn sl_free2(list: *mut sl);
    pub fn sl_append_contents(dest: *mut sl, src: *mut sl);
    pub fn sl_index_of(lst: *mut sl, str_: *const ::std::os::raw::c_char) -> isize;
    pub fn sl_last_index_of(lst: *mut sl, str_: *const ::std::os::raw::c_char) -> isize;
    pub fn sl_contains(lst: *mut sl, str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn sl_free_nonrecursive(list: *mut sl);
    pub fn sl_size(list: *const sl) -> usize;
    pub fn sl_append(
        list: *mut sl,
        string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_append_nocopy(list: *mut sl, string: *const ::std::os::raw::c_char);
    pub fn sl_append_array(list: *mut sl, strings: *mut *const ::std::os::raw::c_char, n: usize);
    pub fn sl_push(
        list: *mut sl,
        data: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_pop(list: *mut sl) -> *mut ::std::os::raw::c_char;
    pub fn sl_get(list: *mut sl, n: usize) -> *mut ::std::os::raw::c_char;
    pub fn sl_get_const(list: *const sl, n: usize) -> *mut ::std::os::raw::c_char;
    pub fn sl_set(
        list: *mut sl,
        n: usize,
        val: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_check_consistency(list: *mut sl) -> ::std::os::raw::c_int;
    pub fn sl_insert(
        list: *mut sl,
        indx: usize,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_insert_nocopy(list: *mut sl, indx: usize, str_: *const ::std::os::raw::c_char);
    pub fn sl_remove_all(list: *mut sl);
    pub fn sl_insert_sorted_nocopy(list: *mut sl, string: *const ::std::os::raw::c_char);
    pub fn sl_insert_sorted(
        list: *mut sl,
        string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_insert_sortedf(
        list: *mut sl,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_remove_index_range(list: *mut sl, start: usize, length: usize);
    pub fn sl_remove(list: *mut sl, index: usize);
    pub fn sl_remove_string(list: *mut sl, string: *const ::std::os::raw::c_char) -> isize;
    pub fn sl_remove_string_bycaseval(
        list: *mut sl,
        string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_remove_string_byval(list: *mut sl, string: *const ::std::os::raw::c_char) -> isize;
    pub fn sl_remove_from(list: *mut sl, start: usize);
    pub fn sl_merge_lists(list1: *mut sl, list2: *mut sl);
    pub fn sl_print(list: *mut sl);
    pub fn sl_remove_duplicates(lst: *mut sl);
    pub fn sl_split(
        lst: *mut sl,
        str_: *const ::std::os::raw::c_char,
        sepstring: *const ::std::os::raw::c_char,
    ) -> *mut sl;
    pub fn sl_implode(
        list: *mut sl,
        join: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_join(
        list: *mut sl,
        joinstring: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_join_reverse(
        list: *mut sl,
        join: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_appendf(
        list: *mut sl,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_appendvf(
        list: *mut sl,
        format: *const ::std::os::raw::c_char,
        va: va_list,
    ) -> *mut ::std::os::raw::c_char;
    pub fn sl_insertf(
        list: *mut sl,
        index: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
    pub fn il_new(blocksize: ::std::os::raw::c_int) -> *mut il;
    pub fn il_size(list: *const il) -> usize;
    pub fn il_new_existing(list: *mut il, blocksize: ::std::os::raw::c_int);
    pub fn il_init(list: *mut il, blocksize: ::std::os::raw::c_int);
    pub fn il_reverse(list: *mut il);
    pub fn il_remove_all(list: *mut il);
    pub fn il_remove_all_reuse(list: *mut il);
    pub fn il_free(list: *mut il);
    pub fn il_append(list: *mut il, data: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_int;
    pub fn il_append_list(list: *mut il, list2: *mut il);
    pub fn il_append_array(list: *mut il, data: *const ::std::os::raw::c_int, ndata: usize);
    pub fn il_merge_lists(list1: *mut il, list2: *mut il);
    pub fn il_push(list: *mut il, data: ::std::os::raw::c_int);
    pub fn il_pop(list: *mut il) -> ::std::os::raw::c_int;
    pub fn il_contains(list: *mut il, data: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn il_sorted_contains(list: *mut il, data: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn il_sorted_index_of(list: *mut il, data: ::std::os::raw::c_int) -> isize;
    pub fn il_sort(list: *mut il, ascending: ::std::os::raw::c_int);
    pub fn il_to_array(list: *mut il) -> *mut ::std::os::raw::c_int;
    pub fn il_index_of(list: *mut il, data: ::std::os::raw::c_int) -> isize;
    pub fn il_get(list: *mut il, n: usize) -> ::std::os::raw::c_int;
    pub fn il_get_const(list: *const il, n: usize) -> ::std::os::raw::c_int;
    pub fn il_access(list: *mut il, n: usize) -> *mut ::std::os::raw::c_int;
    pub fn il_copy(list: *mut il, start: usize, length: usize, vdest: *mut ::std::os::raw::c_int);
    pub fn il_dupe(list: *mut il) -> *mut il;
    pub fn il_print(list: *mut il);
    pub fn il_insert(list: *mut il, indx: usize, data: ::std::os::raw::c_int);
    pub fn il_insert_ascending(list: *mut il, n: ::std::os::raw::c_int) -> usize;
    pub fn il_insert_descending(list: *mut il, n: ::std::os::raw::c_int) -> usize;
    pub fn il_insert_unique_ascending(list: *mut il, p: ::std::os::raw::c_int) -> isize;
    pub fn il_set(list: *mut il, ind: usize, value: ::std::os::raw::c_int);
    pub fn il_remove(list: *mut il, ind: usize);
    pub fn il_remove_index_range(list: *mut il, start: usize, length: usize);
    pub fn il_find_index_ascending(list: *mut il, value: ::std::os::raw::c_int) -> isize;
    pub fn il_merge_ascending(list1: *mut il, list2: *mut il) -> *mut il;
    pub fn il_remove_value(list: *mut il, value: ::std::os::raw::c_int) -> isize;
    pub fn il_check_consistency(list: *mut il) -> ::std::os::raw::c_int;
    pub fn il_check_sorted_ascending(
        list: *mut il,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn il_check_sorted_descending(
        list: *mut il,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ll_new(blocksize: ::std::os::raw::c_int) -> *mut ll;
    pub fn ll_size(list: *const ll) -> usize;
    pub fn ll_new_existing(list: *mut ll, blocksize: ::std::os::raw::c_int);
    pub fn ll_init(list: *mut ll, blocksize: ::std::os::raw::c_int);
    pub fn ll_reverse(list: *mut ll);
    pub fn ll_remove_all(list: *mut ll);
    pub fn ll_remove_all_reuse(list: *mut ll);
    pub fn ll_free(list: *mut ll);
    pub fn ll_append(list: *mut ll, data: i64) -> *mut i64;
    pub fn ll_append_list(list: *mut ll, list2: *mut ll);
    pub fn ll_append_array(list: *mut ll, data: *const i64, ndata: usize);
    pub fn ll_merge_lists(list1: *mut ll, list2: *mut ll);
    pub fn ll_push(list: *mut ll, data: i64);
    pub fn ll_pop(list: *mut ll) -> i64;
    pub fn ll_contains(list: *mut ll, data: i64) -> ::std::os::raw::c_int;
    pub fn ll_sorted_contains(list: *mut ll, data: i64) -> ::std::os::raw::c_int;
    pub fn ll_sorted_index_of(list: *mut ll, data: i64) -> isize;
    pub fn ll_sort(list: *mut ll, ascending: ::std::os::raw::c_int);
    pub fn ll_to_array(list: *mut ll) -> *mut i64;
    pub fn ll_index_of(list: *mut ll, data: i64) -> isize;
    pub fn ll_get(list: *mut ll, n: usize) -> i64;
    pub fn ll_get_const(list: *const ll, n: usize) -> i64;
    pub fn ll_access(list: *mut ll, n: usize) -> *mut i64;
    pub fn ll_copy(list: *mut ll, start: usize, length: usize, vdest: *mut i64);
    pub fn ll_dupe(list: *mut ll) -> *mut ll;
    pub fn ll_print(list: *mut ll);
    pub fn ll_insert(list: *mut ll, indx: usize, data: i64);
    pub fn ll_insert_ascending(list: *mut ll, n: i64) -> usize;
    pub fn ll_insert_descending(list: *mut ll, n: i64) -> usize;
    pub fn ll_insert_unique_ascending(list: *mut ll, p: i64) -> isize;
    pub fn ll_set(list: *mut ll, ind: usize, value: i64);
    pub fn ll_remove(list: *mut ll, ind: usize);
    pub fn ll_remove_index_range(list: *mut ll, start: usize, length: usize);
    pub fn ll_find_index_ascending(list: *mut ll, value: i64) -> isize;
    pub fn ll_merge_ascending(list1: *mut ll, list2: *mut ll) -> *mut ll;
    pub fn ll_remove_value(list: *mut ll, value: i64) -> isize;
    pub fn ll_check_consistency(list: *mut ll) -> ::std::os::raw::c_int;
    pub fn ll_check_sorted_ascending(
        list: *mut ll,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ll_check_sorted_descending(
        list: *mut ll,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn dl_new(blocksize: ::std::os::raw::c_int) -> *mut dl;
    pub fn dl_size(list: *const dl) -> usize;
    pub fn dl_new_existing(list: *mut dl, blocksize: ::std::os::raw::c_int);
    pub fn dl_init(list: *mut dl, blocksize: ::std::os::raw::c_int);
    pub fn dl_reverse(list: *mut dl);
    pub fn dl_remove_all(list: *mut dl);
    pub fn dl_remove_all_reuse(list: *mut dl);
    pub fn dl_free(list: *mut dl);
    pub fn dl_append(list: *mut dl, data: f64) -> *mut f64;
    pub fn dl_append_list(list: *mut dl, list2: *mut dl);
    pub fn dl_append_array(list: *mut dl, data: *const f64, ndata: usize);
    pub fn dl_merge_lists(list1: *mut dl, list2: *mut dl);
    pub fn dl_push(list: *mut dl, data: f64);
    pub fn dl_pop(list: *mut dl) -> f64;
    pub fn dl_contains(list: *mut dl, data: f64) -> ::std::os::raw::c_int;
    pub fn dl_sorted_contains(list: *mut dl, data: f64) -> ::std::os::raw::c_int;
    pub fn dl_sorted_index_of(list: *mut dl, data: f64) -> isize;
    pub fn dl_sort(list: *mut dl, ascending: ::std::os::raw::c_int);
    pub fn dl_to_array(list: *mut dl) -> *mut f64;
    pub fn dl_index_of(list: *mut dl, data: f64) -> isize;
    pub fn dl_get(list: *mut dl, n: usize) -> f64;
    pub fn dl_get_const(list: *const dl, n: usize) -> f64;
    pub fn dl_access(list: *mut dl, n: usize) -> *mut f64;
    pub fn dl_copy(list: *mut dl, start: usize, length: usize, vdest: *mut f64);
    pub fn dl_dupe(list: *mut dl) -> *mut dl;
    pub fn dl_print(list: *mut dl);
    pub fn dl_insert(list: *mut dl, indx: usize, data: f64);
    pub fn dl_insert_ascending(list: *mut dl, n: f64) -> usize;
    pub fn dl_insert_descending(list: *mut dl, n: f64) -> usize;
    pub fn dl_insert_unique_ascending(list: *mut dl, p: f64) -> isize;
    pub fn dl_set(list: *mut dl, ind: usize, value: f64);
    pub fn dl_remove(list: *mut dl, ind: usize);
    pub fn dl_remove_index_range(list: *mut dl, start: usize, length: usize);
    pub fn dl_find_index_ascending(list: *mut dl, value: f64) -> isize;
    pub fn dl_merge_ascending(list1: *mut dl, list2: *mut dl) -> *mut dl;
    pub fn dl_remove_value(list: *mut dl, value: f64) -> isize;
    pub fn dl_check_consistency(list: *mut dl) -> ::std::os::raw::c_int;
    pub fn dl_check_sorted_ascending(
        list: *mut dl,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn dl_check_sorted_descending(
        list: *mut dl,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fl_new(blocksize: ::std::os::raw::c_int) -> *mut fl;
    pub fn fl_size(list: *const fl) -> usize;
    pub fn fl_new_existing(list: *mut fl, blocksize: ::std::os::raw::c_int);
    pub fn fl_init(list: *mut fl, blocksize: ::std::os::raw::c_int);
    pub fn fl_reverse(list: *mut fl);
    pub fn fl_remove_all(list: *mut fl);
    pub fn fl_remove_all_reuse(list: *mut fl);
    pub fn fl_free(list: *mut fl);
    pub fn fl_append(list: *mut fl, data: f32) -> *mut f32;
    pub fn fl_append_list(list: *mut fl, list2: *mut fl);
    pub fn fl_append_array(list: *mut fl, data: *const f32, ndata: usize);
    pub fn fl_merge_lists(list1: *mut fl, list2: *mut fl);
    pub fn fl_push(list: *mut fl, data: f32);
    pub fn fl_pop(list: *mut fl) -> f32;
    pub fn fl_contains(list: *mut fl, data: f32) -> ::std::os::raw::c_int;
    pub fn fl_sorted_contains(list: *mut fl, data: f32) -> ::std::os::raw::c_int;
    pub fn fl_sorted_index_of(list: *mut fl, data: f32) -> isize;
    pub fn fl_sort(list: *mut fl, ascending: ::std::os::raw::c_int);
    pub fn fl_to_array(list: *mut fl) -> *mut f32;
    pub fn fl_index_of(list: *mut fl, data: f32) -> isize;
    pub fn fl_get(list: *mut fl, n: usize) -> f32;
    pub fn fl_get_const(list: *const fl, n: usize) -> f32;
    pub fn fl_access(list: *mut fl, n: usize) -> *mut f32;
    pub fn fl_copy(list: *mut fl, start: usize, length: usize, vdest: *mut f32);
    pub fn fl_dupe(list: *mut fl) -> *mut fl;
    pub fn fl_print(list: *mut fl);
    pub fn fl_insert(list: *mut fl, indx: usize, data: f32);
    pub fn fl_insert_ascending(list: *mut fl, n: f32) -> usize;
    pub fn fl_insert_descending(list: *mut fl, n: f32) -> usize;
    pub fn fl_insert_unique_ascending(list: *mut fl, p: f32) -> isize;
    pub fn fl_set(list: *mut fl, ind: usize, value: f32);
    pub fn fl_remove(list: *mut fl, ind: usize);
    pub fn fl_remove_index_range(list: *mut fl, start: usize, length: usize);
    pub fn fl_find_index_ascending(list: *mut fl, value: f32) -> isize;
    pub fn fl_merge_ascending(list1: *mut fl, list2: *mut fl) -> *mut fl;
    pub fn fl_remove_value(list: *mut fl, value: f32) -> isize;
    pub fn fl_check_consistency(list: *mut fl) -> ::std::os::raw::c_int;
    pub fn fl_check_sorted_ascending(
        list: *mut fl,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fl_check_sorted_descending(
        list: *mut fl,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pl_new(blocksize: ::std::os::raw::c_int) -> *mut pl;
    pub fn pl_size(list: *const pl) -> usize;
    pub fn pl_new_existing(list: *mut pl, blocksize: ::std::os::raw::c_int);
    pub fn pl_init(list: *mut pl, blocksize: ::std::os::raw::c_int);
    pub fn pl_reverse(list: *mut pl);
    pub fn pl_remove_all(list: *mut pl);
    pub fn pl_remove_all_reuse(list: *mut pl);
    pub fn pl_free(list: *mut pl);
    pub fn pl_append(
        list: *mut pl,
        data: *const ::std::os::raw::c_void,
    ) -> *mut *mut ::std::os::raw::c_void;
    pub fn pl_append_list(list: *mut pl, list2: *mut pl);
    pub fn pl_append_array(list: *mut pl, data: *mut *const ::std::os::raw::c_void, ndata: usize);
    pub fn pl_merge_lists(list1: *mut pl, list2: *mut pl);
    pub fn pl_push(list: *mut pl, data: *const ::std::os::raw::c_void);
    pub fn pl_pop(list: *mut pl) -> *mut ::std::os::raw::c_void;
    pub fn pl_contains(list: *mut pl, data: *const ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
    pub fn pl_sorted_contains(
        list: *mut pl,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn pl_sorted_index_of(list: *mut pl, data: *const ::std::os::raw::c_void) -> isize;
    pub fn pl_to_array(list: *mut pl) -> *mut *mut ::std::os::raw::c_void;
    pub fn pl_index_of(list: *mut pl, data: *const ::std::os::raw::c_void) -> isize;
    pub fn pl_get(list: *mut pl, n: usize) -> *mut ::std::os::raw::c_void;
    pub fn pl_get_const(list: *const pl, n: usize) -> *mut ::std::os::raw::c_void;
    pub fn pl_access(list: *mut pl, n: usize) -> *mut *mut ::std::os::raw::c_void;
    pub fn pl_copy(
        list: *mut pl,
        start: usize,
        length: usize,
        vdest: *mut *mut ::std::os::raw::c_void,
    );
    pub fn pl_dupe(list: *mut pl) -> *mut pl;
    pub fn pl_print(list: *mut pl);
    pub fn pl_insert(list: *mut pl, indx: usize, data: *const ::std::os::raw::c_void);
    pub fn pl_insert_ascending(list: *mut pl, n: *const ::std::os::raw::c_void) -> usize;
    pub fn pl_insert_descending(list: *mut pl, n: *const ::std::os::raw::c_void) -> usize;
    pub fn pl_insert_unique_ascending(list: *mut pl, p: *const ::std::os::raw::c_void) -> isize;
    pub fn pl_set(list: *mut pl, ind: usize, value: *const ::std::os::raw::c_void);
    pub fn pl_remove(list: *mut pl, ind: usize);
    pub fn pl_remove_index_range(list: *mut pl, start: usize, length: usize);
    pub fn pl_find_index_ascending(list: *mut pl, value: *const ::std::os::raw::c_void) -> isize;
    pub fn pl_merge_ascending(list1: *mut pl, list2: *mut pl) -> *mut pl;
    pub fn pl_remove_value(list: *mut pl, value: *const ::std::os::raw::c_void) -> isize;
    pub fn pl_check_consistency(list: *mut pl) -> ::std::os::raw::c_int;
    pub fn pl_check_sorted_ascending(
        list: *mut pl,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pl_check_sorted_descending(
        list: *mut pl,
        isunique: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = " Special functions ////////"]
    pub fn pl_free_elements(list: *mut pl);
    pub fn pl_insert_sorted(
        list: *mut pl,
        data: *const ::std::os::raw::c_void,
        compare: ::std::option::Option<
            unsafe extern "C" fn(
                v1: *const ::std::os::raw::c_void,
                v2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> usize;
    pub fn starxy_new(N: ::std::os::raw::c_int, flux: anbool, back: anbool) -> *mut starxy_t;
    pub fn starxy_compute_range(xy: *mut starxy_t);
    pub fn starxy_getx(f: *const starxy_t, i: ::std::os::raw::c_int) -> f64;
    pub fn starxy_gety(f: *const starxy_t, i: ::std::os::raw::c_int) -> f64;
    pub fn starxy_get_x(f: *const starxy_t, i: ::std::os::raw::c_int) -> f64;
    pub fn starxy_get_y(f: *const starxy_t, i: ::std::os::raw::c_int) -> f64;
    pub fn starxy_get_flux(f: *const starxy_t, i: ::std::os::raw::c_int) -> f64;
    pub fn starxy_get(f: *const starxy_t, i: ::std::os::raw::c_int, xy: *mut f64);
    pub fn starxy_setx(f: *mut starxy_t, i: ::std::os::raw::c_int, x: f64);
    pub fn starxy_sety(f: *mut starxy_t, i: ::std::os::raw::c_int, y: f64);
    pub fn starxy_set_x(f: *mut starxy_t, i: ::std::os::raw::c_int, x: f64);
    pub fn starxy_set_y(f: *mut starxy_t, i: ::std::os::raw::c_int, y: f64);
    pub fn starxy_set_flux(f: *mut starxy_t, i: ::std::os::raw::c_int, y: f64);
    pub fn starxy_subset(arg1: *mut starxy_t, N: ::std::os::raw::c_int) -> *mut starxy_t;
    pub fn starxy_set_x_array(s: *mut starxy_t, x: *const f64);
    pub fn starxy_set_y_array(s: *mut starxy_t, y: *const f64);
    pub fn starxy_set_flux_array(s: *mut starxy_t, f: *const f64);
    pub fn starxy_set_bg_array(s: *mut starxy_t, f: *const f64);
    pub fn starxy_set_xy_array(s: *mut starxy_t, xy: *const f64);
    pub fn starxy_sort_by_flux(f: *mut starxy_t);
    pub fn starxy_set(f: *mut starxy_t, i: ::std::os::raw::c_int, x: f64, y: f64);
    pub fn starxy_n(f: *const starxy_t) -> ::std::os::raw::c_int;
    pub fn starxy_copy_x(xy: *const starxy_t) -> *mut f64;
    pub fn starxy_copy_y(xy: *const starxy_t) -> *mut f64;
    pub fn starxy_copy_xy(xy: *const starxy_t) -> *mut f64;
    pub fn starxy_to_xy_array(xy: *mut starxy_t, arr: *mut f64) -> *mut f64;
    pub fn starxy_to_flat_array(xy: *mut starxy_t, arr: *mut f64) -> *mut f64;
    pub fn starxy_alloc_data(
        f: *mut starxy_t,
        N: ::std::os::raw::c_int,
        flux: anbool,
        back: anbool,
    );
    pub fn starxy_from_dl(xy: *mut starxy_t, l: *mut dl, flux: anbool, back: anbool);
    pub fn starxy_free_data(f: *mut starxy_t);
    pub fn starxy_free(f: *mut starxy_t);
    pub fn kdtree_n(kd: *const kdtree_t) -> ::std::os::raw::c_int;
    pub fn kdtree_nnodes(kd: *const kdtree_t) -> ::std::os::raw::c_int;
    pub fn kdtree_has_old_bb(kd: *const kdtree_t) -> ::std::os::raw::c_int;
    pub fn kdtree_get_conservative_query_radius(kd: *const kdtree_t, radius: f64) -> f64;
    pub fn kdtree_sizeof_lr(kd: *const kdtree_t) -> usize;
    pub fn kdtree_sizeof_perm(kd: *const kdtree_t) -> usize;
    pub fn kdtree_sizeof_bb(kd: *const kdtree_t) -> usize;
    pub fn kdtree_sizeof_split(kd: *const kdtree_t) -> usize;
    pub fn kdtree_sizeof_splitdim(kd: *const kdtree_t) -> usize;
    pub fn kdtree_sizeof_data(kd: *const kdtree_t) -> usize;
    pub fn kdtree_sizeof_nodes(kd: *const kdtree_t) -> usize;
    pub fn kdtree_memory_report(kd: *mut kdtree_t);
    pub fn kdtree_new(
        N: ::std::os::raw::c_int,
        D: ::std::os::raw::c_int,
        Nleaf: ::std::os::raw::c_int,
    ) -> *mut kdtree_t;
    pub fn kdtree_print(kd: *mut kdtree_t);
    pub fn kdtree_update_funcs(kd: *mut kdtree_t);
    pub fn kdtree_set_limits(kd: *mut kdtree_t, low: *mut f64, high: *mut f64);
    pub fn kdtree_get_data(
        kd: *const kdtree_t,
        i: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn kdtree_copy_data_double(
        kd: *const kdtree_t,
        i: ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
        dest: *mut f64,
    );
    pub fn kdtree_kdtype_to_string(kdtype: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    pub fn kdtree_build_options_to_string(
        opts: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
    pub fn kdtree_kdtype_parse_data_string(
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_kdtype_parse_tree_string(
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_kdtype_parse_ext_string(
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_kdtypes_to_treetype(
        exttype: ::std::os::raw::c_int,
        treetype: ::std::os::raw::c_int,
        datatype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_permute(
        tree: *const kdtree_t,
        ind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_inverse_permutation(tree: *const kdtree_t, invperm: *mut ::std::os::raw::c_int);
    pub fn kdtree_free_query(res: *mut kdtree_qres_t);
    pub fn kdtree_free(kd: *mut kdtree_t);
    pub fn kdtree_is_node_empty(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_is_leaf_node_empty(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_left(kd: *const kdtree_t, nodeid: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    pub fn kdtree_right(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_leaf_right(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_leaf_left(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_npoints(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_first_leaf(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_last_leaf(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_level_start(
        kd: *const kdtree_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_level_end(
        kd: *const kdtree_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_get_level(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_nnodes_to_nlevels(Nnodes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn kdtree_nearest_neighbour(
        kd: *const kdtree_t,
        pt: *const ::std::os::raw::c_void,
        bestd2: *mut f64,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_nearest_neighbour_within(
        kd: *const kdtree_t,
        pt: *const ::std::os::raw::c_void,
        maxd2: f64,
        bestd2: *mut f64,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_nodes_contained(
        kd: *const kdtree_t,
        querylow: *const ::std::os::raw::c_void,
        queryhi: *const ::std::os::raw::c_void,
        callback_contained: ::std::option::Option<
            unsafe extern "C" fn(
                kd: *const kdtree_t,
                node: ::std::os::raw::c_int,
                extra: *mut ::std::os::raw::c_void,
            ),
        >,
        callback_overlap: ::std::option::Option<
            unsafe extern "C" fn(
                kd: *const kdtree_t,
                node: ::std::os::raw::c_int,
                extra: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_extra: *mut ::std::os::raw::c_void,
    );
    pub fn kdtree_get_bboxes(
        kd: *const kdtree_t,
        node: ::std::os::raw::c_int,
        bblo: *mut ::std::os::raw::c_void,
        bbhi: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_get_splitval(kd: *const kdtree_t, nodeid: ::std::os::raw::c_int) -> f64;
    pub fn kdtree_get_splitdim(
        kd: *const kdtree_t,
        nodeid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_node_node_mindist2(
        kd1: *const kdtree_t,
        node1: ::std::os::raw::c_int,
        kd2: *const kdtree_t,
        node2: ::std::os::raw::c_int,
    ) -> f64;
    pub fn kdtree_node_node_maxdist2(
        kd1: *const kdtree_t,
        node1: ::std::os::raw::c_int,
        kd2: *const kdtree_t,
        node2: ::std::os::raw::c_int,
    ) -> f64;
    pub fn kdtree_node_node_mindist2_exceeds(
        kd1: *const kdtree_t,
        node1: ::std::os::raw::c_int,
        kd2: *const kdtree_t,
        node2: ::std::os::raw::c_int,
        dist2: f64,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_node_node_maxdist2_exceeds(
        kd1: *const kdtree_t,
        node1: ::std::os::raw::c_int,
        kd2: *const kdtree_t,
        node2: ::std::os::raw::c_int,
        dist2: f64,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_node_point_mindist2(
        kd: *const kdtree_t,
        node: ::std::os::raw::c_int,
        pt: *const ::std::os::raw::c_void,
    ) -> f64;
    pub fn kdtree_node_point_maxdist2(
        kd: *const kdtree_t,
        node: ::std::os::raw::c_int,
        pt: *const ::std::os::raw::c_void,
    ) -> f64;
    pub fn kdtree_node_point_mindist2_exceeds(
        kd: *const kdtree_t,
        node: ::std::os::raw::c_int,
        pt: *const ::std::os::raw::c_void,
        dist2: f64,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_node_point_maxdist2_exceeds(
        kd: *const kdtree_t,
        node: ::std::os::raw::c_int,
        pt: *const ::std::os::raw::c_void,
        dist2: f64,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_check(t: *const kdtree_t) -> ::std::os::raw::c_int;
    pub fn kdtree_fix_bounding_boxes(kd: *mut kdtree_t);
    pub fn kdtree_build(
        kd: *mut kdtree_t,
        data: *mut ::std::os::raw::c_void,
        N: ::std::os::raw::c_int,
        D: ::std::os::raw::c_int,
        Nleaf: ::std::os::raw::c_int,
        treetype: ::std::os::raw::c_int,
        options: ::std::os::raw::c_uint,
    ) -> *mut kdtree_t;
    pub fn kdtree_build_2(
        kd: *mut kdtree_t,
        data: *mut ::std::os::raw::c_void,
        N: ::std::os::raw::c_int,
        D: ::std::os::raw::c_int,
        Nleaf: ::std::os::raw::c_int,
        treetype: ::std::os::raw::c_int,
        options: ::std::os::raw::c_uint,
        minval: *mut f64,
        maxval: *mut f64,
    ) -> *mut kdtree_t;
    pub fn kdtree_rangesearch(
        kd: *const kdtree_t,
        pt: *const ::std::os::raw::c_void,
        maxd2: f64,
    ) -> *mut kdtree_qres_t;
    pub fn kdtree_rangesearch_nosort(
        kd: *const kdtree_t,
        pt: *const ::std::os::raw::c_void,
        maxd2: f64,
    ) -> *mut kdtree_qres_t;
    pub fn kdtree_rangesearch_options(
        kd: *const kdtree_t,
        pt: *const ::std::os::raw::c_void,
        maxd2: f64,
        options: ::std::os::raw::c_int,
    ) -> *mut kdtree_qres_t;
    pub fn kdtree_rangesearch_options_reuse(
        kd: *const kdtree_t,
        res: *mut kdtree_qres_t,
        pt: *const ::std::os::raw::c_void,
        maxd2: f64,
        options: ::std::os::raw::c_int,
    ) -> *mut kdtree_qres_t;
    pub fn sip_create() -> *mut sip_t;
    pub fn sip_free(sip: *mut sip_t);
    pub fn sip_copy(dest: *mut sip_t, src: *const sip_t);
    pub fn sip_wrap_tan(tan: *const tan_t, sip: *mut sip_t);
    pub fn sip_imagew(sip: *mut sip_t) -> f64;
    pub fn sip_imageh(sip: *mut sip_t) -> f64;
    pub fn sip_pixelxy2radec(sip: *const sip_t, px: f64, py: f64, a: *mut f64, d: *mut f64);
    pub fn sip_pixelxy2xyzarr(sip: *const sip_t, px: f64, py: f64, xyz: *mut f64);
    pub fn sip_radec2pixelxy(
        sip: *const sip_t,
        a: f64,
        d: f64,
        px: *mut f64,
        py: *mut f64,
    ) -> anbool;
    pub fn sip_radec2pixelxy_check(
        sip: *const sip_t,
        ra: f64,
        dec: f64,
        px: *mut f64,
        py: *mut f64,
    ) -> anbool;
    pub fn sip_xyzarr2pixelxy(
        sip: *const sip_t,
        xyz: *const f64,
        px: *mut f64,
        py: *mut f64,
    ) -> anbool;
    pub fn sip_xyz2pixelxy(
        sip: *const sip_t,
        x: f64,
        y: f64,
        z: f64,
        px: *mut f64,
        py: *mut f64,
    ) -> anbool;
    pub fn sip_pixelxy2iwc(sip: *const sip_t, px: f64, py: f64, iwcx: *mut f64, iwcy: *mut f64);
    pub fn tan_det_cd(tan: *const tan_t) -> f64;
    pub fn sip_det_cd(sip: *const sip_t) -> f64;
    pub fn tan_pixel_scale(tn: *const tan_t) -> f64;
    pub fn sip_pixel_scale(sip: *const sip_t) -> f64;
    pub fn sip_calc_inv_distortion(sip: *const sip_t, U: f64, V: f64, u: *mut f64, v: *mut f64);
    pub fn sip_calc_distortion(sip: *const sip_t, u: f64, v: f64, U: *mut f64, V: *mut f64);
    pub fn sip_pixel_distortion(sip: *const sip_t, x: f64, y: f64, p_x: *mut f64, p_y: *mut f64);
    pub fn sip_pixel_undistortion(sip: *const sip_t, x: f64, y: f64, p_x: *mut f64, p_y: *mut f64);
    pub fn tan_pixelxy2xyzarr(tan: *const tan_t, px: f64, py: f64, xyz: *mut f64);
    pub fn tan_pixelxy2radec(wcs_tan: *const tan_t, px: f64, py: f64, ra: *mut f64, dec: *mut f64);
    pub fn tan_pixelxy2radecarr(wcs_tan: *const tan_t, px: f64, py: f64, radec: *mut f64);
    pub fn tan_radec2pixelxy(
        wcs_tan: *const tan_t,
        ra: f64,
        dec: f64,
        px: *mut f64,
        py: *mut f64,
    ) -> anbool;
    pub fn tan_xyzarr2pixelxy(
        wcs_tan: *const tan_t,
        xyz: *const f64,
        px: *mut f64,
        py: *mut f64,
    ) -> anbool;
    pub fn tan_iwc2pixelxy(tan: *const tan_t, iwcx: f64, iwcy: f64, px: *mut f64, py: *mut f64);
    pub fn tan_iwc2xyzarr(tan: *const tan_t, x: f64, y: f64, xyz: *mut f64);
    pub fn tan_iwc2radec(tan: *const tan_t, x: f64, y: f64, p_ra: *mut f64, p_dec: *mut f64);
    #[doc = "Subtracts off CRPIX, multiplies by CD matrix.\nResults are in degrees."]
    pub fn tan_pixelxy2iwc(tan: *const tan_t, px: f64, py: f64, iwcx: *mut f64, iwcy: *mut f64);
    pub fn tan_xyzarr2iwc(
        tan: *const tan_t,
        xyz: *const f64,
        iwcx: *mut f64,
        iwcy: *mut f64,
    ) -> anbool;
    pub fn tan_radec2iwc(
        tan: *const tan_t,
        ra: f64,
        dec: f64,
        iwcx: *mut f64,
        iwcy: *mut f64,
    ) -> anbool;
    pub fn sip_xyzarr2iwc(
        sip: *const sip_t,
        xyz: *const f64,
        iwcx: *mut f64,
        iwcy: *mut f64,
    ) -> anbool;
    pub fn sip_radec2iwc(
        sip: *const sip_t,
        ra: f64,
        dec: f64,
        iwcx: *mut f64,
        iwcy: *mut f64,
    ) -> anbool;
    pub fn sip_iwc2pixelxy(sip: *const sip_t, iwcx: f64, iwcy: f64, px: *mut f64, py: *mut f64);
    pub fn sip_iwc2radec(sip: *const sip_t, x: f64, y: f64, p_ra: *mut f64, p_dec: *mut f64);
    pub fn sip_print(arg1: *const sip_t);
    pub fn sip_print_to(arg1: *const sip_t);
    pub fn tan_print(tan: *const tan_t);
    pub fn tan_print_to(tan: *const tan_t);
    pub fn sip_get_crval(sip: *const sip_t, ra: *mut f64, dec: *mut f64);
    pub fn tan_get_orientation(tan: *const tan_t) -> f64;
    pub fn sip_get_orientation(sip: *const sip_t) -> f64;
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_uint);
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
    pub fn pause() -> ::std::os::raw::c_int;
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
    pub fn getpid() -> __pid_t;
    pub fn getppid() -> __pid_t;
    pub fn getpgrp() -> __pid_t;
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
    pub fn setpgrp() -> ::std::os::raw::c_int;
    pub fn setsid() -> __pid_t;
    pub fn getsid(__pid: __pid_t) -> __pid_t;
    pub fn getuid() -> __uid_t;
    pub fn geteuid() -> __uid_t;
    pub fn getgid() -> __gid_t;
    pub fn getegid() -> __gid_t;
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
    pub fn fork() -> __pid_t;
    pub fn vfork() -> ::std::os::raw::c_int;
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ttyslot() -> ::std::os::raw::c_int;
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub static mut optarg: *mut ::std::os::raw::c_char;
    pub static mut optind: ::std::os::raw::c_int;
    pub static mut opterr: ::std::os::raw::c_int;
    pub static mut optopt: ::std::os::raw::c_int;
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
    pub fn vhangup() -> ::std::os::raw::c_int;
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
    pub fn endusershell();
    pub fn setusershell();
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn gethostid() -> ::std::os::raw::c_long;
    pub fn sync();
    pub fn getpagesize() -> ::std::os::raw::c_int;
    pub fn getdtablesize() -> ::std::os::raw::c_int;
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_header_debug_dump(arg1: *const qfits_header);
    pub fn qfits_header_list(hdr: *const qfits_header, out: *mut FILE) -> ::std::os::raw::c_int;
    pub fn qfits_header_new() -> *mut qfits_header;
    pub fn qfits_header_default() -> *mut qfits_header;
    pub fn qfits_header_n(arg1: *const qfits_header) -> ::std::os::raw::c_int;
    pub fn qfits_header_add(
        arg1: *mut qfits_header,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    );
    pub fn qfits_header_add_after(
        arg1: *mut qfits_header,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *const ::std::os::raw::c_char,
    );
    pub fn qfits_header_append(
        arg1: *mut qfits_header,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    );
    pub fn qfits_header_del(arg1: *mut qfits_header, arg2: *const ::std::os::raw::c_char);
    pub fn qfits_header_sort(arg1: *mut *mut qfits_header) -> ::std::os::raw::c_int;
    pub fn qfits_header_copy(arg1: *const qfits_header) -> *mut qfits_header;
    pub fn qfits_header_mod(
        arg1: *mut qfits_header,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    );
    pub fn qfits_header_destroy(arg1: *mut qfits_header);
    pub fn qfits_header_getstr(
        arg1: *const qfits_header,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn qfits_header_getstr_pretty(
        hdr: *const qfits_header,
        key: *const ::std::os::raw::c_char,
        pretty: *mut ::std::os::raw::c_char,
        default_val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_header_getitem(
        arg1: *const qfits_header,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
        arg4: *mut ::std::os::raw::c_char,
        arg5: *mut ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_header_setitem(
        arg1: *mut qfits_header,
        arg2: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_char,
        comment: *mut ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_header_getcom(
        arg1: *const qfits_header,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn qfits_header_getint(
        arg1: *const qfits_header,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_header_getdouble(
        arg1: *const qfits_header,
        arg2: *const ::std::os::raw::c_char,
        arg3: f64,
    ) -> f64;
    pub fn qfits_header_getboolean(
        arg1: *const qfits_header,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_header_dump(arg1: *const qfits_header, arg2: *mut FILE) -> ::std::os::raw::c_int;
    pub fn qfits_header_findmatch(
        hdr: *const qfits_header,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn qfits_header_write_line(
        hdr: *const qfits_header,
        line: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_table_copy(t: *const qfits_table) -> *mut qfits_table;
    pub fn qfits_table_prim_header_default() -> *mut qfits_header;
    pub fn qfits_table_ext_header_default(arg1: *const qfits_table) -> *mut qfits_header;
    pub fn qfits_table_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ) -> *mut qfits_table;
    pub fn qfits_col_fill(
        arg1: *mut qfits_col,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: tfits_type,
        arg6: *const ::std::os::raw::c_char,
        arg7: *const ::std::os::raw::c_char,
        arg8: *const ::std::os::raw::c_char,
        arg9: *const ::std::os::raw::c_char,
        arg10: ::std::os::raw::c_int,
        arg11: f32,
        arg12: ::std::os::raw::c_int,
        arg13: f32,
        arg14: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_table_open2(
        hdr: *const qfits_header,
        offset_beg: off_t,
        data_size: usize,
        filename: *const ::std::os::raw::c_char,
        xtnum: ::std::os::raw::c_int,
    ) -> *mut qfits_table;
    pub fn qfits_table_close(arg1: *mut qfits_table);
    pub fn qfits_query_column(
        arg1: *const qfits_table,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
    pub fn qfits_query_column_seq(
        arg1: *const qfits_table,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
    pub fn qfits_query_column_data(
        arg1: *const qfits_table,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
    pub fn qfits_query_column_seq_data(
        arg1: *const qfits_table,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
    pub fn qfits_query_column_seq_to_array_inds(
        th: *const qfits_table,
        colnum: ::std::os::raw::c_int,
        indices: *const ::std::os::raw::c_int,
        Ninds: ::std::os::raw::c_int,
        destination: *mut ::std::os::raw::c_uchar,
        dest_stride: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_query_column_seq_to_array(
        th: *const qfits_table,
        colnum: ::std::os::raw::c_int,
        start_ind: ::std::os::raw::c_int,
        nb_rows: ::std::os::raw::c_int,
        destination: *mut ::std::os::raw::c_uchar,
        dest_stride: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_query_column_seq_to_array_no_endian_swap(
        th: *const qfits_table,
        colnum: ::std::os::raw::c_int,
        start_ind: ::std::os::raw::c_int,
        nb_rows: ::std::os::raw::c_int,
        destination: *mut ::std::os::raw::c_uchar,
        dest_stride: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_query_column_nulls(
        arg1: *const qfits_table,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
    #[doc = "@brief    Compute the table width in bytes from the columns infos\n@param    th      Allocated qfits_table\n@return   the width (-1 in error case)"]
    pub fn qfits_compute_table_width(th: *const qfits_table) -> ::std::os::raw::c_int;
    pub fn qfits_table_append_xtension(
        arg1: *mut FILE,
        arg2: *const qfits_table,
        arg3: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_table_append_xtension_hdr(
        arg1: *mut FILE,
        arg2: *const qfits_table,
        arg3: *mut *const ::std::os::raw::c_void,
        arg4: *const qfits_header,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_table_field_to_string(
        arg1: *const qfits_table,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn qfits_table_get_col(t: *const qfits_table, i: ::std::os::raw::c_int)
        -> *const qfits_col;
    pub fn qfits_table_interpret_type(
        str_: *const ::std::os::raw::c_char,
        nb: *mut ::std::os::raw::c_int,
        dec_nb: *mut ::std::os::raw::c_int,
        type_: *mut tfits_type,
        table_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn qfits_is_table_header(hdr: *const qfits_header) -> ::std::os::raw::c_int;
    pub fn qfits_is_platform_big_endian() -> ::std::os::raw::c_int;
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn siggetmask() -> ::std::os::raw::c_int;
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
    pub fn qfits_pixdump(arg1: *const qfitsdumper) -> ::std::os::raw::c_int;
    pub fn qfits_blocks_needed(size: usize) -> usize;
    pub fn qfits_pretty_string_r(
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn qfits_is_boolean(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn qfits_is_int(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn qfits_is_float(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn qfits_is_complex(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn qfits_is_string(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn qfits_get_type(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn qfits_version() -> *const ::std::os::raw::c_char;
    pub fn qfits_get_datetime_iso8601() -> *mut ::std::os::raw::c_char;
    pub fn fits_get_atom_size(type_: tfits_type) -> ::std::os::raw::c_int;
    #[doc = "Converts data between different FITS types.\n\nDoes NO checking, rounding, or anything smart - just uses C casts.\n\nASSUMES the data have already been flipped to the local host's endianness."]
    pub fn fits_convert_data(
        dest: *mut ::std::os::raw::c_void,
        deststride: ::std::os::raw::c_int,
        desttype: tfits_type,
        src: *const ::std::os::raw::c_void,
        srcstride: ::std::os::raw::c_int,
        srctype: tfits_type,
        arraysize: ::std::os::raw::c_int,
        N: usize,
    ) -> ::std::os::raw::c_int;
    pub fn fits_convert_data_2(
        vdest: *mut ::std::os::raw::c_void,
        deststride: ::std::os::raw::c_int,
        desttype: tfits_type,
        vsrc: *const ::std::os::raw::c_void,
        srcstride: ::std::os::raw::c_int,
        srctype: tfits_type,
        arraysize: ::std::os::raw::c_int,
        N: usize,
        bzero: f64,
        bscale: f64,
    ) -> ::std::os::raw::c_int;
    pub fn anqfits_image_new() -> *mut anqfits_image_t;
    pub fn anqfits_image_free(arg1: *mut anqfits_image_t);
    pub fn anqfits_open(filename: *const ::std::os::raw::c_char) -> *mut anqfits_t;
    pub fn anqfits_open_hdu(
        filename: *const ::std::os::raw::c_char,
        hdu: ::std::os::raw::c_int,
    ) -> *mut anqfits_t;
    pub fn anqfits_close(qf: *mut anqfits_t);
    pub fn anqfits_n_ext(qf: *const anqfits_t) -> ::std::os::raw::c_int;
    pub fn anqfits_header_start(qf: *const anqfits_t, ext: ::std::os::raw::c_int) -> off_t;
    pub fn anqfits_header_size(qf: *const anqfits_t, ext: ::std::os::raw::c_int) -> off_t;
    pub fn anqfits_data_start(qf: *const anqfits_t, ext: ::std::os::raw::c_int) -> off_t;
    pub fn anqfits_data_size(qf: *const anqfits_t, ext: ::std::os::raw::c_int) -> off_t;
    pub fn anqfits_get_data_start_and_size(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
        pstart: *mut off_t,
        psize: *mut off_t,
    ) -> ::std::os::raw::c_int;
    pub fn anqfits_get_header_start_and_size(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
        pstart: *mut off_t,
        psize: *mut off_t,
    ) -> ::std::os::raw::c_int;
    pub fn anqfits_is_table(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn anqfits_get_header(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
    ) -> *mut qfits_header;
    pub fn anqfits_get_header2(
        fn_: *const ::std::os::raw::c_char,
        ext: ::std::os::raw::c_int,
    ) -> *mut qfits_header;
    pub fn anqfits_get_header_only(
        fn_: *const ::std::os::raw::c_char,
        ext: ::std::os::raw::c_int,
    ) -> *mut qfits_header;
    pub fn anqfits_get_header_const(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
    ) -> *const qfits_header;
    pub fn anqfits_header_get_data(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
        Nbytes: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn anqfits_get_table(qf: *const anqfits_t, ext: ::std::os::raw::c_int) -> *mut qfits_table;
    pub fn anqfits_get_table_const(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
    ) -> *const qfits_table;
    pub fn anqfits_get_image(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
    ) -> *mut anqfits_image_t;
    pub fn anqfits_get_image_const(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
    ) -> *const anqfits_image_t;
    pub fn anqfits_readpix(
        qf: *const anqfits_t,
        ext: ::std::os::raw::c_int,
        x0: ::std::os::raw::c_int,
        x1: ::std::os::raw::c_int,
        y0: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        pnum: ::std::os::raw::c_int,
        ptype: ::std::os::raw::c_int,
        output: *mut ::std::os::raw::c_void,
        W: *mut ::std::os::raw::c_int,
        H: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn fitsbin_chunk_init(chunk: *mut fitsbin_chunk_t);
    pub fn fitsbin_chunk_clean(chunk: *mut fitsbin_chunk_t);
    pub fn fitsbin_chunk_reset(chunk: *mut fitsbin_chunk_t);
    pub fn fitsbin_get_filename(fb: *const fitsbin_t) -> *mut ::std::os::raw::c_char;
    pub fn fitsbin_get_header(
        fb: *const fitsbin_t,
        ext: ::std::os::raw::c_int,
    ) -> *mut qfits_header;
    pub fn fitsbin_n_ext(fb: *const fitsbin_t) -> ::std::os::raw::c_int;
    pub fn fitsbin_open(fn_: *const ::std::os::raw::c_char) -> *mut fitsbin_t;
    pub fn fitsbin_open_fits(fits: *mut anqfits_t) -> *mut fitsbin_t;
    pub fn fitsbin_open_for_writing(fn_: *const ::std::os::raw::c_char) -> *mut fitsbin_t;
    pub fn fitsbin_open_in_memory() -> *mut fitsbin_t;
    pub fn fitsbin_close_fd(fb: *mut fitsbin_t) -> ::std::os::raw::c_int;
    pub fn fitsbin_switch_to_reading(fb: *mut fitsbin_t) -> ::std::os::raw::c_int;
    pub fn fitsbin_read(fb: *mut fitsbin_t) -> ::std::os::raw::c_int;
    pub fn fitsbin_get_chunk(
        fb: *mut fitsbin_t,
        chunk: ::std::os::raw::c_int,
    ) -> *mut fitsbin_chunk_t;
    pub fn fitsbin_get_data_start(fb: *mut fitsbin_t, chunk: *mut fitsbin_chunk_t) -> off_t;
    pub fn fitsbin_n_chunks(fb: *mut fitsbin_t) -> ::std::os::raw::c_int;
    #[doc = "Appends the given chunk -- makes a copy of the contents of \"chunk\" and\nreturns a pointer to the stored location."]
    pub fn fitsbin_add_chunk(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
    ) -> *mut fitsbin_chunk_t;
    #[doc = "Immediately tries to read a chunk.  If the chunk is not found, -1 is returned\nand the chunk is not added to this fitsbin's list.  If it's found, 0 is\nreturned, a copy of the chunk is stored, and the results are placed in\n\"chunk\"."]
    pub fn fitsbin_read_chunk(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_get_fid(fb: *mut fitsbin_t) -> *mut FILE;
    pub fn fitsbin_close(fb: *mut fitsbin_t) -> ::std::os::raw::c_int;
    pub fn fitsbin_get_primary_header(fb: *const fitsbin_t) -> *mut qfits_header;
    pub fn fitsbin_set_primary_header(fb: *mut fitsbin_t, hdr: *const qfits_header);
    pub fn fitsbin_write_primary_header(fb: *mut fitsbin_t) -> ::std::os::raw::c_int;
    pub fn fitsbin_fix_primary_header(fb: *mut fitsbin_t) -> ::std::os::raw::c_int;
    pub fn fitsbin_get_chunk_header(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
    ) -> *mut qfits_header;
    pub fn fitsbin_write_chunk(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_write_chunk_flipped(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
        wordsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_write_chunk_header(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_fix_chunk_header(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_write_item(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_write_items(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
        data: *mut ::std::os::raw::c_void,
        N: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_write_primary_header_to(
        fb: *mut fitsbin_t,
        fid: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_write_chunk_header_to(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
        fid: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_write_items_to(
        chunk: *mut fitsbin_chunk_t,
        data: *mut ::std::os::raw::c_void,
        N: ::std::os::raw::c_int,
        fid: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn fitsbin_write_chunk_to(
        fb: *mut fitsbin_t,
        chunk: *mut fitsbin_chunk_t,
        fid: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn quadfile_open(fname: *const ::std::os::raw::c_char) -> *mut quadfile_t;
    pub fn quadfile_open_fits(fits: *mut anqfits_t) -> *mut quadfile_t;
    pub fn quadfile_get_filename(qf: *const quadfile_t) -> *mut ::std::os::raw::c_char;
    pub fn quadfile_open_for_writing(quadfname: *const ::std::os::raw::c_char) -> *mut quadfile_t;
    pub fn quadfile_open_in_memory() -> *mut quadfile_t;
    pub fn quadfile_switch_to_reading(qf: *mut quadfile_t) -> ::std::os::raw::c_int;
    pub fn quadfile_close(qf: *mut quadfile_t) -> ::std::os::raw::c_int;
    pub fn quadfile_check(qf: *const quadfile_t) -> ::std::os::raw::c_int;
    pub fn quadfile_get_stars(
        qf: *const quadfile_t,
        quadid: ::std::os::raw::c_uint,
        stars: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn quadfile_write_quad(
        qf: *mut quadfile_t,
        stars: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn quadfile_dimquads(qf: *const quadfile_t) -> ::std::os::raw::c_int;
    pub fn quadfile_nquads(qf: *const quadfile_t) -> ::std::os::raw::c_int;
    pub fn quadfile_fix_header(qf: *mut quadfile_t) -> ::std::os::raw::c_int;
    pub fn quadfile_write_header(qf: *mut quadfile_t) -> ::std::os::raw::c_int;
    pub fn quadfile_get_index_scale_upper_arcsec(qf: *const quadfile_t) -> f64;
    pub fn quadfile_get_index_scale_lower_arcsec(qf: *const quadfile_t) -> f64;
    pub fn quadfile_get_header(qf: *const quadfile_t) -> *mut qfits_header;
    pub fn quadfile_write_header_to(qf: *mut quadfile_t, fid: *mut FILE) -> ::std::os::raw::c_int;
    pub fn quadfile_write_all_quads_to(
        qf: *mut quadfile_t,
        fid: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_open(fn_: *const ::std::os::raw::c_char) -> *mut kdtree_fits_t;
    pub fn kdtree_fits_open_fits(fits: *mut anqfits_t) -> *mut kdtree_fits_t;
    pub fn kdtree_fits_read(
        fn_: *const ::std::os::raw::c_char,
        treename: *const ::std::os::raw::c_char,
        p_hdr: *mut *mut qfits_header,
    ) -> *mut kdtree_t;
    pub fn kdtree_fits_write(
        kdtree: *const kdtree_t,
        fn_: *const ::std::os::raw::c_char,
        hdr: *const qfits_header,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_contains_tree(
        io: *const kdtree_fits_t,
        treename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_get_fitsbin(io: *mut kdtree_fits_t) -> *mut fitsbin_t;
    pub fn kdtree_fits_read_tree(
        io: *mut kdtree_fits_t,
        treename: *const ::std::os::raw::c_char,
        p_hdr: *mut *mut qfits_header,
    ) -> *mut kdtree_t;
    pub fn kdtree_fits_read_chunk(
        io: *mut kdtree_fits_t,
        chunk: *mut fitsbin_chunk_t,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_get_primary_header(io: *mut kdtree_fits_t) -> *mut qfits_header;
    pub fn kdtree_fits_open_for_writing(fn_: *const ::std::os::raw::c_char) -> *mut kdtree_fits_t;
    pub fn kdtree_fits_write_tree(
        io: *mut kdtree_fits_t,
        kd: *const kdtree_t,
        add_headers: *const qfits_header,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_append_tree(
        io: *mut kdtree_fits_t,
        kd: *const kdtree_t,
        add_headers: *const qfits_header,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_append_tree_to(
        kd: *mut kdtree_t,
        inhdr: *const qfits_header,
        fid: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_write_primary_header(
        io: *mut kdtree_fits_t,
        add_headers: *const qfits_header,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_write_chunk(
        io: *mut kdtree_fits_t,
        chunk: *mut fitsbin_chunk_t,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_write_chunk_to(
        chunk: *mut fitsbin_chunk_t,
        fid: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_close(io: *mut kdtree_t) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_io_close(io: *mut kdtree_fits_t) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_write_chunk_flipped(
        io: *mut kdtree_fits_t,
        chunk: *mut fitsbin_chunk_t,
        wordsize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_write_flipped(
        kdtree: *const kdtree_t,
        fn_: *const ::std::os::raw::c_char,
        hdr: *const qfits_header,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_write_tree_flipped(
        io: *mut kdtree_fits_t,
        kd: *const kdtree_t,
        inhdr: *const qfits_header,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_append_tree_flipped(
        io: *mut kdtree_fits_t,
        kd: *const kdtree_t,
        inhdr: *const qfits_header,
    ) -> ::std::os::raw::c_int;
    pub fn kdtree_fits_column_is_kdtree(
        columnname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub static mut ENDIAN_DETECTOR: u32;
    pub fn QSORT_R(
        base: *mut ::std::os::raw::c_void,
        nmembers: usize,
        member_size: usize,
        token: *mut ::std::os::raw::c_void,
        compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
    pub fn copy_file(
        infn: *const ::std::os::raw::c_char,
        outfn: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn pad_fid(
        fid: *mut FILE,
        len: usize,
        pad: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn pad_file(
        filename: *mut ::std::os::raw::c_char,
        len: usize,
        pad: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn basename_safe(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn dirname_safe(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn get_cpu_usage() -> f32;
    pub fn find_file_in_dirs(
        dirs: *mut *const ::std::os::raw::c_char,
        ndirs: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        allow_absolute: anbool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn streq(s1: *const ::std::os::raw::c_char, s2: *const ::std::os::raw::c_char) -> anbool;
    pub fn strcaseeq(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> anbool;
    pub fn pipe_file_offset(
        fin: *mut FILE,
        offset: off_t,
        length: off_t,
        fout: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn write_file(
        fn_: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn asprintf_safe(
        strp: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
    pub fn get_mmap_size(
        start: usize,
        size: usize,
        mapstart: *mut off_t,
        mapsize: *mut usize,
        pgap: *mut ::std::os::raw::c_int,
    );
    pub fn create_temp_file(
        fn_: *const ::std::os::raw::c_char,
        dir: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn shell_escape(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn file_get_last_modified_time(fn_: *const ::std::os::raw::c_char) -> time_t;
    pub fn file_exists(fn_: *const ::std::os::raw::c_char) -> anbool;
    pub fn file_readable(fn_: *const ::std::os::raw::c_char) -> anbool;
    pub fn file_executable(fn_: *const ::std::os::raw::c_char) -> anbool;
    pub fn path_is_dir(path: *const ::std::os::raw::c_char) -> anbool;
    pub fn file_get_contents(
        fn_: *const ::std::os::raw::c_char,
        len: *mut usize,
        addzero: anbool,
    ) -> *mut ::std::os::raw::c_void;
    pub fn file_get_contents_offset(
        fn_: *const ::std::os::raw::c_char,
        offset: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn fid_add_lines(fid: *mut FILE, include_newlines: anbool, list: *mut sl) -> *mut sl;
    pub fn file_get_lines(fn_: *const ::std::os::raw::c_char, include_newlines: anbool) -> *mut sl;
    pub fn fid_get_lines(fid: *mut FILE, include_newlines: anbool) -> *mut sl;
    #[doc = "Splits the given \"str\" into words, so that the first line is at most\n\"firstlinew\" long.  Subsequent lines have length <= \"linew\".  If\n\"lst\" is non-NULL, the words are added into it.  Otherwise a new sl\nis allocated."]
    pub fn split_long_string(
        str_: *const ::std::os::raw::c_char,
        firstlinew: ::std::os::raw::c_int,
        linew: ::std::os::raw::c_int,
        lst: *mut sl,
    ) -> *mut sl;
    pub fn split_string_once(
        str_: *const ::std::os::raw::c_char,
        splitstr: *const ::std::os::raw::c_char,
        first: *mut *mut ::std::os::raw::c_char,
        second: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = "If \"cmdline\" starts with \"keyword\", returns 1 and places the address of\nthe start of the next word in \"p_next_word\"."]
    pub fn is_word(
        cmdline: *const ::std::os::raw::c_char,
        keyword: *const ::std::os::raw::c_char,
        p_next_word: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn starts_with(
        str_: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn ends_with(
        str_: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn strdup_safe(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn add_sigbus_mmap_warning();
    pub fn reset_sigbus_mmap_warning();
    pub fn write_u8(fout: *mut FILE, val: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
    pub fn write_u16(fout: *mut FILE, val: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn write_u32(fout: *mut FILE, val: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn write_uints(
        fout: *mut FILE,
        val: *mut ::std::os::raw::c_uint,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn write_double(fout: *mut FILE, val: f64) -> ::std::os::raw::c_int;
    pub fn write_float(fout: *mut FILE, val: f32) -> ::std::os::raw::c_int;
    pub fn write_fixed_length_string(
        fout: *mut FILE,
        s: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn write_string(fout: *mut FILE, s: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn write_u32_portable(
        fout: *mut FILE,
        val: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn write_u32s_portable(
        fout: *mut FILE,
        val: *mut ::std::os::raw::c_uint,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn read_u8(fin: *mut FILE, val: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
    pub fn read_u16(fout: *mut FILE, val: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn read_u32(fin: *mut FILE, val: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
    pub fn read_double(fin: *mut FILE, val: *mut f64) -> ::std::os::raw::c_int;
    pub fn read_fixed_length_string(
        fin: *mut FILE,
        s: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn read_string(fin: *mut FILE) -> *mut ::std::os::raw::c_char;
    pub fn read_string_terminated(
        fin: *mut FILE,
        terminators: *const ::std::os::raw::c_char,
        nterminators: ::std::os::raw::c_int,
        include_terminator: anbool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn read_u32_portable(
        fin: *mut FILE,
        val: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
    pub fn read_u32s_portable(
        fin: *mut FILE,
        val: *mut ::std::os::raw::c_uint,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn buffered_read_new(
        elementsize: ::std::os::raw::c_int,
        Nbuffer: ::std::os::raw::c_int,
        Ntotal: ::std::os::raw::c_int,
        refill_buffer: ::std::option::Option<
            unsafe extern "C" fn(
                userdata: *mut ::std::os::raw::c_void,
                buffer: *mut ::std::os::raw::c_void,
                offs: ::std::os::raw::c_uint,
                nelems: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int,
        >,
        userdata: *mut ::std::os::raw::c_void,
    ) -> *mut bread_t;
    pub fn buffered_read(buff: *mut bread_t) -> *mut ::std::os::raw::c_void;
    pub fn buffered_read_pushback(br: *mut bread_t);
    pub fn buffered_read_reset(br: *mut bread_t);
    pub fn buffered_read_free(br: *mut bread_t);
    pub fn buffered_read_resize(br: *mut bread_t, newsize: ::std::os::raw::c_int);
    pub fn fitscolumn_int_type() -> tfits_type;
    pub fn fitscolumn_double_type() -> tfits_type;
    pub fn fitscolumn_float_type() -> tfits_type;
    pub fn fitscolumn_char_type() -> tfits_type;
    pub fn fitscolumn_boolean_type() -> tfits_type;
    pub fn fitscolumn_u8_type() -> tfits_type;
    pub fn fitscolumn_i16_type() -> tfits_type;
    pub fn fitscolumn_i32_type() -> tfits_type;
    pub fn fitscolumn_i64_type() -> tfits_type;
    pub fn fitscolumn_bitfield_type() -> tfits_type;
    pub fn fitscolumn_bool_type() -> tfits_type;
    pub fn fitscolumn_any_type() -> tfits_type;
    pub fn fitstable_open_in_memory() -> *mut fitstable_t;
    pub fn fitstable_switch_to_reading(tab: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_open(fn_: *const ::std::os::raw::c_char) -> *mut fitstable_t;
    pub fn fitstable_open_extension_2(
        fn_: *const ::std::os::raw::c_char,
        ext: ::std::os::raw::c_int,
    ) -> *mut fitstable_t;
    pub fn fitstable_open_mixed(fn_: *const ::std::os::raw::c_char) -> *mut fitstable_t;
    pub fn fitstable_open_for_writing(fn_: *const ::std::os::raw::c_char) -> *mut fitstable_t;
    pub fn fitstable_open_for_appending(fn_: *const ::std::os::raw::c_char) -> *mut fitstable_t;
    pub fn fitstable_open_for_appending_to(fid: *mut FILE) -> *mut fitstable_t;
    pub fn fitstable_n_extensions(t: *const fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_append_to(t: *mut fitstable_t, fid: *mut FILE) -> ::std::os::raw::c_int;
    pub fn fitstable_copy_columns(src: *const fitstable_t, dest: *mut fitstable_t);
    pub fn fitstable_n_fits_columns(tab: *const fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_add_fits_columns_as_struct(dest: *mut fitstable_t);
    pub fn fitstable_add_fits_columns_as_struct2(
        intab: *const fitstable_t,
        outtab: *mut fitstable_t,
    );
    pub fn fitstable_add_fits_columns_as_struct3(
        intab: *const fitstable_t,
        outtab: *mut fitstable_t,
        columns: *const sl,
        c_offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_add_fits_columns_as_struct4(
        intab: *const fitstable_t,
        outtab: *mut fitstable_t,
        columns: *const sl,
        c_offset: ::std::os::raw::c_int,
        fitstype: tfits_type,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_find_fits_column(
        t: *mut fitstable_t,
        colname: *const ::std::os::raw::c_char,
        units: *mut *mut ::std::os::raw::c_char,
        type_: *mut tfits_type,
        arraysize: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_get_fits_column_names(t: *const fitstable_t, lst: *mut sl) -> *mut sl;
    #[doc = "Returns the number of columns in the FITS table."]
    pub fn fitstable_get_N_fits_columns(t: *const fitstable_t) -> ::std::os::raw::c_int;
    #[doc = "Returns the name of the 'i'th FITS column in this table.  The\nlifetime of the returned string is the lifetime of the currently-open\nextension; you might want to copy it for safety."]
    pub fn fitstable_get_fits_column_name(
        t: *const fitstable_t,
        i: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
    pub fn fitstable_get_fits_column_type(
        t: *const fitstable_t,
        i: ::std::os::raw::c_int,
    ) -> tfits_type;
    pub fn fitstable_get_fits_column_array_size(
        t: *const fitstable_t,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_open_extension(
        tab: *mut fitstable_t,
        ext: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_open_next_extension(tab: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_close(arg1: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_ncols(t: *const fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_nrows(t: *const fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_row_size(t: *const fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_get_struct_size(table: *const fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_next_extension(tab: *mut fitstable_t);
    pub fn fitstable_clear_table(tab: *mut fitstable_t);
    pub fn fitstable_new_table(t: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_read_extension(
        tab: *mut fitstable_t,
        ext: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_get_array_size(
        tab: *mut fitstable_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_get_type(
        tab: *mut fitstable_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_add_read_column_struct(
        tab: *mut fitstable_t,
        c_type: tfits_type,
        arraysize: ::std::os::raw::c_int,
        structoffset: ::std::os::raw::c_int,
        fits_type: tfits_type,
        name: *const ::std::os::raw::c_char,
        required: anbool,
    );
    pub fn fitstable_add_write_column_struct(
        tab: *mut fitstable_t,
        c_type: tfits_type,
        arraysize: ::std::os::raw::c_int,
        structoffset: ::std::os::raw::c_int,
        fits_type: tfits_type,
        name: *const ::std::os::raw::c_char,
        units: *const ::std::os::raw::c_char,
    );
    pub fn fitstable_add_column_struct(
        tab: *mut fitstable_t,
        c_type: tfits_type,
        arraysize: ::std::os::raw::c_int,
        structoffset: ::std::os::raw::c_int,
        fits_type: tfits_type,
        name: *const ::std::os::raw::c_char,
        units: *const ::std::os::raw::c_char,
        required: anbool,
    );
    pub fn fitstable_add_write_column(
        tab: *mut fitstable_t,
        t: tfits_type,
        name: *const ::std::os::raw::c_char,
        units: *const ::std::os::raw::c_char,
    );
    pub fn fitstable_add_write_column_array(
        tab: *mut fitstable_t,
        t: tfits_type,
        arraysize: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        units: *const ::std::os::raw::c_char,
    );
    pub fn fitstable_add_write_column_convert(
        tab: *mut fitstable_t,
        fits_type: tfits_type,
        c_type: tfits_type,
        name: *const ::std::os::raw::c_char,
        units: *const ::std::os::raw::c_char,
    );
    pub fn fitstable_add_write_column_array_convert(
        tab: *mut fitstable_t,
        fits_type: tfits_type,
        c_type: tfits_type,
        arraysize: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        units: *const ::std::os::raw::c_char,
    );
    pub fn fitstable_remove_column(
        tab: *mut fitstable_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_read_column_into(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        read_as_type: tfits_type,
        dest: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_read_column_inds_into(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        read_as_type: tfits_type,
        dest: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
        inds: *const ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_read_column_inds(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        read_as_type: tfits_type,
        inds: *const ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn fitstable_read_column_array_inds_into(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        read_as_type: tfits_type,
        dest: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
        arraysize: ::std::os::raw::c_int,
        inds: *const ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_read_column_array_inds(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        read_as_type: tfits_type,
        inds: *const ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
        arraysize: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn fitstable_read_column_offset_into(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        read_as_type: tfits_type,
        dest: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
        start: ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_read_column(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        t: tfits_type,
    ) -> *mut ::std::os::raw::c_void;
    pub fn fitstable_read_column_array(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        t: tfits_type,
    ) -> *mut ::std::os::raw::c_void;
    pub fn fitstable_read_column_offset(
        tab: *const fitstable_t,
        colname: *const ::std::os::raw::c_char,
        ctype: tfits_type,
        offset: ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn fitstable_write_row(table: *mut fitstable_t, ...) -> ::std::os::raw::c_int;
    pub fn fitstable_write_row_noflip(table: *mut fitstable_t, ...) -> ::std::os::raw::c_int;
    #[doc = "Reads/writes raw row data, without endian-flipping.\n\nThis means that if you're reading from a FITS file into an in-memory\nfitstable, or vice versa, you will need to use\nfitstable_endian_flip_row_data().\n\n(these inputs are not \"const\" because they update the file offsets)"]
    pub fn fitstable_read_nrows_data(
        table: *mut fitstable_t,
        row0: ::std::os::raw::c_int,
        nrows: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_read_row_data(
        table: *mut fitstable_t,
        row: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_write_row_data(
        table: *mut fitstable_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_copy_rows_data(
        table: *mut fitstable_t,
        rows: *mut ::std::os::raw::c_int,
        Nrows: ::std::os::raw::c_int,
        outtable: *mut fitstable_t,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_write_struct(
        table: *mut fitstable_t,
        struc: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_write_struct_noflip(
        table: *mut fitstable_t,
        struc: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_write_structs(
        table: *mut fitstable_t,
        struc: *const ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_pad_with(
        table: *mut fitstable_t,
        pad: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_write_one_column(
        table: *mut fitstable_t,
        colnum: ::std::os::raw::c_int,
        rowoffset: ::std::os::raw::c_int,
        nrows: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        src_stride: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_read_struct(
        table: *mut fitstable_t,
        index: ::std::os::raw::c_int,
        struc: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_read_structs(
        table: *mut fitstable_t,
        struc: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn fitstable_get_primary_header(t: *const fitstable_t) -> *mut qfits_header;
    pub fn fitstable_write_primary_header(t: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_fix_primary_header(t: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_get_header(t: *mut fitstable_t) -> *mut qfits_header;
    pub fn fitstable_write_header(t: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_fix_header(t: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_close_table(tab: *mut fitstable_t);
    pub fn fitstable_use_buffered_reading(
        tab: *mut fitstable_t,
        elementsize: ::std::os::raw::c_int,
        Nbuffer: ::std::os::raw::c_int,
    );
    pub fn fitstable_next_struct(tab: *mut fitstable_t) -> *mut ::std::os::raw::c_void;
    pub fn fitstable_pushback(tab: *mut fitstable_t) -> ::std::os::raw::c_int;
    pub fn fitstable_set_buffer_fill_function(
        tab: *mut fitstable_t,
        refill_buffer: ::std::option::Option<
            unsafe extern "C" fn(
                userdata: *mut ::std::os::raw::c_void,
                buffer: *mut ::std::os::raw::c_void,
                offs: ::std::os::raw::c_uint,
                nelems: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int,
        >,
        userdata: *mut ::std::os::raw::c_void,
    );
    pub fn fitstable_print_missing(tab: *mut fitstable_t, f: *mut FILE);
    pub fn fitstable_error_report_missing(tab: *mut fitstable_t);
    pub fn fitstable_print_columns(tab: *mut fitstable_t);
    pub fn startree_open(fn_: *const ::std::os::raw::c_char) -> *mut startree_t;
    pub fn startree_open_fits(fits: *mut anqfits_t) -> *mut startree_t;
    #[doc = "Searches for stars within a radius of a point.\n\nxyzcenter: double[3]: unit-sphere coordinates of point; see\nstarutil.h : radecdeg2xyzarr() to convert RA,Decs to this form.\n\nradius2: radius-squared on the unit sphere; see starutil.h :\ndeg2distsq() or arcsec2distsq().\n\nxyzresults: if non-NULL, returns the xyz positions of the stars that\nare found, in a newly-allocated array.\n\nradecresults: if non-NULL, returns the RA,Dec positions (in degrees)\nof the stars within range.\n\nstarinds: if non-NULL, returns the indices of stars within range.\nThis can be used to retrieve extra information about the stars, using\nthe 'startree_get_data_column()' function.\n"]
    pub fn startree_search_for(
        s: *const startree_t,
        xyzcenter: *const f64,
        radius2: f64,
        xyzresults: *mut *mut f64,
        radecresults: *mut *mut f64,
        starinds: *mut *mut ::std::os::raw::c_int,
        nresults: *mut ::std::os::raw::c_int,
    );
    #[doc = "RA, Dec, and radius in degrees.  Otherwise same as startree_search_for()."]
    pub fn startree_search_for_radec(
        s: *const startree_t,
        ra: f64,
        dec: f64,
        radius: f64,
        xyzresults: *mut *mut f64,
        radecresults: *mut *mut f64,
        starinds: *mut *mut ::std::os::raw::c_int,
        nresults: *mut ::std::os::raw::c_int,
    );
    pub fn startree_search(
        s: *const startree_t,
        xyzcenter: *const f64,
        radius2: f64,
        xyzresults: *mut *mut f64,
        radecresults: *mut *mut f64,
        nresults: *mut ::std::os::raw::c_int,
    );
    #[doc = "Reads a column of data from the \"tag-along\" table.\n\nGet the \"inds\" and \"N\" from \"startree_search\" or \"startree_search_for\".\n\nTo get all entries, set \"inds\" = NULL and N = startree_N().\n\nThe return value is a newly-allocated array of size N.  It should be\nfreed using \"startree_free_data_column\""]
    pub fn startree_get_data_column(
        s: *mut startree_t,
        colname: *const ::std::os::raw::c_char,
        indices: *const ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> *mut f64;
    #[doc = "Same as startree_get_data_column but for int64_t.  Don't you love C templating?"]
    pub fn startree_get_data_column_int64(
        s: *mut startree_t,
        colname: *const ::std::os::raw::c_char,
        indices: *const ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
    ) -> *mut i64;
    #[doc = "Reads a column of data from the \"tag-along\" table.\n\nThe column may be an array (that is, each row contains multiple\nentries); the array size is placed in \"arraysize\".\n\nThe array entries"]
    pub fn startree_get_data_column_array(
        s: *mut startree_t,
        colname: *const ::std::os::raw::c_char,
        indices: *const ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
        arraysize: *mut ::std::os::raw::c_int,
    ) -> *mut f64;
    pub fn startree_free_data_column(s: *mut startree_t, d: *mut f64);
    pub fn startree_has_tagalong(s: *mut startree_t) -> anbool;
    pub fn startree_get_tagalong(s: *mut startree_t) -> *mut fitstable_t;
    pub fn startree_get_tagalong_column_names(s: *mut startree_t, lst: *mut sl) -> *mut sl;
    #[doc = "Returns the number of columns in the tagalong table."]
    pub fn startree_get_tagalong_N_columns(s: *mut startree_t) -> ::std::os::raw::c_int;
    #[doc = "Returns the name of the 'i'th column in the tagalong table.\nThe lifetime of the returned string is the lifetime of this starkd."]
    pub fn startree_get_tagalong_column_name(
        s: *mut startree_t,
        i: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
    #[doc = "Returns the FITS type of the 'i'th column in the tagalong table."]
    pub fn startree_get_tagalong_column_fits_type(
        s: *mut startree_t,
        i: ::std::os::raw::c_int,
    ) -> tfits_type;
    #[doc = "Returns the array size of the 'i'th column in the tagalong table.\nFor scalar columns, this is 1."]
    pub fn startree_get_tagalong_column_array_size(
        s: *mut startree_t,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn startree_get_cut_nside(s: *const startree_t) -> ::std::os::raw::c_int;
    pub fn startree_get_cut_nsweeps(s: *const startree_t) -> ::std::os::raw::c_int;
    pub fn startree_get_cut_dedup(s: *const startree_t) -> f64;
    pub fn startree_get_cut_band(s: *const startree_t) -> *mut ::std::os::raw::c_char;
    pub fn startree_get_cut_margin(s: *const startree_t) -> ::std::os::raw::c_int;
    pub fn startree_get_jitter(s: *const startree_t) -> f64;
    pub fn startree_set_jitter(s: *mut startree_t, jitter_arcsec: f64);
    pub fn startree_get_sweep(
        s: *const startree_t,
        ind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn startree_N(s: *const startree_t) -> ::std::os::raw::c_int;
    pub fn startree_nodes(s: *const startree_t) -> ::std::os::raw::c_int;
    pub fn startree_D(s: *const startree_t) -> ::std::os::raw::c_int;
    pub fn startree_header(s: *const startree_t) -> *mut qfits_header;
    pub fn startree_get(
        s: *mut startree_t,
        starid: ::std::os::raw::c_int,
        posn: *mut f64,
    ) -> ::std::os::raw::c_int;
    pub fn startree_get_radec(
        s: *mut startree_t,
        starid: ::std::os::raw::c_int,
        ra: *mut f64,
        dec: *mut f64,
    ) -> ::std::os::raw::c_int;
    pub fn startree_close(s: *mut startree_t) -> ::std::os::raw::c_int;
    pub fn startree_compute_inverse_perm(s: *mut startree_t);
    pub fn startree_check_inverse_perm(s: *mut startree_t) -> ::std::os::raw::c_int;
    pub fn startree_new() -> *mut startree_t;
    pub fn startree_write_to_file(
        s: *mut startree_t,
        fn_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn startree_write_to_file_flipped(
        s: *mut startree_t,
        fn_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn startree_append_to(s: *mut startree_t, fid: *mut FILE) -> ::std::os::raw::c_int;
    pub fn codetree_open(fn_: *const ::std::os::raw::c_char) -> *mut codetree_t;
    pub fn codetree_open_fits(fits: *mut anqfits_t) -> *mut codetree_t;
    pub fn codetree_get(
        s: *mut codetree_t,
        codeid: ::std::os::raw::c_uint,
        code: *mut f64,
    ) -> ::std::os::raw::c_int;
    pub fn codetree_N(s: *mut codetree_t) -> ::std::os::raw::c_int;
    pub fn codetree_nodes(s: *mut codetree_t) -> ::std::os::raw::c_int;
    pub fn codetree_D(s: *mut codetree_t) -> ::std::os::raw::c_int;
    pub fn codetree_get_permuted(
        s: *mut codetree_t,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn codetree_header(s: *mut codetree_t) -> *mut qfits_header;
    pub fn codetree_close(s: *mut codetree_t) -> ::std::os::raw::c_int;
    pub fn codetree_new() -> *mut codetree_t;
    pub fn codetree_append_to(s: *mut codetree_t, fid: *mut FILE) -> ::std::os::raw::c_int;
    pub fn codetree_write_to_file(
        s: *mut codetree_t,
        fn_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn codetree_write_to_file_flipped(
        s: *mut codetree_t,
        fn_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = "Simple accessor (indx->dimquads): returns the dimensionality of quads\nin this index."]
    pub fn index_dimquads(indx: *mut index_t) -> ::std::os::raw::c_int;
    #[doc = "Returns TRUE if the given index contains quads of sizes that overlap\nthe given range of quad sizes, [quadlo, quadhi], in arcseconds."]
    pub fn index_overlaps_scale_range(indx: *mut index_t, quadlo: f64, quadhi: f64) -> anbool;
    #[doc = "Returns TRUE if the given index covers a part of the sky that is\nwithin \"radius_deg\" degrees of the given \"ra\",\"dec\" position (in\ndegrees)."]
    pub fn index_is_within_range(indx: *mut index_t, ra: f64, dec: f64, radius_deg: f64) -> anbool;
    #[doc = "Reads index metadata from the given 'filename' into the given 'indx'\nstruct.\n\nThis is done by basically loading the index, grabbing the metadata,\nand closing the index; therefore it checks for structural consistency\nof the index file as well as getting the metadata; this also means\nit's slower than it could be..."]
    pub fn index_get_meta(
        filename: *const ::std::os::raw::c_char,
        indx: *mut index_t,
    ) -> ::std::os::raw::c_int;
    pub fn index_is_file_index(filename: *const ::std::os::raw::c_char) -> anbool;
    pub fn index_get_quad_filename(
        indexname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn index_get_qidx_filename(
        indexname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn index_get_quad_dim(index: *const index_t) -> ::std::os::raw::c_int;
    pub fn index_get_code_dim(index: *const index_t) -> ::std::os::raw::c_int;
    pub fn index_nquads(index: *const index_t) -> ::std::os::raw::c_int;
    pub fn index_nstars(index: *const index_t) -> ::std::os::raw::c_int;
    pub fn index_build_from(
        codekd: *mut codetree_t,
        quads: *mut quadfile_t,
        starkd: *mut startree_t,
    ) -> *mut index_t;
    #[doc = " Load an index from disk\n\n Parameters:\n\n   indexname - the base name of the index files; for example, if the\n               index is in files 'myindex.ckdt.fits' and\n               'myindex.skdt.fits', then the indexname is just\n               'myindex'\n\n   flags - If INDEX_ONLY_LOAD_METADATA, then only metadata will be\n               loaded.\n\n   dest - If NULL, a new index_t will be allocated and returned;\n               otherwise, the results will be put in this index_t\n               object.\n\n Returns:\n\n   A pointer to an index_t structure or NULL on error.\n"]
    pub fn index_load(
        indexname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        dest: *mut index_t,
    ) -> *mut index_t;
    #[doc = "Close the quad, skdt, and ckdt files; makes it as though you did\nINDEX_ONLY_LOAD_METADATA.  You can re-load the files with\nindex_reload()."]
    pub fn index_unload(index: *mut index_t);
    pub fn index_reload(index: *mut index_t) -> ::std::os::raw::c_int;
    #[doc = "Closes the FILE*s in this index.  Once you have index_reload()ed,\nyou can call this function and the index will remain valid."]
    pub fn index_close_fds(index: *mut index_t) -> ::std::os::raw::c_int;
    #[doc = "Close an index and free associated data structures, *without freeing\n'index' itself*."]
    pub fn index_close(index: *mut index_t);
    #[doc = "Closes the given index and calls free(index)."]
    pub fn index_free(index: *mut index_t);
    pub fn index_get_missing_cut_params(
        indexid: ::std::os::raw::c_int,
        hpnside: *mut ::std::os::raw::c_int,
        nsweep: *mut ::std::os::raw::c_int,
        dedup: *mut f64,
        margin: *mut ::std::os::raw::c_int,
        band: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn matchobj_compute_overlap(mo: *mut MatchObj);
    pub fn matchobj_compute_derived(mo: *mut MatchObj);
    pub fn matchobj_get_index_name(mo: *mut MatchObj) -> *const ::std::os::raw::c_char;
    pub fn matchobj_log_hit_miss(
        theta: *mut ::std::os::raw::c_int,
        testperm: *mut ::std::os::raw::c_int,
        nbest: ::std::os::raw::c_int,
        nfield: ::std::os::raw::c_int,
        loglevel: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
    );
    pub fn matchobj_hit_miss_string(
        theta: *mut ::std::os::raw::c_int,
        testperm: *mut ::std::os::raw::c_int,
        nbest: ::std::os::raw::c_int,
        nfield: ::std::os::raw::c_int,
        target: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn matchobj_print(mo: *mut MatchObj, loglvl: ::std::os::raw::c_int);
    pub fn verify_field_preprocess(fieldxy: *const starxy_t) -> *mut verify_field_t;
    pub fn verify_field_free(vf: *mut verify_field_t);
    pub fn verify_count_hits(
        theta: *mut ::std::os::raw::c_int,
        besti: ::std::os::raw::c_int,
        p_nmatch: *mut ::std::os::raw::c_int,
        p_nconflict: *mut ::std::os::raw::c_int,
        p_ndistractor: *mut ::std::os::raw::c_int,
    );
    pub fn verify_wcs(
        skdt: *const startree_t,
        index_cutnside: ::std::os::raw::c_int,
        sip: *const sip_t,
        vf: *const verify_field_t,
        verify_pix2: f64,
        distractors: f64,
        fieldW: f64,
        fieldH: f64,
        logratio_tobail: f64,
        logratio_toaccept: f64,
        logratio_tostoplooking: f64,
        logodds: *mut f64,
        nfield: *mut ::std::os::raw::c_int,
        nindex: *mut ::std::os::raw::c_int,
        nmatch: *mut ::std::os::raw::c_int,
        nconflict: *mut ::std::os::raw::c_int,
        ndistractor: *mut ::std::os::raw::c_int,
    );
    pub fn verify_hit(
        skdt: *const startree_t,
        index_cutnside: ::std::os::raw::c_int,
        mo: *mut MatchObj,
        sip: *const sip_t,
        vf: *const verify_field_t,
        verify_pix2: f64,
        distractors: f64,
        fieldW: f64,
        fieldH: f64,
        logratio_tobail: f64,
        logratio_toaccept: f64,
        logratio_tostoplooking: f64,
        distance_from_quad_bonus: anbool,
        fake_match: anbool,
    );
    #[doc = "Returns the best log-odds encountered."]
    pub fn verify_star_lists(
        refxys: *mut f64,
        NR: ::std::os::raw::c_int,
        testxys: *const f64,
        testsigma2s: *const f64,
        NT: ::std::os::raw::c_int,
        effective_area: f64,
        distractors: f64,
        logodds_bail: f64,
        logodds_accept: f64,
        p_besti: *mut ::std::os::raw::c_int,
        p_all_logodds: *mut *mut f64,
        p_theta: *mut *mut ::std::os::raw::c_int,
        p_worstlogodds: *mut f64,
        p_testperm: *mut *mut ::std::os::raw::c_int,
    ) -> f64;
    pub fn verify_get_uniformize_scale(
        cutnside: ::std::os::raw::c_int,
        scale: f64,
        W: ::std::os::raw::c_int,
        H: ::std::os::raw::c_int,
        uni_nw: *mut ::std::os::raw::c_int,
        uni_nh: *mut ::std::os::raw::c_int,
    );
    pub fn verify_uniformize_field(
        xy: *const f64,
        perm: *mut ::std::os::raw::c_int,
        N: ::std::os::raw::c_int,
        fieldW: f64,
        fieldH: f64,
        nw: ::std::os::raw::c_int,
        nh: ::std::os::raw::c_int,
        p_bincounts: *mut *mut ::std::os::raw::c_int,
        p_binids: *mut *mut ::std::os::raw::c_int,
    );
    pub fn verify_uniformize_bin_centers(
        fieldW: f64,
        fieldH: f64,
        nw: ::std::os::raw::c_int,
        nh: ::std::os::raw::c_int,
    ) -> *mut f64;
    pub fn verify_get_quad_center(
        vf: *const verify_field_t,
        mo: *const MatchObj,
        centerpix: *mut f64,
        quadr2: *mut f64,
    );
    pub fn verify_get_index_stars(
        fieldcenter: *const f64,
        fieldr2: f64,
        skdt: *const startree_t,
        sip: *const sip_t,
        tan: *const tan_t,
        fieldW: f64,
        fieldH: f64,
        p_indexradec: *mut *mut f64,
        p_indexpix: *mut *mut f64,
        p_starids: *mut *mut ::std::os::raw::c_int,
        p_nindex: *mut ::std::os::raw::c_int,
    );
    pub fn verify_logodds_to_weight(lodds: f64) -> f64;
    pub fn verify_free_matchobj(mo: *mut MatchObj);
    pub fn verify_matchobj_deep_copy(mo: *const MatchObj, dest: *mut MatchObj);
    pub fn verify_get_ror2(
        Q2: f64,
        area: f64,
        distractors: f64,
        NR: ::std::os::raw::c_int,
        pix2: f64,
    ) -> f64;
    pub fn verify_star_lists_ror(
        refxys: *mut f64,
        NR: ::std::os::raw::c_int,
        testxys: *const f64,
        testsigma2s: *const f64,
        NT: ::std::os::raw::c_int,
        pix2: f64,
        gamma: f64,
        qc: *const f64,
        Q2: f64,
        W: f64,
        H: f64,
        distractors: f64,
        logodds_bail: f64,
        logodds_stoplooking: f64,
        p_besti: *mut ::std::os::raw::c_int,
        p_all_logodds: *mut *mut f64,
        p_theta: *mut *mut ::std::os::raw::c_int,
        p_worstlogodds: *mut f64,
        p_testperm: *mut *mut ::std::os::raw::c_int,
        p_refperm: *mut *mut ::std::os::raw::c_int,
    ) -> f64;
    pub fn solver_new() -> *mut solver_t;
    pub fn solver_set_default_values(solver: *mut solver_t);
    #[doc = "Returns the assumed field positional uncertainty (\"jitter\")\nin pixels."]
    pub fn solver_get_field_jitter(solver: *const solver_t) -> f64;
    #[doc = "Sets the log-odds ratio for \"recording\" a proposed solution.  NOTE,\n'recording' means calling your callback, where you can decide what to\ndo with it; thus it's probably your \"solve\" threshold.\n\nDefault: 0, which means your callback gets called for every match.\n\nSuggested value: log(1e9) or log(1e12)."]
    pub fn solver_set_keep_logodds(solver: *mut solver_t, logodds: f64);
    #[doc = "Sets the \"parity\" or \"flip\" of the image.\n\nPARITY_NORMAL: det(CD) < 0\nPARITY_FLIP:   det(CD) > 0\nPARITY_BOTH (default): try both.\n\nReturn 0 on success, -1 on invalid parity value."]
    pub fn solver_set_parity(
        solver: *mut solver_t,
        parity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "Returns the pixel position of the center of the field, defined\nto be the mean of the min and max position.\n(field_maxx + field_maxy)/2"]
    pub fn solver_get_field_center(solver: *const solver_t, px: *mut f64, py: *mut f64);
    #[doc = "Returns the maximum field size expected, in arcsec.\n\nThis is simply the maximum pixel scale * maximum radius (on the\ndiagonal)"]
    pub fn solver_get_max_radius_arcsec(solver: *const solver_t) -> f64;
    #[doc = "Returns the best match found after a solver_run() call.\n\nThis is just &(solver->best_match)"]
    pub fn solver_get_best_match(solver: *mut solver_t) -> *mut MatchObj;
    #[doc = "Did the best match solve?\n\nReturns solver->best_match_solved."]
    pub fn solver_did_solve(solver: *const solver_t) -> anbool;
    #[doc = "Returns solver->best_index->indexname.\n\n(Should be equal to solver->best_match->index->indexname."]
    pub fn solver_get_best_match_index_name(
        solver: *const solver_t,
    ) -> *const ::std::os::raw::c_char;
    #[doc = "Returns the lower/upper bounds of pixel scale that will be searched,\nin arcsec/pixel."]
    pub fn solver_get_pixscale_low(solver: *const solver_t) -> f64;
    pub fn solver_get_pixscale_high(solver: *const solver_t) -> f64;
    #[doc = "Sets the range of quad sizes to try in the image.  This will be\nfurther tightened, if possible, given the range of quad sizes in the\nindex and the pixel scale estimates.\n\nThis avoids looking at tiny quads in the image, because if matches\nare generated they are difficult to verify (a tiny bit of noise in\nthe quad position translates to a lot of positional noise in stars\nfar away).\n\nMin and max are in pixels.\n\nSets quadsize_min, quadsize_max fields.\n\nRecommended: ~ 10% of smaller image dimension; 100% of image diagonal."]
    pub fn solver_set_quad_size_range(solver: *mut solver_t, qmin: f64, qmax: f64);
    #[doc = "Same as solver_set_quad_size_range(), but specified in terms of\nfraction of the smaller image dimension (for lower) and the diagonal\n(for upper).\n\nRecommended: min=0.1, max=1"]
    pub fn solver_set_quad_size_fraction(solver: *mut solver_t, qmin: f64, qmax: f64);
    #[doc = "Returns the range of quad sizes that could be matched, given the\ncurrent settings of pixel scale and image quad size.\n\nReturns minimum pixel scale * minimum quad size and\nmaximum pixel scale * maximum quad size."]
    pub fn solver_get_quad_size_range_arcsec(
        solver: *const solver_t,
        qmin: *mut f64,
        qmax: *mut f64,
    );
    pub fn solver_free(arg1: *mut solver_t);
    #[doc = "Tells the solver which field of stars it's going to be solving.\n\nThe solver_t* takes ownership of the *field*; it will be freed upon\nsolver_free() or solver_cleanup_field() or a new solver_set_field()."]
    pub fn solver_set_field(s: *mut solver_t, field: *mut starxy_t);
    pub fn solver_get_field(solver: *mut solver_t) -> *mut starxy_t;
    pub fn solver_reset_field_size(s: *mut solver_t);
    #[doc = "Tells the solver to only accept matches within \"radius_deg\" (in\ndegrees) of the given \"ra\",\"dec\" point (also in degrees).\n\nThis is, each star comprising the quad must be within that circle."]
    pub fn solver_set_radec(s: *mut solver_t, ra: f64, dec: f64, radius_deg: f64);
    pub fn solver_clear_radec(s: *mut solver_t);
    #[doc = "Tells the solver the pixel coordinate range of the image to be\nsolved.  If not set, this will be computed based on the bounds of the\nstars within the field (an underestimate)."]
    pub fn solver_set_field_bounds(s: *mut solver_t, xlo: f64, xhi: f64, ylo: f64, yhi: f64);
    #[doc = "Reset everything associated with solving a particular field.\n\n(renamed from solver_new_field)"]
    pub fn solver_cleanup_field(arg1: *mut solver_t);
    #[doc = "get field w,h"]
    pub fn solver_field_width(t: *const solver_t) -> f64;
    pub fn solver_field_height(t: *const solver_t) -> f64;
    pub fn solver_add_index(solver: *mut solver_t, index: *mut index_t);
    pub fn solver_clear_indexes(solver: *mut solver_t);
    pub fn solver_n_indices(solver: *const solver_t) -> ::std::os::raw::c_int;
    pub fn solver_get_index(solver: *const solver_t, i: ::std::os::raw::c_int) -> *mut index_t;
    pub fn solver_verify_sip_wcs(solver: *mut solver_t, sip: *mut sip_t);
    pub fn solver_run(solver: *mut solver_t);
    pub fn solver_tweak2(
        solver: *mut solver_t,
        mo: *mut MatchObj,
        order: ::std::os::raw::c_int,
        verifysip: *mut sip_t,
    );
    pub fn solver_cleanup(solver: *mut solver_t);
    pub fn solver_preprocess_field(sp: *mut solver_t);
    pub fn solver_free_field(sp: *mut solver_t);
    pub fn solver_inject_match(solver: *mut solver_t, mo: *mut MatchObj, sip: *mut sip_t);
    pub fn solver_compute_quad_range(
        solver: *const solver_t,
        index: *const index_t,
        arg1: *mut f64,
        arg2: *mut f64,
    );
    #[doc = "Resets the \"numtries\", \"nummatches\", etc counters, as well as\n\"quitnow\"."]
    pub fn solver_reset_counters(t: *mut solver_t);
    #[doc = "Clears the \"best_match_solves\", \"have_best_match\", etc fields."]
    pub fn solver_reset_best_match(sp: *mut solver_t);
    pub fn solver_print_to(sp: *const solver_t, stream: *mut FILE);
    pub fn solver_log_params(sp: *const solver_t);
    pub fn blind_set_xcol(bp: *mut blind_t, x: *const ::std::os::raw::c_char);
    pub fn blind_set_ycol(bp: *mut blind_t, x: *const ::std::os::raw::c_char);
    pub fn blind_add_verify_wcs(bp: *mut blind_t, wcs: *mut sip_t);
    pub fn blind_add_loaded_index(bp: *mut blind_t, ind: *mut index_t);
    pub fn blind_add_index(bp: *mut blind_t, index: *const ::std::os::raw::c_char);
    pub fn blind_clear_verify_wcses(bp: *mut blind_t);
    pub fn blind_clear_indexes(bp: *mut blind_t);
    pub fn blind_clear_solutions(bp: *mut blind_t);
    pub fn blind_add_field(bp: *mut blind_t, field: ::std::os::raw::c_int);
    pub fn blind_add_field_range(
        bp: *mut blind_t,
        lo: ::std::os::raw::c_int,
        hi: ::std::os::raw::c_int,
    );
    pub fn blind_run(bp: *mut blind_t);
    pub fn blind_init(bp: *mut blind_t);
    pub fn blind_cleanup(bp: *mut blind_t);
    pub fn blind_parameters_are_sane(bp: *mut blind_t, sp: *mut solver_t) -> ::std::os::raw::c_int;
    pub fn blind_log_run_parameters(bp: *mut blind_t);
    pub fn blind_free_matchobj(mo: *mut MatchObj);
    pub fn engine_new() -> *mut engine_t;
    pub fn engine_add_search_path(engine: *mut engine_t, path: *const ::std::os::raw::c_char);
    pub fn engine_find_index(
        arg1: *mut engine_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn engine_add_index(
        engine: *mut engine_t,
        path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn engine_autoindex_search_paths(engine: *mut engine_t) -> ::std::os::raw::c_int;
    pub fn engine_parse_config_file_stream(
        engine: *mut engine_t,
        fconf: *mut FILE,
    ) -> ::std::os::raw::c_int;
    pub fn engine_parse_config_file(
        engine: *mut engine_t,
        fn_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn engine_run_job(engine: *mut engine_t, job: *mut job_t) -> ::std::os::raw::c_int;
    pub fn engine_free(engine: *mut engine_t);
    pub fn job_free(job: *mut job_t);
    pub fn wcs_pixel_center_for_size(size: f64) -> f64;
    pub fn sip_ensure_inverse_polynomials(sip: *mut sip_t) -> ::std::os::raw::c_int;
    #[doc = "sip->a_order, sip->b_order, sip->a, and sip->b must be set.\n\nsip->ap_order and sip->bp_order must be set.\n\nComputes sip->ap and sip->bp by inverting the forward polynomial evaluated\non a regular grid of points, NX x NY, between xlo,xhi and ylo,yhi.\n\nIf NX,NY are 0, a reasonable default will be chosen.\n\nIf xlo=xhi=0 or ylo=yhi=0, the bounds of the image (from\nsip->wcstan.imagew/h) will be used."]
    pub fn sip_compute_inverse_polynomials(
        sip: *mut sip_t,
        NX: ::std::os::raw::c_int,
        NY: ::std::os::raw::c_int,
        xlo: f64,
        xhi: f64,
        ylo: f64,
        yhi: f64,
    ) -> ::std::os::raw::c_int;
    pub fn sip_filter_stars_in_field(
        sip: *const sip_t,
        tan: *const tan_t,
        xyz: *const f64,
        radec: *const f64,
        N: ::std::os::raw::c_int,
        xy: *mut *mut f64,
        inds: *mut ::std::os::raw::c_int,
        Ngood: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
    #[doc = "Returns the bounds of the image in RA,Dec space, approximately, by\nwalking the boundary of the image in steps of size \"stepsize\".\n\nReturn values satisfy:\n-90 <= decmin <= decmax <= 90\nramin <= ramax\nramin may be < 0, or ramax > 360, if the image straddles RA=0.\n"]
    pub fn sip_get_radec_bounds(
        wcs: *const sip_t,
        stepsize: ::std::os::raw::c_int,
        pramin: *mut f64,
        pramax: *mut f64,
        pdecmin: *mut f64,
        pdecmax: *mut f64,
    );
    pub fn sip_walk_image_boundary(
        wcs: *const sip_t,
        stepsize: f64,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                wcs: *const sip_t,
                x: f64,
                y: f64,
                ra: f64,
                dec: f64,
                token: *mut ::std::os::raw::c_void,
            ),
        >,
        token: *mut ::std::os::raw::c_void,
    );
    pub fn sip_get_radec_center(wcs: *const sip_t, p_ra: *mut f64, p_dec: *mut f64);
    pub fn tan_get_radec_center(wcs: *const tan_t, p_ra: *mut f64, p_dec: *mut f64);
    pub fn sip_get_radius_deg(wcs: *const sip_t) -> f64;
    pub fn tan_get_radius_deg(wcs: *const tan_t) -> f64;
    pub fn sip_get_radec_center_hms(
        wcs: *const sip_t,
        rah: *mut ::std::os::raw::c_int,
        ram: *mut ::std::os::raw::c_int,
        ras: *mut f64,
        decsign: *mut ::std::os::raw::c_int,
        decd: *mut ::std::os::raw::c_int,
        decm: *mut ::std::os::raw::c_int,
        decs: *mut f64,
    );
    pub fn sip_pixel_is_inside_image(wcs: *const sip_t, px: f64, py: f64) -> anbool;
    pub fn sip_is_inside_image(wcs: *const sip_t, ra: f64, dec: f64) -> anbool;
    pub fn sip_get_radec_center_hms_string(
        wcs: *const sip_t,
        rastr: *mut ::std::os::raw::c_char,
        decstr: *mut ::std::os::raw::c_char,
    );
    pub fn sip_get_field_size(
        wcs: *const sip_t,
        pw: *mut f64,
        ph: *mut f64,
        units: *mut *mut ::std::os::raw::c_char,
    );
    pub fn sip_shift(
        sipin: *const sip_t,
        sipout: *mut sip_t,
        xlo: f64,
        xhi: f64,
        ylo: f64,
        yhi: f64,
    );
    pub fn tan_pixel_is_inside_image(wcs: *const tan_t, px: f64, py: f64) -> anbool;
    pub fn tan_is_inside_image(wcs: *const tan_t, ra: f64, dec: f64) -> anbool;
    pub fn tan_transform(
        tanin: *const tan_t,
        tanout: *mut tan_t,
        xlo: f64,
        xhi: f64,
        ylo: f64,
        yhi: f64,
        scale: f64,
    );
    pub fn tan_scale(tanin: *const tan_t, tanout: *mut tan_t, scale: f64);
    pub fn sip_scale(tanin: *const sip_t, tanout: *mut sip_t, scale: f64);
    pub fn tan_rotate(tanin: *const tan_t, tanout: *mut tan_t, rotate: f64);
    pub fn sip_get_image_size(
        hdr: *const qfits_header,
        pW: *mut ::std::os::raw::c_int,
        pH: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sip_read_tan_or_sip_header_file_ext(
        fn_: *const ::std::os::raw::c_char,
        ext: ::std::os::raw::c_int,
        dest: *mut sip_t,
        forcetan: anbool,
    ) -> *mut sip_t;
    pub fn sip_create_header(sip: *const sip_t) -> *mut qfits_header;
    pub fn tan_create_header(tan: *const tan_t) -> *mut qfits_header;
    pub fn sip_add_to_header(hdr: *mut qfits_header, sip: *const sip_t);
    pub fn tan_add_to_header(hdr: *mut qfits_header, tan: *const tan_t);
    pub fn sip_read_header_file(fn_: *const ::std::os::raw::c_char, dest: *mut sip_t)
        -> *mut sip_t;
    pub fn sip_read_header_file_ext(
        fn_: *const ::std::os::raw::c_char,
        ext: ::std::os::raw::c_int,
        dest: *mut sip_t,
    ) -> *mut sip_t;
    pub fn sip_read_header_file_ext_only(
        fn_: *const ::std::os::raw::c_char,
        ext: ::std::os::raw::c_int,
        dest: *mut sip_t,
    ) -> *mut sip_t;
    pub fn tan_read_header_file(fn_: *const ::std::os::raw::c_char, dest: *mut tan_t)
        -> *mut tan_t;
    pub fn tan_read_header_file_ext(
        fn_: *const ::std::os::raw::c_char,
        ext: ::std::os::raw::c_int,
        dest: *mut tan_t,
    ) -> *mut tan_t;
    pub fn tan_read_header_file_ext_only(
        fn_: *const ::std::os::raw::c_char,
        ext: ::std::os::raw::c_int,
        dest: *mut tan_t,
    ) -> *mut tan_t;
    pub fn sip_read_header(hdr: *const qfits_header, dest: *mut sip_t) -> *mut sip_t;
    pub fn tan_read_header(hdr: *const qfits_header, dest: *mut tan_t) -> *mut tan_t;
    pub fn sip_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dest: *mut sip_t,
    ) -> *mut sip_t;
    pub fn tan_write_to(tan: *const tan_t, fid: *mut FILE) -> ::std::os::raw::c_int;
    pub fn sip_write_to(sip: *const sip_t, fid: *mut FILE) -> ::std::os::raw::c_int;
    pub fn sip_write_to_file(
        sip: *const sip_t,
        fn_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn tan_write_to_file(
        tan: *const tan_t,
        fn_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn sep_background(
        image: *const sep_image,
        bw: ::std::os::raw::c_int,
        bh: ::std::os::raw::c_int,
        fw: ::std::os::raw::c_int,
        fh: ::std::os::raw::c_int,
        fthresh: f64,
        bkg: *mut *mut sep_bkg,
    ) -> ::std::os::raw::c_int;
    pub fn sep_bkg_global(bkg: *const sep_bkg) -> f32;
    pub fn sep_bkg_globalrms(bkg: *const sep_bkg) -> f32;
    pub fn sep_bkg_pix(
        bkg: *const sep_bkg,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> f32;
    pub fn sep_bkg_line(
        bkg: *const sep_bkg,
        y: ::std::os::raw::c_int,
        line: *mut ::std::os::raw::c_void,
        dtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sep_bkg_subline(
        bkg: *const sep_bkg,
        y: ::std::os::raw::c_int,
        line: *mut ::std::os::raw::c_void,
        dtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sep_bkg_rmsline(
        bkg: *const sep_bkg,
        y: ::std::os::raw::c_int,
        line: *mut ::std::os::raw::c_void,
        dtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sep_bkg_array(
        bkg: *const sep_bkg,
        arr: *mut ::std::os::raw::c_void,
        dtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sep_bkg_subarray(
        bkg: *const sep_bkg,
        arr: *mut ::std::os::raw::c_void,
        dtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sep_bkg_rmsarray(
        bkg: *const sep_bkg,
        arr: *mut ::std::os::raw::c_void,
        dtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn sep_bkg_free(bkg: *mut sep_bkg);
    pub fn sep_extract(
        image: *const sep_image,
        thresh: f32,
        thresh_type: ::std::os::raw::c_int,
        minarea: ::std::os::raw::c_int,
        conv: *const f32,
        convw: ::std::os::raw::c_int,
        convh: ::std::os::raw::c_int,
        filter_type: ::std::os::raw::c_int,
        deblend_nthresh: ::std::os::raw::c_int,
        deblend_cont: f64,
        clean_flag: ::std::os::raw::c_int,
        clean_param: f64,
        catalog: *mut *mut sep_catalog,
    ) -> ::std::os::raw::c_int;
    pub fn sep_set_extract_pixstack(val: usize);
    pub fn sep_get_extract_pixstack() -> usize;
    pub fn sep_set_sub_object_limit(val: ::std::os::raw::c_int);
    pub fn sep_get_sub_object_limit() -> ::std::os::raw::c_int;
    pub fn sep_catalog_free(catalog: *mut sep_catalog);
    pub fn sep_sum_circle(
        image: *const sep_image,
        x: f64,
        y: f64,
        r: f64,
        id: ::std::os::raw::c_int,
        subpix: ::std::os::raw::c_int,
        inflags: ::std::os::raw::c_short,
        sum: *mut f64,
        sumerr: *mut f64,
        area: *mut f64,
        flag: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
    pub fn sep_sum_circann(
        image: *const sep_image,
        x: f64,
        y: f64,
        rin: f64,
        rout: f64,
        id: ::std::os::raw::c_int,
        subpix: ::std::os::raw::c_int,
        inflags: ::std::os::raw::c_short,
        sum: *mut f64,
        sumerr: *mut f64,
        area: *mut f64,
        flag: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
    pub fn sep_sum_ellipse(
        image: *const sep_image,
        x: f64,
        y: f64,
        a: f64,
        b: f64,
        theta: f64,
        r: f64,
        id: ::std::os::raw::c_int,
        subpix: ::std::os::raw::c_int,
        inflags: ::std::os::raw::c_short,
        sum: *mut f64,
        sumerr: *mut f64,
        area: *mut f64,
        flag: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
    pub fn sep_sum_ellipann(
        image: *const sep_image,
        x: f64,
        y: f64,
        a: f64,
        b: f64,
        theta: f64,
        rin: f64,
        rout: f64,
        id: ::std::os::raw::c_int,
        subpix: ::std::os::raw::c_int,
        inflags: ::std::os::raw::c_short,
        sum: *mut f64,
        sumerr: *mut f64,
        area: *mut f64,
        flag: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
    pub fn sep_sum_circann_multi(
        im: *const sep_image,
        x: f64,
        y: f64,
        rmax: f64,
        n: ::std::os::raw::c_int,
        id: ::std::os::raw::c_int,
        subpix: ::std::os::raw::c_int,
        inflag: ::std::os::raw::c_short,
        sum: *mut f64,
        sumvar: *mut f64,
        area: *mut f64,
        maskarea: *mut f64,
        flag: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
    pub fn sep_flux_radius(
        im: *const sep_image,
        x: f64,
        y: f64,
        rmax: f64,
        id: ::std::os::raw::c_int,
        subpix: ::std::os::raw::c_int,
        inflag: ::std::os::raw::c_short,
        fluxtot: *const f64,
        fluxfrac: *const f64,
        n: ::std::os::raw::c_int,
        r: *mut f64,
        flag: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
    pub fn sep_kron_radius(
        im: *const sep_image,
        x: f64,
        y: f64,
        cxx: f64,
        cyy: f64,
        cxy: f64,
        r: f64,
        id: ::std::os::raw::c_int,
        kronrad: *mut f64,
        flag: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
    pub fn sep_windowed(
        im: *const sep_image,
        x: f64,
        y: f64,
        sig: f64,
        subpix: ::std::os::raw::c_int,
        inflag: ::std::os::raw::c_short,
        xout: *mut f64,
        yout: *mut f64,
        niter: *mut ::std::os::raw::c_int,
        flag: *mut ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
    pub fn sep_set_ellipse(
        arr: *mut ::std::os::raw::c_uchar,
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
        x: f64,
        y: f64,
        cxx: f64,
        cyy: f64,
        cxy: f64,
        r: f64,
        val: ::std::os::raw::c_uchar,
    );
    pub fn sep_ellipse_axes(
        cxx: f64,
        cyy: f64,
        cxy: f64,
        a: *mut f64,
        b: *mut f64,
        theta: *mut f64,
    ) -> ::std::os::raw::c_int;
    pub fn sep_ellipse_coeffs(
        a: f64,
        b: f64,
        theta: f64,
        cxx: *mut f64,
        cyy: *mut f64,
        cxy: *mut f64,
    );
    pub static sep_version_string: *const ::std::os::raw::c_char;
    pub fn sep_get_errmsg(status: ::std::os::raw::c_int, errtext: *mut ::std::os::raw::c_char);
    pub fn sep_get_errdetail(errtext: *mut ::std::os::raw::c_char);
}
