/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const MAX_AUDIO_FRAME_NUM: u32 = 50;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _SYS_TIME_H: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const __BITS_PER_LONG: u32 = 64;
pub const V4L2_SEL_TGT_CROP: u32 = 0;
pub const V4L2_SEL_TGT_CROP_DEFAULT: u32 = 1;
pub const V4L2_SEL_TGT_CROP_BOUNDS: u32 = 2;
pub const V4L2_SEL_TGT_NATIVE_SIZE: u32 = 3;
pub const V4L2_SEL_TGT_COMPOSE: u32 = 256;
pub const V4L2_SEL_TGT_COMPOSE_DEFAULT: u32 = 257;
pub const V4L2_SEL_TGT_COMPOSE_BOUNDS: u32 = 258;
pub const V4L2_SEL_TGT_COMPOSE_PADDED: u32 = 259;
pub const V4L2_SEL_FLAG_GE: u32 = 1;
pub const V4L2_SEL_FLAG_LE: u32 = 2;
pub const V4L2_SEL_FLAG_KEEP_CONFIG: u32 = 4;
pub const V4L2_SEL_TGT_CROP_ACTIVE: u32 = 0;
pub const V4L2_SEL_TGT_COMPOSE_ACTIVE: u32 = 256;
pub const V4L2_SUBDEV_SEL_TGT_CROP_ACTUAL: u32 = 0;
pub const V4L2_SUBDEV_SEL_TGT_COMPOSE_ACTUAL: u32 = 256;
pub const V4L2_SUBDEV_SEL_TGT_CROP_BOUNDS: u32 = 2;
pub const V4L2_SUBDEV_SEL_TGT_COMPOSE_BOUNDS: u32 = 258;
pub const V4L2_SUBDEV_SEL_FLAG_SIZE_GE: u32 = 1;
pub const V4L2_SUBDEV_SEL_FLAG_SIZE_LE: u32 = 2;
pub const V4L2_SUBDEV_SEL_FLAG_KEEP_CONFIG: u32 = 4;
pub const V4L2_CTRL_CLASS_USER: u32 = 9961472;
pub const V4L2_CTRL_CLASS_CODEC: u32 = 10027008;
pub const V4L2_CTRL_CLASS_CAMERA: u32 = 10092544;
pub const V4L2_CTRL_CLASS_FM_TX: u32 = 10158080;
pub const V4L2_CTRL_CLASS_FLASH: u32 = 10223616;
pub const V4L2_CTRL_CLASS_JPEG: u32 = 10289152;
pub const V4L2_CTRL_CLASS_IMAGE_SOURCE: u32 = 10354688;
pub const V4L2_CTRL_CLASS_IMAGE_PROC: u32 = 10420224;
pub const V4L2_CTRL_CLASS_DV: u32 = 10485760;
pub const V4L2_CTRL_CLASS_FM_RX: u32 = 10551296;
pub const V4L2_CTRL_CLASS_RF_TUNER: u32 = 10616832;
pub const V4L2_CTRL_CLASS_DETECT: u32 = 10682368;
pub const V4L2_CTRL_CLASS_CODEC_STATELESS: u32 = 10747904;
pub const V4L2_CTRL_CLASS_COLORIMETRY: u32 = 10813440;
pub const V4L2_CID_BASE: u32 = 9963776;
pub const V4L2_CID_USER_BASE: u32 = 9963776;
pub const V4L2_CID_USER_CLASS: u32 = 9961473;
pub const V4L2_CID_BRIGHTNESS: u32 = 9963776;
pub const V4L2_CID_CONTRAST: u32 = 9963777;
pub const V4L2_CID_SATURATION: u32 = 9963778;
pub const V4L2_CID_HUE: u32 = 9963779;
pub const V4L2_CID_AUDIO_VOLUME: u32 = 9963781;
pub const V4L2_CID_AUDIO_BALANCE: u32 = 9963782;
pub const V4L2_CID_AUDIO_BASS: u32 = 9963783;
pub const V4L2_CID_AUDIO_TREBLE: u32 = 9963784;
pub const V4L2_CID_AUDIO_MUTE: u32 = 9963785;
pub const V4L2_CID_AUDIO_LOUDNESS: u32 = 9963786;
pub const V4L2_CID_BLACK_LEVEL: u32 = 9963787;
pub const V4L2_CID_AUTO_WHITE_BALANCE: u32 = 9963788;
pub const V4L2_CID_DO_WHITE_BALANCE: u32 = 9963789;
pub const V4L2_CID_RED_BALANCE: u32 = 9963790;
pub const V4L2_CID_BLUE_BALANCE: u32 = 9963791;
pub const V4L2_CID_GAMMA: u32 = 9963792;
pub const V4L2_CID_WHITENESS: u32 = 9963792;
pub const V4L2_CID_EXPOSURE: u32 = 9963793;
pub const V4L2_CID_AUTOGAIN: u32 = 9963794;
pub const V4L2_CID_GAIN: u32 = 9963795;
pub const V4L2_CID_HFLIP: u32 = 9963796;
pub const V4L2_CID_VFLIP: u32 = 9963797;
pub const V4L2_CID_POWER_LINE_FREQUENCY: u32 = 9963800;
pub const V4L2_CID_HUE_AUTO: u32 = 9963801;
pub const V4L2_CID_WHITE_BALANCE_TEMPERATURE: u32 = 9963802;
pub const V4L2_CID_SHARPNESS: u32 = 9963803;
pub const V4L2_CID_BACKLIGHT_COMPENSATION: u32 = 9963804;
pub const V4L2_CID_CHROMA_AGC: u32 = 9963805;
pub const V4L2_CID_COLOR_KILLER: u32 = 9963806;
pub const V4L2_CID_COLORFX: u32 = 9963807;
pub const V4L2_CID_AUTOBRIGHTNESS: u32 = 9963808;
pub const V4L2_CID_BAND_STOP_FILTER: u32 = 9963809;
pub const V4L2_CID_ROTATE: u32 = 9963810;
pub const V4L2_CID_BG_COLOR: u32 = 9963811;
pub const V4L2_CID_CHROMA_GAIN: u32 = 9963812;
pub const V4L2_CID_ILLUMINATORS_1: u32 = 9963813;
pub const V4L2_CID_ILLUMINATORS_2: u32 = 9963814;
pub const V4L2_CID_MIN_BUFFERS_FOR_CAPTURE: u32 = 9963815;
pub const V4L2_CID_MIN_BUFFERS_FOR_OUTPUT: u32 = 9963816;
pub const V4L2_CID_ALPHA_COMPONENT: u32 = 9963817;
pub const V4L2_CID_COLORFX_CBCR: u32 = 9963818;
pub const V4L2_CID_LASTP1: u32 = 9963819;
pub const V4L2_CID_USER_MEYE_BASE: u32 = 9967872;
pub const V4L2_CID_USER_BTTV_BASE: u32 = 9967888;
pub const V4L2_CID_USER_S2255_BASE: u32 = 9967920;
pub const V4L2_CID_USER_SI476X_BASE: u32 = 9967936;
pub const V4L2_CID_USER_TI_VPE_BASE: u32 = 9967952;
pub const V4L2_CID_USER_SAA7134_BASE: u32 = 9967968;
pub const V4L2_CID_USER_ADV7180_BASE: u32 = 9967984;
pub const V4L2_CID_USER_TC358743_BASE: u32 = 9968000;
pub const V4L2_CID_USER_MAX217X_BASE: u32 = 9968016;
pub const V4L2_CID_USER_IMX_BASE: u32 = 9968048;
pub const V4L2_CID_USER_ATMEL_ISC_BASE: u32 = 9968064;
pub const V4L2_CID_USER_CODA_BASE: u32 = 9968096;
pub const V4L2_CID_USER_CCS_BASE: u32 = 9968112;
pub const V4L2_CID_CODEC_BASE: u32 = 10029312;
pub const V4L2_CID_CODEC_CLASS: u32 = 10027009;
pub const V4L2_CID_MPEG_STREAM_TYPE: u32 = 10029312;
pub const V4L2_CID_MPEG_STREAM_PID_PMT: u32 = 10029313;
pub const V4L2_CID_MPEG_STREAM_PID_AUDIO: u32 = 10029314;
pub const V4L2_CID_MPEG_STREAM_PID_VIDEO: u32 = 10029315;
pub const V4L2_CID_MPEG_STREAM_PID_PCR: u32 = 10029316;
pub const V4L2_CID_MPEG_STREAM_PES_ID_AUDIO: u32 = 10029317;
pub const V4L2_CID_MPEG_STREAM_PES_ID_VIDEO: u32 = 10029318;
pub const V4L2_CID_MPEG_STREAM_VBI_FMT: u32 = 10029319;
pub const V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ: u32 = 10029412;
pub const V4L2_CID_MPEG_AUDIO_ENCODING: u32 = 10029413;
pub const V4L2_CID_MPEG_AUDIO_L1_BITRATE: u32 = 10029414;
pub const V4L2_CID_MPEG_AUDIO_L2_BITRATE: u32 = 10029415;
pub const V4L2_CID_MPEG_AUDIO_L3_BITRATE: u32 = 10029416;
pub const V4L2_CID_MPEG_AUDIO_MODE: u32 = 10029417;
pub const V4L2_CID_MPEG_AUDIO_MODE_EXTENSION: u32 = 10029418;
pub const V4L2_CID_MPEG_AUDIO_EMPHASIS: u32 = 10029419;
pub const V4L2_CID_MPEG_AUDIO_CRC: u32 = 10029420;
pub const V4L2_CID_MPEG_AUDIO_MUTE: u32 = 10029421;
pub const V4L2_CID_MPEG_AUDIO_AAC_BITRATE: u32 = 10029422;
pub const V4L2_CID_MPEG_AUDIO_AC3_BITRATE: u32 = 10029423;
pub const V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK: u32 = 10029424;
pub const V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK: u32 = 10029425;
pub const V4L2_CID_MPEG_VIDEO_ENCODING: u32 = 10029512;
pub const V4L2_CID_MPEG_VIDEO_ASPECT: u32 = 10029513;
pub const V4L2_CID_MPEG_VIDEO_B_FRAMES: u32 = 10029514;
pub const V4L2_CID_MPEG_VIDEO_GOP_SIZE: u32 = 10029515;
pub const V4L2_CID_MPEG_VIDEO_GOP_CLOSURE: u32 = 10029516;
pub const V4L2_CID_MPEG_VIDEO_PULLDOWN: u32 = 10029517;
pub const V4L2_CID_MPEG_VIDEO_BITRATE_MODE: u32 = 10029518;
pub const V4L2_CID_MPEG_VIDEO_BITRATE: u32 = 10029519;
pub const V4L2_CID_MPEG_VIDEO_BITRATE_PEAK: u32 = 10029520;
pub const V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION: u32 = 10029521;
pub const V4L2_CID_MPEG_VIDEO_MUTE: u32 = 10029522;
pub const V4L2_CID_MPEG_VIDEO_MUTE_YUV: u32 = 10029523;
pub const V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE: u32 = 10029524;
pub const V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER: u32 = 10029525;
pub const V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB: u32 = 10029526;
pub const V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE: u32 = 10029527;
pub const V4L2_CID_MPEG_VIDEO_HEADER_MODE: u32 = 10029528;
pub const V4L2_CID_MPEG_VIDEO_MAX_REF_PIC: u32 = 10029529;
pub const V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE: u32 = 10029530;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES: u32 = 10029531;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB: u32 = 10029532;
pub const V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE: u32 = 10029533;
pub const V4L2_CID_MPEG_VIDEO_VBV_SIZE: u32 = 10029534;
pub const V4L2_CID_MPEG_VIDEO_DEC_PTS: u32 = 10029535;
pub const V4L2_CID_MPEG_VIDEO_DEC_FRAME: u32 = 10029536;
pub const V4L2_CID_MPEG_VIDEO_VBV_DELAY: u32 = 10029537;
pub const V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER: u32 = 10029538;
pub const V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE: u32 = 10029539;
pub const V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE: u32 = 10029540;
pub const V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME: u32 = 10029541;
pub const V4L2_CID_MPEG_VIDEO_BASELAYER_PRIORITY_ID: u32 = 10029542;
pub const V4L2_CID_MPEG_VIDEO_AU_DELIMITER: u32 = 10029543;
pub const V4L2_CID_MPEG_VIDEO_LTR_COUNT: u32 = 10029544;
pub const V4L2_CID_MPEG_VIDEO_FRAME_LTR_INDEX: u32 = 10029545;
pub const V4L2_CID_MPEG_VIDEO_USE_LTR_FRAMES: u32 = 10029546;
pub const V4L2_CID_MPEG_VIDEO_DEC_CONCEAL_COLOR: u32 = 10029547;
pub const V4L2_CID_MPEG_VIDEO_INTRA_REFRESH_PERIOD: u32 = 10029548;
pub const V4L2_CID_MPEG_VIDEO_MPEG2_LEVEL: u32 = 10029582;
pub const V4L2_CID_MPEG_VIDEO_MPEG2_PROFILE: u32 = 10029583;
pub const V4L2_CID_FWHT_I_FRAME_QP: u32 = 10029602;
pub const V4L2_CID_FWHT_P_FRAME_QP: u32 = 10029603;
pub const V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP: u32 = 10029612;
pub const V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP: u32 = 10029613;
pub const V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP: u32 = 10029614;
pub const V4L2_CID_MPEG_VIDEO_H263_MIN_QP: u32 = 10029615;
pub const V4L2_CID_MPEG_VIDEO_H263_MAX_QP: u32 = 10029616;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP: u32 = 10029662;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP: u32 = 10029663;
pub const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP: u32 = 10029664;
pub const V4L2_CID_MPEG_VIDEO_H264_MIN_QP: u32 = 10029665;
pub const V4L2_CID_MPEG_VIDEO_H264_MAX_QP: u32 = 10029666;
pub const V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM: u32 = 10029667;
pub const V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE: u32 = 10029668;
pub const V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE: u32 = 10029669;
pub const V4L2_CID_MPEG_VIDEO_H264_I_PERIOD: u32 = 10029670;
pub const V4L2_CID_MPEG_VIDEO_H264_LEVEL: u32 = 10029671;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA: u32 = 10029672;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA: u32 = 10029673;
pub const V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE: u32 = 10029674;
pub const V4L2_CID_MPEG_VIDEO_H264_PROFILE: u32 = 10029675;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT: u32 = 10029676;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH: u32 = 10029677;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE: u32 = 10029678;
pub const V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC: u32 = 10029679;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING: u32 = 10029680;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0: u32 = 10029681;
pub const V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE: u32 = 10029682;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO: u32 = 10029683;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE: u32 = 10029684;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP: u32 = 10029685;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION: u32 = 10029686;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE: u32 = 10029687;
pub const V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH: u32 = 10029688;
pub const V4L2_CID_MPEG_VIDEO_H264_ASO: u32 = 10029689;
pub const V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER: u32 = 10029690;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING: u32 = 10029691;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE: u32 = 10029692;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER: u32 = 10029693;
pub const V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP: u32 = 10029694;
pub const V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION: u32 = 10029695;
pub const V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET: u32 = 10029696;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MIN_QP: u32 = 10029697;
pub const V4L2_CID_MPEG_VIDEO_H264_I_FRAME_MAX_QP: u32 = 10029698;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MIN_QP: u32 = 10029699;
pub const V4L2_CID_MPEG_VIDEO_H264_P_FRAME_MAX_QP: u32 = 10029700;
pub const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_MIN_QP: u32 = 10029701;
pub const V4L2_CID_MPEG_VIDEO_H264_B_FRAME_MAX_QP: u32 = 10029702;
pub const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L0_BR: u32 = 10029703;
pub const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L1_BR: u32 = 10029704;
pub const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L2_BR: u32 = 10029705;
pub const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L3_BR: u32 = 10029706;
pub const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L4_BR: u32 = 10029707;
pub const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L5_BR: u32 = 10029708;
pub const V4L2_CID_MPEG_VIDEO_H264_HIER_CODING_L6_BR: u32 = 10029709;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP: u32 = 10029712;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP: u32 = 10029713;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP: u32 = 10029714;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP: u32 = 10029715;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP: u32 = 10029716;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL: u32 = 10029717;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE: u32 = 10029718;
pub const V4L2_CID_MPEG_VIDEO_MPEG4_QPEL: u32 = 10029719;
pub const V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS: u32 = 10029812;
pub const V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4: u32 = 10029813;
pub const V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES: u32 = 10029814;
pub const V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL: u32 = 10029815;
pub const V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS: u32 = 10029816;
pub const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD: u32 = 10029817;
pub const V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL: u32 = 10029818;
pub const V4L2_CID_MPEG_VIDEO_VPX_MIN_QP: u32 = 10029819;
pub const V4L2_CID_MPEG_VIDEO_VPX_MAX_QP: u32 = 10029820;
pub const V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP: u32 = 10029821;
pub const V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP: u32 = 10029822;
pub const V4L2_CID_MPEG_VIDEO_VP8_PROFILE: u32 = 10029823;
pub const V4L2_CID_MPEG_VIDEO_VPX_PROFILE: u32 = 10029823;
pub const V4L2_CID_MPEG_VIDEO_VP9_PROFILE: u32 = 10029824;
pub const V4L2_CID_MPEG_VIDEO_VP9_LEVEL: u32 = 10029825;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP: u32 = 10029912;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP: u32 = 10029913;
pub const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP: u32 = 10029914;
pub const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP: u32 = 10029915;
pub const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP: u32 = 10029916;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP: u32 = 10029917;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE: u32 = 10029918;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER: u32 = 10029919;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP: u32 = 10029920;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP: u32 = 10029921;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP: u32 = 10029922;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP: u32 = 10029923;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP: u32 = 10029924;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP: u32 = 10029925;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP: u32 = 10029926;
pub const V4L2_CID_MPEG_VIDEO_HEVC_PROFILE: u32 = 10029927;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LEVEL: u32 = 10029928;
pub const V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION: u32 = 10029929;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TIER: u32 = 10029930;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH: u32 = 10029931;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE: u32 = 10029932;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2: u32 = 10029933;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2: u32 = 10029934;
pub const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE: u32 = 10029935;
pub const V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD: u32 = 10029936;
pub const V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU: u32 = 10029937;
pub const V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED: u32 = 10029938;
pub const V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT: u32 = 10029939;
pub const V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB: u32 = 10029940;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID: u32 = 10029941;
pub const V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING: u32 = 10029942;
pub const V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1: u32 = 10029943;
pub const V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT: u32 = 10029944;
pub const V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION: u32 = 10029945;
pub const V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE: u32 = 10029946;
pub const V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD: u32 = 10029947;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR: u32 = 10029948;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR: u32 = 10029949;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR: u32 = 10029950;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR: u32 = 10029951;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR: u32 = 10029952;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR: u32 = 10029953;
pub const V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR: u32 = 10029954;
pub const V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES: u32 = 10029955;
pub const V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR: u32 = 10029956;
pub const V4L2_CID_MPEG_VIDEO_CONSTANT_QUALITY: u32 = 10029957;
pub const V4L2_CID_MPEG_VIDEO_FRAME_SKIP_MODE: u32 = 10029958;
pub const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_MIN_QP: u32 = 10029959;
pub const V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_MAX_QP: u32 = 10029960;
pub const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_MIN_QP: u32 = 10029961;
pub const V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_MAX_QP: u32 = 10029962;
pub const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_MIN_QP: u32 = 10029963;
pub const V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_MAX_QP: u32 = 10029964;
pub const V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY: u32 = 10029965;
pub const V4L2_CID_MPEG_VIDEO_DEC_DISPLAY_DELAY_ENABLE: u32 = 10029966;
pub const V4L2_CID_CODEC_CX2341X_BASE: u32 = 10031104;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE: u32 = 10031104;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_SPATIAL_FILTER: u32 = 10031105;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE: u32 = 10031106;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE: u32 = 10031107;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE: u32 = 10031108;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER: u32 = 10031109;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE: u32 = 10031110;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_BOTTOM: u32 = 10031111;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_LUMA_MEDIAN_FILTER_TOP: u32 = 10031112;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_BOTTOM: u32 = 10031113;
pub const V4L2_CID_MPEG_CX2341X_VIDEO_CHROMA_MEDIAN_FILTER_TOP: u32 = 10031114;
pub const V4L2_CID_MPEG_CX2341X_STREAM_INSERT_NAV_PACKETS: u32 = 10031115;
pub const V4L2_CID_CODEC_MFC51_BASE: u32 = 10031360;
pub const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY: u32 = 10031360;
pub const V4L2_CID_MPEG_MFC51_VIDEO_DECODER_H264_DISPLAY_DELAY_ENABLE: u32 = 10031361;
pub const V4L2_CID_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE: u32 = 10031362;
pub const V4L2_CID_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE: u32 = 10031363;
pub const V4L2_CID_MPEG_MFC51_VIDEO_PADDING: u32 = 10031364;
pub const V4L2_CID_MPEG_MFC51_VIDEO_PADDING_YUV: u32 = 10031365;
pub const V4L2_CID_MPEG_MFC51_VIDEO_RC_FIXED_TARGET_BIT: u32 = 10031366;
pub const V4L2_CID_MPEG_MFC51_VIDEO_RC_REACTION_COEFF: u32 = 10031367;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_ACTIVITY: u32 = 10031410;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_DARK: u32 = 10031411;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_SMOOTH: u32 = 10031412;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_ADAPTIVE_RC_STATIC: u32 = 10031413;
pub const V4L2_CID_MPEG_MFC51_VIDEO_H264_NUM_REF_PIC_FOR_P: u32 = 10031414;
pub const V4L2_CID_CAMERA_CLASS_BASE: u32 = 10094848;
pub const V4L2_CID_CAMERA_CLASS: u32 = 10092545;
pub const V4L2_CID_EXPOSURE_AUTO: u32 = 10094849;
pub const V4L2_CID_EXPOSURE_ABSOLUTE: u32 = 10094850;
pub const V4L2_CID_EXPOSURE_AUTO_PRIORITY: u32 = 10094851;
pub const V4L2_CID_PAN_RELATIVE: u32 = 10094852;
pub const V4L2_CID_TILT_RELATIVE: u32 = 10094853;
pub const V4L2_CID_PAN_RESET: u32 = 10094854;
pub const V4L2_CID_TILT_RESET: u32 = 10094855;
pub const V4L2_CID_PAN_ABSOLUTE: u32 = 10094856;
pub const V4L2_CID_TILT_ABSOLUTE: u32 = 10094857;
pub const V4L2_CID_FOCUS_ABSOLUTE: u32 = 10094858;
pub const V4L2_CID_FOCUS_RELATIVE: u32 = 10094859;
pub const V4L2_CID_FOCUS_AUTO: u32 = 10094860;
pub const V4L2_CID_ZOOM_ABSOLUTE: u32 = 10094861;
pub const V4L2_CID_ZOOM_RELATIVE: u32 = 10094862;
pub const V4L2_CID_ZOOM_CONTINUOUS: u32 = 10094863;
pub const V4L2_CID_PRIVACY: u32 = 10094864;
pub const V4L2_CID_IRIS_ABSOLUTE: u32 = 10094865;
pub const V4L2_CID_IRIS_RELATIVE: u32 = 10094866;
pub const V4L2_CID_AUTO_EXPOSURE_BIAS: u32 = 10094867;
pub const V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE: u32 = 10094868;
pub const V4L2_CID_WIDE_DYNAMIC_RANGE: u32 = 10094869;
pub const V4L2_CID_IMAGE_STABILIZATION: u32 = 10094870;
pub const V4L2_CID_ISO_SENSITIVITY: u32 = 10094871;
pub const V4L2_CID_ISO_SENSITIVITY_AUTO: u32 = 10094872;
pub const V4L2_CID_EXPOSURE_METERING: u32 = 10094873;
pub const V4L2_CID_SCENE_MODE: u32 = 10094874;
pub const V4L2_CID_3A_LOCK: u32 = 10094875;
pub const V4L2_LOCK_EXPOSURE: u32 = 1;
pub const V4L2_LOCK_WHITE_BALANCE: u32 = 2;
pub const V4L2_LOCK_FOCUS: u32 = 4;
pub const V4L2_CID_AUTO_FOCUS_START: u32 = 10094876;
pub const V4L2_CID_AUTO_FOCUS_STOP: u32 = 10094877;
pub const V4L2_CID_AUTO_FOCUS_STATUS: u32 = 10094878;
pub const V4L2_AUTO_FOCUS_STATUS_IDLE: u32 = 0;
pub const V4L2_AUTO_FOCUS_STATUS_BUSY: u32 = 1;
pub const V4L2_AUTO_FOCUS_STATUS_REACHED: u32 = 2;
pub const V4L2_AUTO_FOCUS_STATUS_FAILED: u32 = 4;
pub const V4L2_CID_AUTO_FOCUS_RANGE: u32 = 10094879;
pub const V4L2_CID_PAN_SPEED: u32 = 10094880;
pub const V4L2_CID_TILT_SPEED: u32 = 10094881;
pub const V4L2_CID_CAMERA_ORIENTATION: u32 = 10094882;
pub const V4L2_CAMERA_ORIENTATION_FRONT: u32 = 0;
pub const V4L2_CAMERA_ORIENTATION_BACK: u32 = 1;
pub const V4L2_CAMERA_ORIENTATION_EXTERNAL: u32 = 2;
pub const V4L2_CID_CAMERA_SENSOR_ROTATION: u32 = 10094883;
pub const V4L2_CID_FM_TX_CLASS_BASE: u32 = 10160384;
pub const V4L2_CID_FM_TX_CLASS: u32 = 10158081;
pub const V4L2_CID_RDS_TX_DEVIATION: u32 = 10160385;
pub const V4L2_CID_RDS_TX_PI: u32 = 10160386;
pub const V4L2_CID_RDS_TX_PTY: u32 = 10160387;
pub const V4L2_CID_RDS_TX_PS_NAME: u32 = 10160389;
pub const V4L2_CID_RDS_TX_RADIO_TEXT: u32 = 10160390;
pub const V4L2_CID_RDS_TX_MONO_STEREO: u32 = 10160391;
pub const V4L2_CID_RDS_TX_ARTIFICIAL_HEAD: u32 = 10160392;
pub const V4L2_CID_RDS_TX_COMPRESSED: u32 = 10160393;
pub const V4L2_CID_RDS_TX_DYNAMIC_PTY: u32 = 10160394;
pub const V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT: u32 = 10160395;
pub const V4L2_CID_RDS_TX_TRAFFIC_PROGRAM: u32 = 10160396;
pub const V4L2_CID_RDS_TX_MUSIC_SPEECH: u32 = 10160397;
pub const V4L2_CID_RDS_TX_ALT_FREQS_ENABLE: u32 = 10160398;
pub const V4L2_CID_RDS_TX_ALT_FREQS: u32 = 10160399;
pub const V4L2_CID_AUDIO_LIMITER_ENABLED: u32 = 10160448;
pub const V4L2_CID_AUDIO_LIMITER_RELEASE_TIME: u32 = 10160449;
pub const V4L2_CID_AUDIO_LIMITER_DEVIATION: u32 = 10160450;
pub const V4L2_CID_AUDIO_COMPRESSION_ENABLED: u32 = 10160464;
pub const V4L2_CID_AUDIO_COMPRESSION_GAIN: u32 = 10160465;
pub const V4L2_CID_AUDIO_COMPRESSION_THRESHOLD: u32 = 10160466;
pub const V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME: u32 = 10160467;
pub const V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME: u32 = 10160468;
pub const V4L2_CID_PILOT_TONE_ENABLED: u32 = 10160480;
pub const V4L2_CID_PILOT_TONE_DEVIATION: u32 = 10160481;
pub const V4L2_CID_PILOT_TONE_FREQUENCY: u32 = 10160482;
pub const V4L2_CID_TUNE_PREEMPHASIS: u32 = 10160496;
pub const V4L2_CID_TUNE_POWER_LEVEL: u32 = 10160497;
pub const V4L2_CID_TUNE_ANTENNA_CAPACITOR: u32 = 10160498;
pub const V4L2_CID_FLASH_CLASS_BASE: u32 = 10225920;
pub const V4L2_CID_FLASH_CLASS: u32 = 10223617;
pub const V4L2_CID_FLASH_LED_MODE: u32 = 10225921;
pub const V4L2_CID_FLASH_STROBE_SOURCE: u32 = 10225922;
pub const V4L2_CID_FLASH_STROBE: u32 = 10225923;
pub const V4L2_CID_FLASH_STROBE_STOP: u32 = 10225924;
pub const V4L2_CID_FLASH_STROBE_STATUS: u32 = 10225925;
pub const V4L2_CID_FLASH_TIMEOUT: u32 = 10225926;
pub const V4L2_CID_FLASH_INTENSITY: u32 = 10225927;
pub const V4L2_CID_FLASH_TORCH_INTENSITY: u32 = 10225928;
pub const V4L2_CID_FLASH_INDICATOR_INTENSITY: u32 = 10225929;
pub const V4L2_CID_FLASH_FAULT: u32 = 10225930;
pub const V4L2_FLASH_FAULT_OVER_VOLTAGE: u32 = 1;
pub const V4L2_FLASH_FAULT_TIMEOUT: u32 = 2;
pub const V4L2_FLASH_FAULT_OVER_TEMPERATURE: u32 = 4;
pub const V4L2_FLASH_FAULT_SHORT_CIRCUIT: u32 = 8;
pub const V4L2_FLASH_FAULT_OVER_CURRENT: u32 = 16;
pub const V4L2_FLASH_FAULT_INDICATOR: u32 = 32;
pub const V4L2_FLASH_FAULT_UNDER_VOLTAGE: u32 = 64;
pub const V4L2_FLASH_FAULT_INPUT_VOLTAGE: u32 = 128;
pub const V4L2_FLASH_FAULT_LED_OVER_TEMPERATURE: u32 = 256;
pub const V4L2_CID_FLASH_CHARGE: u32 = 10225931;
pub const V4L2_CID_FLASH_READY: u32 = 10225932;
pub const V4L2_CID_JPEG_CLASS_BASE: u32 = 10291456;
pub const V4L2_CID_JPEG_CLASS: u32 = 10289153;
pub const V4L2_CID_JPEG_CHROMA_SUBSAMPLING: u32 = 10291457;
pub const V4L2_CID_JPEG_RESTART_INTERVAL: u32 = 10291458;
pub const V4L2_CID_JPEG_COMPRESSION_QUALITY: u32 = 10291459;
pub const V4L2_CID_JPEG_ACTIVE_MARKER: u32 = 10291460;
pub const V4L2_JPEG_ACTIVE_MARKER_APP0: u32 = 1;
pub const V4L2_JPEG_ACTIVE_MARKER_APP1: u32 = 2;
pub const V4L2_JPEG_ACTIVE_MARKER_COM: u32 = 65536;
pub const V4L2_JPEG_ACTIVE_MARKER_DQT: u32 = 131072;
pub const V4L2_JPEG_ACTIVE_MARKER_DHT: u32 = 262144;
pub const V4L2_CID_IMAGE_SOURCE_CLASS_BASE: u32 = 10356992;
pub const V4L2_CID_IMAGE_SOURCE_CLASS: u32 = 10354689;
pub const V4L2_CID_VBLANK: u32 = 10356993;
pub const V4L2_CID_HBLANK: u32 = 10356994;
pub const V4L2_CID_ANALOGUE_GAIN: u32 = 10356995;
pub const V4L2_CID_TEST_PATTERN_RED: u32 = 10356996;
pub const V4L2_CID_TEST_PATTERN_GREENR: u32 = 10356997;
pub const V4L2_CID_TEST_PATTERN_BLUE: u32 = 10356998;
pub const V4L2_CID_TEST_PATTERN_GREENB: u32 = 10356999;
pub const V4L2_CID_UNIT_CELL_SIZE: u32 = 10357000;
pub const V4L2_CID_IMAGE_PROC_CLASS_BASE: u32 = 10422528;
pub const V4L2_CID_IMAGE_PROC_CLASS: u32 = 10420225;
pub const V4L2_CID_LINK_FREQ: u32 = 10422529;
pub const V4L2_CID_PIXEL_RATE: u32 = 10422530;
pub const V4L2_CID_TEST_PATTERN: u32 = 10422531;
pub const V4L2_CID_DEINTERLACING_MODE: u32 = 10422532;
pub const V4L2_CID_DIGITAL_GAIN: u32 = 10422533;
pub const V4L2_CID_DV_CLASS_BASE: u32 = 10488064;
pub const V4L2_CID_DV_CLASS: u32 = 10485761;
pub const V4L2_CID_DV_TX_HOTPLUG: u32 = 10488065;
pub const V4L2_CID_DV_TX_RXSENSE: u32 = 10488066;
pub const V4L2_CID_DV_TX_EDID_PRESENT: u32 = 10488067;
pub const V4L2_CID_DV_TX_MODE: u32 = 10488068;
pub const V4L2_CID_DV_TX_RGB_RANGE: u32 = 10488069;
pub const V4L2_CID_DV_TX_IT_CONTENT_TYPE: u32 = 10488070;
pub const V4L2_CID_DV_RX_POWER_PRESENT: u32 = 10488164;
pub const V4L2_CID_DV_RX_RGB_RANGE: u32 = 10488165;
pub const V4L2_CID_DV_RX_IT_CONTENT_TYPE: u32 = 10488166;
pub const V4L2_CID_FM_RX_CLASS_BASE: u32 = 10553600;
pub const V4L2_CID_FM_RX_CLASS: u32 = 10551297;
pub const V4L2_CID_TUNE_DEEMPHASIS: u32 = 10553601;
pub const V4L2_CID_RDS_RECEPTION: u32 = 10553602;
pub const V4L2_CID_RDS_RX_PTY: u32 = 10553603;
pub const V4L2_CID_RDS_RX_PS_NAME: u32 = 10553604;
pub const V4L2_CID_RDS_RX_RADIO_TEXT: u32 = 10553605;
pub const V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT: u32 = 10553606;
pub const V4L2_CID_RDS_RX_TRAFFIC_PROGRAM: u32 = 10553607;
pub const V4L2_CID_RDS_RX_MUSIC_SPEECH: u32 = 10553608;
pub const V4L2_CID_RF_TUNER_CLASS_BASE: u32 = 10619136;
pub const V4L2_CID_RF_TUNER_CLASS: u32 = 10616833;
pub const V4L2_CID_RF_TUNER_BANDWIDTH_AUTO: u32 = 10619147;
pub const V4L2_CID_RF_TUNER_BANDWIDTH: u32 = 10619148;
pub const V4L2_CID_RF_TUNER_RF_GAIN: u32 = 10619168;
pub const V4L2_CID_RF_TUNER_LNA_GAIN_AUTO: u32 = 10619177;
pub const V4L2_CID_RF_TUNER_LNA_GAIN: u32 = 10619178;
pub const V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO: u32 = 10619187;
pub const V4L2_CID_RF_TUNER_MIXER_GAIN: u32 = 10619188;
pub const V4L2_CID_RF_TUNER_IF_GAIN_AUTO: u32 = 10619197;
pub const V4L2_CID_RF_TUNER_IF_GAIN: u32 = 10619198;
pub const V4L2_CID_RF_TUNER_PLL_LOCK: u32 = 10619227;
pub const V4L2_CID_DETECT_CLASS_BASE: u32 = 10684672;
pub const V4L2_CID_DETECT_CLASS: u32 = 10682369;
pub const V4L2_CID_DETECT_MD_MODE: u32 = 10684673;
pub const V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD: u32 = 10684674;
pub const V4L2_CID_DETECT_MD_THRESHOLD_GRID: u32 = 10684675;
pub const V4L2_CID_DETECT_MD_REGION_GRID: u32 = 10684676;
pub const V4L2_CID_CODEC_STATELESS_BASE: u32 = 10750208;
pub const V4L2_CID_CODEC_STATELESS_CLASS: u32 = 10747905;
pub const V4L2_CID_STATELESS_H264_DECODE_MODE: u32 = 10750208;
pub const V4L2_CID_STATELESS_H264_START_CODE: u32 = 10750209;
pub const V4L2_H264_SPS_CONSTRAINT_SET0_FLAG: u32 = 1;
pub const V4L2_H264_SPS_CONSTRAINT_SET1_FLAG: u32 = 2;
pub const V4L2_H264_SPS_CONSTRAINT_SET2_FLAG: u32 = 4;
pub const V4L2_H264_SPS_CONSTRAINT_SET3_FLAG: u32 = 8;
pub const V4L2_H264_SPS_CONSTRAINT_SET4_FLAG: u32 = 16;
pub const V4L2_H264_SPS_CONSTRAINT_SET5_FLAG: u32 = 32;
pub const V4L2_H264_SPS_FLAG_SEPARATE_COLOUR_PLANE: u32 = 1;
pub const V4L2_H264_SPS_FLAG_QPPRIME_Y_ZERO_TRANSFORM_BYPASS: u32 = 2;
pub const V4L2_H264_SPS_FLAG_DELTA_PIC_ORDER_ALWAYS_ZERO: u32 = 4;
pub const V4L2_H264_SPS_FLAG_GAPS_IN_FRAME_NUM_VALUE_ALLOWED: u32 = 8;
pub const V4L2_H264_SPS_FLAG_FRAME_MBS_ONLY: u32 = 16;
pub const V4L2_H264_SPS_FLAG_MB_ADAPTIVE_FRAME_FIELD: u32 = 32;
pub const V4L2_H264_SPS_FLAG_DIRECT_8X8_INFERENCE: u32 = 64;
pub const V4L2_CID_STATELESS_H264_SPS: u32 = 10750210;
pub const V4L2_H264_PPS_FLAG_ENTROPY_CODING_MODE: u32 = 1;
pub const V4L2_H264_PPS_FLAG_BOTTOM_FIELD_PIC_ORDER_IN_FRAME_PRESENT: u32 = 2;
pub const V4L2_H264_PPS_FLAG_WEIGHTED_PRED: u32 = 4;
pub const V4L2_H264_PPS_FLAG_DEBLOCKING_FILTER_CONTROL_PRESENT: u32 = 8;
pub const V4L2_H264_PPS_FLAG_CONSTRAINED_INTRA_PRED: u32 = 16;
pub const V4L2_H264_PPS_FLAG_REDUNDANT_PIC_CNT_PRESENT: u32 = 32;
pub const V4L2_H264_PPS_FLAG_TRANSFORM_8X8_MODE: u32 = 64;
pub const V4L2_H264_PPS_FLAG_SCALING_MATRIX_PRESENT: u32 = 128;
pub const V4L2_CID_STATELESS_H264_PPS: u32 = 10750211;
pub const V4L2_CID_STATELESS_H264_SCALING_MATRIX: u32 = 10750212;
pub const V4L2_CID_STATELESS_H264_PRED_WEIGHTS: u32 = 10750213;
pub const V4L2_H264_SLICE_TYPE_P: u32 = 0;
pub const V4L2_H264_SLICE_TYPE_B: u32 = 1;
pub const V4L2_H264_SLICE_TYPE_I: u32 = 2;
pub const V4L2_H264_SLICE_TYPE_SP: u32 = 3;
pub const V4L2_H264_SLICE_TYPE_SI: u32 = 4;
pub const V4L2_H264_SLICE_FLAG_DIRECT_SPATIAL_MV_PRED: u32 = 1;
pub const V4L2_H264_SLICE_FLAG_SP_FOR_SWITCH: u32 = 2;
pub const V4L2_H264_TOP_FIELD_REF: u32 = 1;
pub const V4L2_H264_BOTTOM_FIELD_REF: u32 = 2;
pub const V4L2_H264_FRAME_REF: u32 = 3;
pub const V4L2_H264_NUM_DPB_ENTRIES: u32 = 16;
pub const V4L2_H264_REF_LIST_LEN: u32 = 32;
pub const V4L2_CID_STATELESS_H264_SLICE_PARAMS: u32 = 10750214;
pub const V4L2_H264_DPB_ENTRY_FLAG_VALID: u32 = 1;
pub const V4L2_H264_DPB_ENTRY_FLAG_ACTIVE: u32 = 2;
pub const V4L2_H264_DPB_ENTRY_FLAG_LONG_TERM: u32 = 4;
pub const V4L2_H264_DPB_ENTRY_FLAG_FIELD: u32 = 8;
pub const V4L2_H264_DECODE_PARAM_FLAG_IDR_PIC: u32 = 1;
pub const V4L2_H264_DECODE_PARAM_FLAG_FIELD_PIC: u32 = 2;
pub const V4L2_H264_DECODE_PARAM_FLAG_BOTTOM_FIELD: u32 = 4;
pub const V4L2_CID_STATELESS_H264_DECODE_PARAMS: u32 = 10750215;
pub const V4L2_FWHT_VERSION: u32 = 3;
pub const V4L2_FWHT_FL_COMPONENTS_NUM_OFFSET: u32 = 16;
pub const V4L2_FWHT_FL_PIXENC_OFFSET: u32 = 19;
pub const V4L2_FWHT_FL_PIXENC_YUV: u32 = 524288;
pub const V4L2_FWHT_FL_PIXENC_RGB: u32 = 1048576;
pub const V4L2_FWHT_FL_PIXENC_HSV: u32 = 1572864;
pub const V4L2_CID_STATELESS_FWHT_PARAMS: u32 = 10750308;
pub const V4L2_VP8_SEGMENT_FLAG_ENABLED: u32 = 1;
pub const V4L2_VP8_SEGMENT_FLAG_UPDATE_MAP: u32 = 2;
pub const V4L2_VP8_SEGMENT_FLAG_UPDATE_FEATURE_DATA: u32 = 4;
pub const V4L2_VP8_SEGMENT_FLAG_DELTA_VALUE_MODE: u32 = 8;
pub const V4L2_VP8_LF_ADJ_ENABLE: u32 = 1;
pub const V4L2_VP8_LF_DELTA_UPDATE: u32 = 2;
pub const V4L2_VP8_LF_FILTER_TYPE_SIMPLE: u32 = 4;
pub const V4L2_VP8_COEFF_PROB_CNT: u32 = 11;
pub const V4L2_VP8_MV_PROB_CNT: u32 = 19;
pub const V4L2_VP8_FRAME_FLAG_KEY_FRAME: u32 = 1;
pub const V4L2_VP8_FRAME_FLAG_EXPERIMENTAL: u32 = 2;
pub const V4L2_VP8_FRAME_FLAG_SHOW_FRAME: u32 = 4;
pub const V4L2_VP8_FRAME_FLAG_MB_NO_SKIP_COEFF: u32 = 8;
pub const V4L2_VP8_FRAME_FLAG_SIGN_BIAS_GOLDEN: u32 = 16;
pub const V4L2_VP8_FRAME_FLAG_SIGN_BIAS_ALT: u32 = 32;
pub const V4L2_CID_STATELESS_VP8_FRAME: u32 = 10750408;
pub const V4L2_MPEG2_SEQ_FLAG_PROGRESSIVE: u32 = 1;
pub const V4L2_CID_STATELESS_MPEG2_SEQUENCE: u32 = 10750428;
pub const V4L2_MPEG2_PIC_CODING_TYPE_I: u32 = 1;
pub const V4L2_MPEG2_PIC_CODING_TYPE_P: u32 = 2;
pub const V4L2_MPEG2_PIC_CODING_TYPE_B: u32 = 3;
pub const V4L2_MPEG2_PIC_CODING_TYPE_D: u32 = 4;
pub const V4L2_MPEG2_PIC_TOP_FIELD: u32 = 1;
pub const V4L2_MPEG2_PIC_BOTTOM_FIELD: u32 = 2;
pub const V4L2_MPEG2_PIC_FRAME: u32 = 3;
pub const V4L2_MPEG2_PIC_FLAG_TOP_FIELD_FIRST: u32 = 1;
pub const V4L2_MPEG2_PIC_FLAG_FRAME_PRED_DCT: u32 = 2;
pub const V4L2_MPEG2_PIC_FLAG_CONCEALMENT_MV: u32 = 4;
pub const V4L2_MPEG2_PIC_FLAG_Q_SCALE_TYPE: u32 = 8;
pub const V4L2_MPEG2_PIC_FLAG_INTRA_VLC: u32 = 16;
pub const V4L2_MPEG2_PIC_FLAG_ALT_SCAN: u32 = 32;
pub const V4L2_MPEG2_PIC_FLAG_REPEAT_FIRST: u32 = 64;
pub const V4L2_MPEG2_PIC_FLAG_PROGRESSIVE: u32 = 128;
pub const V4L2_CID_STATELESS_MPEG2_PICTURE: u32 = 10750429;
pub const V4L2_CID_STATELESS_MPEG2_QUANTISATION: u32 = 10750430;
pub const V4L2_CID_COLORIMETRY_CLASS_BASE: u32 = 10815744;
pub const V4L2_CID_COLORIMETRY_CLASS: u32 = 10813441;
pub const V4L2_CID_COLORIMETRY_HDR10_CLL_INFO: u32 = 10815744;
pub const V4L2_CID_COLORIMETRY_HDR10_MASTERING_DISPLAY: u32 = 10815745;
pub const V4L2_HDR10_MASTERING_PRIMARIES_X_LOW: u32 = 5;
pub const V4L2_HDR10_MASTERING_PRIMARIES_X_HIGH: u32 = 37000;
pub const V4L2_HDR10_MASTERING_PRIMARIES_Y_LOW: u32 = 5;
pub const V4L2_HDR10_MASTERING_PRIMARIES_Y_HIGH: u32 = 42000;
pub const V4L2_HDR10_MASTERING_WHITE_POINT_X_LOW: u32 = 5;
pub const V4L2_HDR10_MASTERING_WHITE_POINT_X_HIGH: u32 = 37000;
pub const V4L2_HDR10_MASTERING_WHITE_POINT_Y_LOW: u32 = 5;
pub const V4L2_HDR10_MASTERING_WHITE_POINT_Y_HIGH: u32 = 42000;
pub const V4L2_HDR10_MASTERING_MAX_LUMA_LOW: u32 = 50000;
pub const V4L2_HDR10_MASTERING_MAX_LUMA_HIGH: u32 = 100000000;
pub const V4L2_HDR10_MASTERING_MIN_LUMA_LOW: u32 = 1;
pub const V4L2_HDR10_MASTERING_MIN_LUMA_HIGH: u32 = 50000;
pub const V4L2_CTRL_CLASS_MPEG: u32 = 10027008;
pub const V4L2_CID_MPEG_CLASS: u32 = 10027009;
pub const V4L2_CID_MPEG_BASE: u32 = 10029312;
pub const V4L2_CID_MPEG_CX2341X_BASE: u32 = 10031104;
pub const V4L2_CID_MPEG_MFC51_BASE: u32 = 10031360;
pub const VIDEO_MAX_FRAME: u32 = 32;
pub const VIDEO_MAX_PLANES: u32 = 8;
pub const V4L2_CAP_VIDEO_CAPTURE: u32 = 1;
pub const V4L2_CAP_VIDEO_OUTPUT: u32 = 2;
pub const V4L2_CAP_VIDEO_OVERLAY: u32 = 4;
pub const V4L2_CAP_VBI_CAPTURE: u32 = 16;
pub const V4L2_CAP_VBI_OUTPUT: u32 = 32;
pub const V4L2_CAP_SLICED_VBI_CAPTURE: u32 = 64;
pub const V4L2_CAP_SLICED_VBI_OUTPUT: u32 = 128;
pub const V4L2_CAP_RDS_CAPTURE: u32 = 256;
pub const V4L2_CAP_VIDEO_OUTPUT_OVERLAY: u32 = 512;
pub const V4L2_CAP_HW_FREQ_SEEK: u32 = 1024;
pub const V4L2_CAP_RDS_OUTPUT: u32 = 2048;
pub const V4L2_CAP_VIDEO_CAPTURE_MPLANE: u32 = 4096;
pub const V4L2_CAP_VIDEO_OUTPUT_MPLANE: u32 = 8192;
pub const V4L2_CAP_VIDEO_M2M_MPLANE: u32 = 16384;
pub const V4L2_CAP_VIDEO_M2M: u32 = 32768;
pub const V4L2_CAP_TUNER: u32 = 65536;
pub const V4L2_CAP_AUDIO: u32 = 131072;
pub const V4L2_CAP_RADIO: u32 = 262144;
pub const V4L2_CAP_MODULATOR: u32 = 524288;
pub const V4L2_CAP_SDR_CAPTURE: u32 = 1048576;
pub const V4L2_CAP_EXT_PIX_FORMAT: u32 = 2097152;
pub const V4L2_CAP_SDR_OUTPUT: u32 = 4194304;
pub const V4L2_CAP_META_CAPTURE: u32 = 8388608;
pub const V4L2_CAP_READWRITE: u32 = 16777216;
pub const V4L2_CAP_ASYNCIO: u32 = 33554432;
pub const V4L2_CAP_STREAMING: u32 = 67108864;
pub const V4L2_CAP_META_OUTPUT: u32 = 134217728;
pub const V4L2_CAP_TOUCH: u32 = 268435456;
pub const V4L2_CAP_IO_MC: u32 = 536870912;
pub const V4L2_CAP_DEVICE_CAPS: u32 = 2147483648;
pub const V4L2_PIX_FMT_PRIV_MAGIC: u32 = 4276996862;
pub const V4L2_PIX_FMT_FLAG_PREMUL_ALPHA: u32 = 1;
pub const V4L2_PIX_FMT_FLAG_SET_CSC: u32 = 2;
pub const V4L2_FMT_FLAG_COMPRESSED: u32 = 1;
pub const V4L2_FMT_FLAG_EMULATED: u32 = 2;
pub const V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM: u32 = 4;
pub const V4L2_FMT_FLAG_DYN_RESOLUTION: u32 = 8;
pub const V4L2_FMT_FLAG_ENC_CAP_FRAME_INTERVAL: u32 = 16;
pub const V4L2_FMT_FLAG_CSC_COLORSPACE: u32 = 32;
pub const V4L2_FMT_FLAG_CSC_XFER_FUNC: u32 = 64;
pub const V4L2_FMT_FLAG_CSC_YCBCR_ENC: u32 = 128;
pub const V4L2_FMT_FLAG_CSC_HSV_ENC: u32 = 128;
pub const V4L2_FMT_FLAG_CSC_QUANTIZATION: u32 = 256;
pub const V4L2_TC_TYPE_24FPS: u32 = 1;
pub const V4L2_TC_TYPE_25FPS: u32 = 2;
pub const V4L2_TC_TYPE_30FPS: u32 = 3;
pub const V4L2_TC_TYPE_50FPS: u32 = 4;
pub const V4L2_TC_TYPE_60FPS: u32 = 5;
pub const V4L2_TC_FLAG_DROPFRAME: u32 = 1;
pub const V4L2_TC_FLAG_COLORFRAME: u32 = 2;
pub const V4L2_TC_USERBITS_field: u32 = 12;
pub const V4L2_TC_USERBITS_USERDEFINED: u32 = 0;
pub const V4L2_TC_USERBITS_8BITCHARS: u32 = 8;
pub const V4L2_JPEG_MARKER_DHT: u32 = 8;
pub const V4L2_JPEG_MARKER_DQT: u32 = 16;
pub const V4L2_JPEG_MARKER_DRI: u32 = 32;
pub const V4L2_JPEG_MARKER_COM: u32 = 64;
pub const V4L2_JPEG_MARKER_APP: u32 = 128;
pub const V4L2_BUF_CAP_SUPPORTS_MMAP: u32 = 1;
pub const V4L2_BUF_CAP_SUPPORTS_USERPTR: u32 = 2;
pub const V4L2_BUF_CAP_SUPPORTS_DMABUF: u32 = 4;
pub const V4L2_BUF_CAP_SUPPORTS_REQUESTS: u32 = 8;
pub const V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS: u32 = 16;
pub const V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF: u32 = 32;
pub const V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS: u32 = 64;
pub const V4L2_BUF_FLAG_MAPPED: u32 = 1;
pub const V4L2_BUF_FLAG_QUEUED: u32 = 2;
pub const V4L2_BUF_FLAG_DONE: u32 = 4;
pub const V4L2_BUF_FLAG_KEYFRAME: u32 = 8;
pub const V4L2_BUF_FLAG_PFRAME: u32 = 16;
pub const V4L2_BUF_FLAG_BFRAME: u32 = 32;
pub const V4L2_BUF_FLAG_ERROR: u32 = 64;
pub const V4L2_BUF_FLAG_IN_REQUEST: u32 = 128;
pub const V4L2_BUF_FLAG_TIMECODE: u32 = 256;
pub const V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF: u32 = 512;
pub const V4L2_BUF_FLAG_PREPARED: u32 = 1024;
pub const V4L2_BUF_FLAG_NO_CACHE_INVALIDATE: u32 = 2048;
pub const V4L2_BUF_FLAG_NO_CACHE_CLEAN: u32 = 4096;
pub const V4L2_BUF_FLAG_TIMESTAMP_MASK: u32 = 57344;
pub const V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN: u32 = 0;
pub const V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC: u32 = 8192;
pub const V4L2_BUF_FLAG_TIMESTAMP_COPY: u32 = 16384;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_MASK: u32 = 458752;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_EOF: u32 = 0;
pub const V4L2_BUF_FLAG_TSTAMP_SRC_SOE: u32 = 65536;
pub const V4L2_BUF_FLAG_LAST: u32 = 1048576;
pub const V4L2_BUF_FLAG_REQUEST_FD: u32 = 8388608;
pub const V4L2_FBUF_CAP_EXTERNOVERLAY: u32 = 1;
pub const V4L2_FBUF_CAP_CHROMAKEY: u32 = 2;
pub const V4L2_FBUF_CAP_LIST_CLIPPING: u32 = 4;
pub const V4L2_FBUF_CAP_BITMAP_CLIPPING: u32 = 8;
pub const V4L2_FBUF_CAP_LOCAL_ALPHA: u32 = 16;
pub const V4L2_FBUF_CAP_GLOBAL_ALPHA: u32 = 32;
pub const V4L2_FBUF_CAP_LOCAL_INV_ALPHA: u32 = 64;
pub const V4L2_FBUF_CAP_SRC_CHROMAKEY: u32 = 128;
pub const V4L2_FBUF_FLAG_PRIMARY: u32 = 1;
pub const V4L2_FBUF_FLAG_OVERLAY: u32 = 2;
pub const V4L2_FBUF_FLAG_CHROMAKEY: u32 = 4;
pub const V4L2_FBUF_FLAG_LOCAL_ALPHA: u32 = 8;
pub const V4L2_FBUF_FLAG_GLOBAL_ALPHA: u32 = 16;
pub const V4L2_FBUF_FLAG_LOCAL_INV_ALPHA: u32 = 32;
pub const V4L2_FBUF_FLAG_SRC_CHROMAKEY: u32 = 64;
pub const V4L2_MODE_HIGHQUALITY: u32 = 1;
pub const V4L2_CAP_TIMEPERFRAME: u32 = 4096;
pub const V4L2_STD_UNKNOWN: u32 = 0;
pub const V4L2_DV_PROGRESSIVE: u32 = 0;
pub const V4L2_DV_INTERLACED: u32 = 1;
pub const V4L2_DV_VSYNC_POS_POL: u32 = 1;
pub const V4L2_DV_HSYNC_POS_POL: u32 = 2;
pub const V4L2_DV_BT_STD_CEA861: u32 = 1;
pub const V4L2_DV_BT_STD_DMT: u32 = 2;
pub const V4L2_DV_BT_STD_CVT: u32 = 4;
pub const V4L2_DV_BT_STD_GTF: u32 = 8;
pub const V4L2_DV_BT_STD_SDI: u32 = 16;
pub const V4L2_DV_FL_REDUCED_BLANKING: u32 = 1;
pub const V4L2_DV_FL_CAN_REDUCE_FPS: u32 = 2;
pub const V4L2_DV_FL_REDUCED_FPS: u32 = 4;
pub const V4L2_DV_FL_HALF_LINE: u32 = 8;
pub const V4L2_DV_FL_IS_CE_VIDEO: u32 = 16;
pub const V4L2_DV_FL_FIRST_FIELD_EXTRA_LINE: u32 = 32;
pub const V4L2_DV_FL_HAS_PICTURE_ASPECT: u32 = 64;
pub const V4L2_DV_FL_HAS_CEA861_VIC: u32 = 128;
pub const V4L2_DV_FL_HAS_HDMI_VIC: u32 = 256;
pub const V4L2_DV_FL_CAN_DETECT_REDUCED_FPS: u32 = 512;
pub const V4L2_DV_BT_656_1120: u32 = 0;
pub const V4L2_DV_BT_CAP_INTERLACED: u32 = 1;
pub const V4L2_DV_BT_CAP_PROGRESSIVE: u32 = 2;
pub const V4L2_DV_BT_CAP_REDUCED_BLANKING: u32 = 4;
pub const V4L2_DV_BT_CAP_CUSTOM: u32 = 8;
pub const V4L2_INPUT_TYPE_TUNER: u32 = 1;
pub const V4L2_INPUT_TYPE_CAMERA: u32 = 2;
pub const V4L2_INPUT_TYPE_TOUCH: u32 = 3;
pub const V4L2_IN_ST_NO_POWER: u32 = 1;
pub const V4L2_IN_ST_NO_SIGNAL: u32 = 2;
pub const V4L2_IN_ST_NO_COLOR: u32 = 4;
pub const V4L2_IN_ST_HFLIP: u32 = 16;
pub const V4L2_IN_ST_VFLIP: u32 = 32;
pub const V4L2_IN_ST_NO_H_LOCK: u32 = 256;
pub const V4L2_IN_ST_COLOR_KILL: u32 = 512;
pub const V4L2_IN_ST_NO_V_LOCK: u32 = 1024;
pub const V4L2_IN_ST_NO_STD_LOCK: u32 = 2048;
pub const V4L2_IN_ST_NO_SYNC: u32 = 65536;
pub const V4L2_IN_ST_NO_EQU: u32 = 131072;
pub const V4L2_IN_ST_NO_CARRIER: u32 = 262144;
pub const V4L2_IN_ST_MACROVISION: u32 = 16777216;
pub const V4L2_IN_ST_NO_ACCESS: u32 = 33554432;
pub const V4L2_IN_ST_VTR: u32 = 67108864;
pub const V4L2_IN_CAP_DV_TIMINGS: u32 = 2;
pub const V4L2_IN_CAP_CUSTOM_TIMINGS: u32 = 2;
pub const V4L2_IN_CAP_STD: u32 = 4;
pub const V4L2_IN_CAP_NATIVE_SIZE: u32 = 8;
pub const V4L2_OUTPUT_TYPE_MODULATOR: u32 = 1;
pub const V4L2_OUTPUT_TYPE_ANALOG: u32 = 2;
pub const V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY: u32 = 3;
pub const V4L2_OUT_CAP_DV_TIMINGS: u32 = 2;
pub const V4L2_OUT_CAP_CUSTOM_TIMINGS: u32 = 2;
pub const V4L2_OUT_CAP_STD: u32 = 4;
pub const V4L2_OUT_CAP_NATIVE_SIZE: u32 = 8;
pub const V4L2_CTRL_ID_MASK: u32 = 268435455;
pub const V4L2_CTRL_MAX_DIMS: u32 = 4;
pub const V4L2_CTRL_WHICH_CUR_VAL: u32 = 0;
pub const V4L2_CTRL_WHICH_DEF_VAL: u32 = 251658240;
pub const V4L2_CTRL_WHICH_REQUEST_VAL: u32 = 251723776;
pub const V4L2_CTRL_FLAG_DISABLED: u32 = 1;
pub const V4L2_CTRL_FLAG_GRABBED: u32 = 2;
pub const V4L2_CTRL_FLAG_READ_ONLY: u32 = 4;
pub const V4L2_CTRL_FLAG_UPDATE: u32 = 8;
pub const V4L2_CTRL_FLAG_INACTIVE: u32 = 16;
pub const V4L2_CTRL_FLAG_SLIDER: u32 = 32;
pub const V4L2_CTRL_FLAG_WRITE_ONLY: u32 = 64;
pub const V4L2_CTRL_FLAG_VOLATILE: u32 = 128;
pub const V4L2_CTRL_FLAG_HAS_PAYLOAD: u32 = 256;
pub const V4L2_CTRL_FLAG_EXECUTE_ON_WRITE: u32 = 512;
pub const V4L2_CTRL_FLAG_MODIFY_LAYOUT: u32 = 1024;
pub const V4L2_CTRL_FLAG_NEXT_CTRL: u32 = 2147483648;
pub const V4L2_CTRL_FLAG_NEXT_COMPOUND: u32 = 1073741824;
pub const V4L2_CID_MAX_CTRLS: u32 = 1024;
pub const V4L2_CID_PRIVATE_BASE: u32 = 134217728;
pub const V4L2_TUNER_CAP_LOW: u32 = 1;
pub const V4L2_TUNER_CAP_NORM: u32 = 2;
pub const V4L2_TUNER_CAP_HWSEEK_BOUNDED: u32 = 4;
pub const V4L2_TUNER_CAP_HWSEEK_WRAP: u32 = 8;
pub const V4L2_TUNER_CAP_STEREO: u32 = 16;
pub const V4L2_TUNER_CAP_LANG2: u32 = 32;
pub const V4L2_TUNER_CAP_SAP: u32 = 32;
pub const V4L2_TUNER_CAP_LANG1: u32 = 64;
pub const V4L2_TUNER_CAP_RDS: u32 = 128;
pub const V4L2_TUNER_CAP_RDS_BLOCK_IO: u32 = 256;
pub const V4L2_TUNER_CAP_RDS_CONTROLS: u32 = 512;
pub const V4L2_TUNER_CAP_FREQ_BANDS: u32 = 1024;
pub const V4L2_TUNER_CAP_HWSEEK_PROG_LIM: u32 = 2048;
pub const V4L2_TUNER_CAP_1HZ: u32 = 4096;
pub const V4L2_TUNER_SUB_MONO: u32 = 1;
pub const V4L2_TUNER_SUB_STEREO: u32 = 2;
pub const V4L2_TUNER_SUB_LANG2: u32 = 4;
pub const V4L2_TUNER_SUB_SAP: u32 = 4;
pub const V4L2_TUNER_SUB_LANG1: u32 = 8;
pub const V4L2_TUNER_SUB_RDS: u32 = 16;
pub const V4L2_TUNER_MODE_MONO: u32 = 0;
pub const V4L2_TUNER_MODE_STEREO: u32 = 1;
pub const V4L2_TUNER_MODE_LANG2: u32 = 2;
pub const V4L2_TUNER_MODE_SAP: u32 = 2;
pub const V4L2_TUNER_MODE_LANG1: u32 = 3;
pub const V4L2_TUNER_MODE_LANG1_LANG2: u32 = 4;
pub const V4L2_BAND_MODULATION_VSB: u32 = 2;
pub const V4L2_BAND_MODULATION_FM: u32 = 4;
pub const V4L2_BAND_MODULATION_AM: u32 = 8;
pub const V4L2_RDS_BLOCK_MSK: u32 = 7;
pub const V4L2_RDS_BLOCK_A: u32 = 0;
pub const V4L2_RDS_BLOCK_B: u32 = 1;
pub const V4L2_RDS_BLOCK_C: u32 = 2;
pub const V4L2_RDS_BLOCK_D: u32 = 3;
pub const V4L2_RDS_BLOCK_C_ALT: u32 = 4;
pub const V4L2_RDS_BLOCK_INVALID: u32 = 7;
pub const V4L2_RDS_BLOCK_CORRECTED: u32 = 64;
pub const V4L2_RDS_BLOCK_ERROR: u32 = 128;
pub const V4L2_AUDCAP_STEREO: u32 = 1;
pub const V4L2_AUDCAP_AVL: u32 = 2;
pub const V4L2_AUDMODE_AVL: u32 = 1;
pub const V4L2_ENC_IDX_FRAME_I: u32 = 0;
pub const V4L2_ENC_IDX_FRAME_P: u32 = 1;
pub const V4L2_ENC_IDX_FRAME_B: u32 = 2;
pub const V4L2_ENC_IDX_FRAME_MASK: u32 = 15;
pub const V4L2_ENC_IDX_ENTRIES: u32 = 64;
pub const V4L2_ENC_CMD_START: u32 = 0;
pub const V4L2_ENC_CMD_STOP: u32 = 1;
pub const V4L2_ENC_CMD_PAUSE: u32 = 2;
pub const V4L2_ENC_CMD_RESUME: u32 = 3;
pub const V4L2_ENC_CMD_STOP_AT_GOP_END: u32 = 1;
pub const V4L2_DEC_CMD_START: u32 = 0;
pub const V4L2_DEC_CMD_STOP: u32 = 1;
pub const V4L2_DEC_CMD_PAUSE: u32 = 2;
pub const V4L2_DEC_CMD_RESUME: u32 = 3;
pub const V4L2_DEC_CMD_FLUSH: u32 = 4;
pub const V4L2_DEC_CMD_START_MUTE_AUDIO: u32 = 1;
pub const V4L2_DEC_CMD_PAUSE_TO_BLACK: u32 = 1;
pub const V4L2_DEC_CMD_STOP_TO_BLACK: u32 = 1;
pub const V4L2_DEC_CMD_STOP_IMMEDIATELY: u32 = 2;
pub const V4L2_DEC_START_FMT_NONE: u32 = 0;
pub const V4L2_DEC_START_FMT_GOP: u32 = 1;
pub const V4L2_VBI_UNSYNC: u32 = 1;
pub const V4L2_VBI_INTERLACED: u32 = 2;
pub const V4L2_VBI_ITU_525_F1_START: u32 = 1;
pub const V4L2_VBI_ITU_525_F2_START: u32 = 264;
pub const V4L2_VBI_ITU_625_F1_START: u32 = 1;
pub const V4L2_VBI_ITU_625_F2_START: u32 = 314;
pub const V4L2_SLICED_TELETEXT_B: u32 = 1;
pub const V4L2_SLICED_VPS: u32 = 1024;
pub const V4L2_SLICED_CAPTION_525: u32 = 4096;
pub const V4L2_SLICED_WSS_625: u32 = 16384;
pub const V4L2_SLICED_VBI_525: u32 = 4096;
pub const V4L2_SLICED_VBI_625: u32 = 17409;
pub const V4L2_MPEG_VBI_IVTV_TELETEXT_B: u32 = 1;
pub const V4L2_MPEG_VBI_IVTV_CAPTION_525: u32 = 4;
pub const V4L2_MPEG_VBI_IVTV_WSS_625: u32 = 5;
pub const V4L2_MPEG_VBI_IVTV_VPS: u32 = 7;
pub const V4L2_MPEG_VBI_IVTV_MAGIC0: &[u8; 5] = b"itv0\0";
pub const V4L2_MPEG_VBI_IVTV_MAGIC1: &[u8; 5] = b"ITV0\0";
pub const V4L2_EVENT_ALL: u32 = 0;
pub const V4L2_EVENT_VSYNC: u32 = 1;
pub const V4L2_EVENT_EOS: u32 = 2;
pub const V4L2_EVENT_CTRL: u32 = 3;
pub const V4L2_EVENT_FRAME_SYNC: u32 = 4;
pub const V4L2_EVENT_SOURCE_CHANGE: u32 = 5;
pub const V4L2_EVENT_MOTION_DET: u32 = 6;
pub const V4L2_EVENT_PRIVATE_START: u32 = 134217728;
pub const V4L2_EVENT_CTRL_CH_VALUE: u32 = 1;
pub const V4L2_EVENT_CTRL_CH_FLAGS: u32 = 2;
pub const V4L2_EVENT_CTRL_CH_RANGE: u32 = 4;
pub const V4L2_EVENT_SRC_CH_RESOLUTION: u32 = 1;
pub const V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ: u32 = 1;
pub const V4L2_EVENT_SUB_FL_SEND_INITIAL: u32 = 1;
pub const V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK: u32 = 2;
pub const V4L2_CHIP_MATCH_BRIDGE: u32 = 0;
pub const V4L2_CHIP_MATCH_SUBDEV: u32 = 4;
pub const V4L2_CHIP_MATCH_HOST: u32 = 0;
pub const V4L2_CHIP_MATCH_I2C_DRIVER: u32 = 1;
pub const V4L2_CHIP_MATCH_I2C_ADDR: u32 = 2;
pub const V4L2_CHIP_MATCH_AC97: u32 = 3;
pub const V4L2_CHIP_FL_READABLE: u32 = 1;
pub const V4L2_CHIP_FL_WRITABLE: u32 = 2;
pub const BASE_VIDIOC_PRIVATE: u32 = 192;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const IMP_ENC_AVC_PROFILE_IDC_BASELINE: u32 = 66;
pub const IMP_ENC_AVC_PROFILE_IDC_MAIN: u32 = 77;
pub const IMP_ENC_AVC_PROFILE_IDC_HIGH: u32 = 100;
pub const IMP_ENC_HEVC_PROFILE_IDC_MAIN: u32 = 1;
pub const IMP_IVS_MOVE_MAX_ROI_CNT: u32 = 52;
pub const IMP_IVS_DEFAULT_TIMEOUTMS: i32 = -1;
pub const IMP_LOG_OUT_STDOUT: u32 = 0;
pub const IMP_LOG_OUT_LOCAL_FILE: u32 = 1;
pub const IMP_LOG_OUT_SERVER: u32 = 2;
pub const IMP_LOG_OUT_DEFAULT: u32 = 0;
pub const IMP_LOG_OP_PID_SHIFT: u32 = 0;
pub const IMP_LOG_OP_USTIME_SHIFT: u32 = 1;
pub const IMP_LOG_OP_MODULE_SHIFT: u32 = 2;
pub const IMP_LOG_OP_FILE_SHIFT: u32 = 3;
pub const IMP_LOG_OP_FUNC_SHIFT: u32 = 4;
pub const IMP_LOG_OP_LINE_SHIFT: u32 = 5;
pub const IMP_LOG_OP_PID: u32 = 1;
pub const IMP_LOG_OP_USTIME: u32 = 2;
pub const IMP_LOG_OP_MODULE: u32 = 4;
pub const IMP_LOG_OP_FILE: u32 = 8;
pub const IMP_LOG_OP_FUNC: u32 = 16;
pub const IMP_LOG_OP_LINE: u32 = 32;
pub const IMP_LOG_OP_NONE: u32 = 0;
pub const IMP_LOG_OP_ALL: u32 = 63;
pub const IMP_LOG_OP_DEFAULT: u32 = 63;
pub const INVHANDLE: i32 = -1;
pub const DEVICE_ID_MAGIC: &[u8; 5] = b"53ef\0";
pub const DEVICE_ID_MAGIC_LEN: u32 = 4;
pub const DEVICE_ID_LEN: u32 = 32;
pub const MAX_INFO_LEN: u32 = 64;
pub const REINIT: i32 = -10;
pub const INIT_FAILED: i32 = -11;
pub const FAILED_GETHANDLE: i32 = -12;
pub const INVALID_PARA: i32 = -13;
pub const SET_PARA_FAILED: i32 = -14;
pub const FAILURE: i32 = -15;
pub const SET_DATALEN_ERR: i32 = -16;
pub const EXIT_ERR: i32 = -17;
pub const UNINIT: i32 = -18;
pub const FAILED_DESHANDLE: i32 = -19;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "< block"]
pub const IMPBlock_BLOCK: IMPBlock = 0;
#[doc = "< not block"]
pub const IMPBlock_NOBLOCK: IMPBlock = 1;
#[doc = " Audio stream blocking type"]
pub type IMPBlock = ::std::os::raw::c_uint;
#[doc = "< 8KHz sampling rate"]
pub const IMPAudioSampleRate_AUDIO_SAMPLE_RATE_8000: IMPAudioSampleRate = 8000;
#[doc = "< 16KHz sampling rate"]
pub const IMPAudioSampleRate_AUDIO_SAMPLE_RATE_16000: IMPAudioSampleRate = 16000;
#[doc = "< 24KHz sampling rate"]
pub const IMPAudioSampleRate_AUDIO_SAMPLE_RATE_24000: IMPAudioSampleRate = 24000;
#[doc = "< 32KHz sampling rate"]
pub const IMPAudioSampleRate_AUDIO_SAMPLE_RATE_32000: IMPAudioSampleRate = 32000;
#[doc = "< 44.1KHz sampling rate"]
pub const IMPAudioSampleRate_AUDIO_SAMPLE_RATE_44100: IMPAudioSampleRate = 44100;
#[doc = "< 48KHz sampling rate"]
pub const IMPAudioSampleRate_AUDIO_SAMPLE_RATE_48000: IMPAudioSampleRate = 48000;
#[doc = "< 96KHz sampling rate"]
pub const IMPAudioSampleRate_AUDIO_SAMPLE_RATE_96000: IMPAudioSampleRate = 96000;
#[doc = " Audio sampling rate definition."]
pub type IMPAudioSampleRate = ::std::os::raw::c_uint;
#[doc = "< 16bit sampling precision"]
pub const IMPAudioBitWidth_AUDIO_BIT_WIDTH_16: IMPAudioBitWidth = 16;
#[doc = " Audio sampling precision definition."]
pub type IMPAudioBitWidth = ::std::os::raw::c_uint;
#[doc = "< Single channel"]
pub const IMPAudioSoundMode_AUDIO_SOUND_MODE_MONO: IMPAudioSoundMode = 1;
#[doc = "< Double channel"]
pub const IMPAudioSoundMode_AUDIO_SOUND_MODE_STEREO: IMPAudioSoundMode = 2;
#[doc = " Audio channel mode definition."]
pub type IMPAudioSoundMode = ::std::os::raw::c_uint;
pub const IMPAudioPalyloadType_PT_PCM: IMPAudioPalyloadType = 0;
pub const IMPAudioPalyloadType_PT_G711A: IMPAudioPalyloadType = 1;
pub const IMPAudioPalyloadType_PT_G711U: IMPAudioPalyloadType = 2;
pub const IMPAudioPalyloadType_PT_G726: IMPAudioPalyloadType = 3;
pub const IMPAudioPalyloadType_PT_AEC: IMPAudioPalyloadType = 4;
pub const IMPAudioPalyloadType_PT_ADPCM: IMPAudioPalyloadType = 5;
pub const IMPAudioPalyloadType_PT_MAX: IMPAudioPalyloadType = 6;
#[doc = " Define audio payload type enumeration."]
pub type IMPAudioPalyloadType = ::std::os::raw::c_uint;
#[doc = "< Pack decoding"]
pub const IMPAudioDecMode_ADEC_MODE_PACK: IMPAudioDecMode = 0;
#[doc = "< Stream decoding"]
pub const IMPAudioDecMode_ADEC_MODE_STREAM: IMPAudioDecMode = 1;
#[doc = " Define the decoding method."]
pub type IMPAudioDecMode = ::std::os::raw::c_uint;
#[doc = " Audio input and output device attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioIOAttr {
    #[doc = "< Audio sampling rate"]
    pub samplerate: IMPAudioSampleRate,
    #[doc = "< Audio sampling precision"]
    pub bitwidth: IMPAudioBitWidth,
    #[doc = "< Audio channel mode"]
    pub soundmode: IMPAudioSoundMode,
    #[doc = "< Number of cached frames, range: [2, MAX_AUDIO_FRAME_NUM]"]
    pub frmNum: ::std::os::raw::c_int,
    #[doc = "< Number of sample points per frame"]
    pub numPerFrm: ::std::os::raw::c_int,
    #[doc = "< Number of channels supported"]
    pub chnCnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPAudioIOAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioIOAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioIOAttr>(),
        24usize,
        concat!("Size of: ", stringify!(IMPAudioIOAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioIOAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPAudioIOAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioIOAttr),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitwidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioIOAttr),
            "::",
            stringify!(bitwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).soundmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioIOAttr),
            "::",
            stringify!(soundmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frmNum) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioIOAttr),
            "::",
            stringify!(frmNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPerFrm) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioIOAttr),
            "::",
            stringify!(numPerFrm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chnCnt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioIOAttr),
            "::",
            stringify!(chnCnt)
        )
    );
}
#[doc = " Audio frame structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioFrame {
    #[doc = "< Audio sampling precision"]
    pub bitwidth: IMPAudioBitWidth,
    #[doc = "< Audio channel mode"]
    pub soundmode: IMPAudioSoundMode,
    #[doc = "< Audio frame data virtual address"]
    pub virAddr: *mut u32,
    #[doc = "< Audio frame data physical address"]
    pub phyAddr: u32,
    #[doc = "< Audio frame data time stamp"]
    pub timeStamp: i64,
    #[doc = "< Audio frame data serial number"]
    pub seq: ::std::os::raw::c_int,
    #[doc = "< Audio frame data length"]
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPAudioFrame() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioFrame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioFrame>(),
        40usize,
        concat!("Size of: ", stringify!(IMPAudioFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPAudioFrame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitwidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioFrame),
            "::",
            stringify!(bitwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).soundmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioFrame),
            "::",
            stringify!(soundmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virAddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioFrame),
            "::",
            stringify!(virAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phyAddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioFrame),
            "::",
            stringify!(phyAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioFrame),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioFrame),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioFrame),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Audio channel parameter structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioIChnParam {
    #[doc = "< Audio frame buffer depth"]
    pub usrFrmDepth: ::std::os::raw::c_int,
    #[doc = "< retain"]
    pub Rev: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPAudioIChnParam() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioIChnParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioIChnParam>(),
        8usize,
        concat!("Size of: ", stringify!(IMPAudioIChnParam))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioIChnParam>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPAudioIChnParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usrFrmDepth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioIChnParam),
            "::",
            stringify!(usrFrmDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioIChnParam),
            "::",
            stringify!(Rev)
        )
    );
}
#[doc = " Data cache state structure of audio output channel."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioOChnState {
    #[doc = "< The total number of cached output channel"]
    pub chnTotalNum: ::std::os::raw::c_int,
    #[doc = "< Free cache blocks"]
    pub chnFreeNum: ::std::os::raw::c_int,
    #[doc = "< The number of cache be used"]
    pub chnBusyNum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPAudioOChnState() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioOChnState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioOChnState>(),
        12usize,
        concat!("Size of: ", stringify!(IMPAudioOChnState))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioOChnState>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPAudioOChnState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chnTotalNum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioOChnState),
            "::",
            stringify!(chnTotalNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chnFreeNum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioOChnState),
            "::",
            stringify!(chnFreeNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chnBusyNum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioOChnState),
            "::",
            stringify!(chnBusyNum)
        )
    );
}
#[doc = " Define audio stream structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioStream {
    #[doc = "< Data stream pointer"]
    pub stream: *mut u8,
    #[doc = "< Data stream physical address"]
    pub phyAddr: u32,
    #[doc = "< Audio stream length"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< time stamp"]
    pub timeStamp: i64,
    #[doc = "< Audio stream serial number"]
    pub seq: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPAudioStream() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioStream>(),
        32usize,
        concat!("Size of: ", stringify!(IMPAudioStream))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioStream>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPAudioStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioStream),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phyAddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioStream),
            "::",
            stringify!(phyAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioStream),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioStream),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioStream),
            "::",
            stringify!(seq)
        )
    );
}
#[doc = " Define audio encoding channel attribute structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioEncChnAttr {
    #[doc = "< Audio payload data type"]
    pub type_: IMPAudioPalyloadType,
    #[doc = "<  buf size, in order to frame the unit, [2 ~ MAX_AUDIO_FRAME_NUM]"]
    pub bufSize: ::std::os::raw::c_int,
    #[doc = "< Protocol attribute pointer"]
    pub value: *mut u32,
}
#[test]
fn bindgen_test_layout_IMPAudioEncChnAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioEncChnAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioEncChnAttr>(),
        16usize,
        concat!("Size of: ", stringify!(IMPAudioEncChnAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioEncChnAttr>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPAudioEncChnAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncChnAttr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncChnAttr),
            "::",
            stringify!(bufSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncChnAttr),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Define the encoder attribute structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioEncEncoder {
    #[doc = "< Encoding protocol type"]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< Maximum code stream length"]
    pub maxFrmLen: ::std::os::raw::c_int,
    #[doc = "< encoder name"]
    pub name: [::std::os::raw::c_char; 16usize],
    pub openEncoder: ::std::option::Option<
        unsafe extern "C" fn(
            encoderAttr: *mut ::std::os::raw::c_void,
            encoder: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub encoderFrm: ::std::option::Option<
        unsafe extern "C" fn(
            encoder: *mut ::std::os::raw::c_void,
            data: *mut IMPAudioFrame,
            outbuf: *mut ::std::os::raw::c_uchar,
            outLen: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub closeEncoder: ::std::option::Option<
        unsafe extern "C" fn(encoder: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_IMPAudioEncEncoder() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioEncEncoder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioEncEncoder>(),
        48usize,
        concat!("Size of: ", stringify!(IMPAudioEncEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioEncEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPAudioEncEncoder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncEncoder),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxFrmLen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncEncoder),
            "::",
            stringify!(maxFrmLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncEncoder),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).openEncoder) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncEncoder),
            "::",
            stringify!(openEncoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoderFrm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncEncoder),
            "::",
            stringify!(encoderFrm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closeEncoder) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioEncEncoder),
            "::",
            stringify!(closeEncoder)
        )
    );
}
#[doc = " Define the decoded channel attribute structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioDecChnAttr {
    #[doc = "< Audio decoding protocol type"]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< Audio decoder cache size"]
    pub bufSize: ::std::os::raw::c_int,
    #[doc = "< Decoding mode"]
    pub mode: IMPAudioDecMode,
    #[doc = "< Specific protocol attribute pointer"]
    pub value: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_IMPAudioDecChnAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioDecChnAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioDecChnAttr>(),
        24usize,
        concat!("Size of: ", stringify!(IMPAudioDecChnAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioDecChnAttr>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPAudioDecChnAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecChnAttr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecChnAttr),
            "::",
            stringify!(bufSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecChnAttr),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecChnAttr),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Define decoder attribute structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioDecDecoder {
    #[doc = "< Audio decoding protocol type"]
    pub type_: IMPAudioPalyloadType,
    #[doc = "< Audio encoder name"]
    pub name: [::std::os::raw::c_char; 16usize],
    pub openDecoder: ::std::option::Option<
        unsafe extern "C" fn(
            decoderAttr: *mut ::std::os::raw::c_void,
            decoder: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub decodeFrm: ::std::option::Option<
        unsafe extern "C" fn(
            decoder: *mut ::std::os::raw::c_void,
            inbuf: *mut ::std::os::raw::c_uchar,
            inLen: ::std::os::raw::c_int,
            outbuf: *mut ::std::os::raw::c_ushort,
            outLen: *mut ::std::os::raw::c_int,
            chns: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub getFrmInfo: ::std::option::Option<
        unsafe extern "C" fn(
            decoder: *mut ::std::os::raw::c_void,
            info: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub closeDecoder: ::std::option::Option<
        unsafe extern "C" fn(decoder: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_IMPAudioDecDecoder() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioDecDecoder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioDecDecoder>(),
        56usize,
        concat!("Size of: ", stringify!(IMPAudioDecDecoder))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioDecDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPAudioDecDecoder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecDecoder),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecDecoder),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).openDecoder) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecDecoder),
            "::",
            stringify!(openDecoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decodeFrm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecDecoder),
            "::",
            stringify!(decodeFrm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getFrmInfo) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecDecoder),
            "::",
            stringify!(getFrmInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closeDecoder) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioDecDecoder),
            "::",
            stringify!(closeDecoder)
        )
    );
}
#[doc = " Define AGC gain structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPAudioAgcConfig {
    #[doc = "< Gain level, the value of [0, 31], this refers to the target volume level, the unit is dB, is negative value. The smaller the value, the greater the volume."]
    pub TargetLevelDbfs: ::std::os::raw::c_int,
    #[doc = "< Set the maximum gain value, [0, 90], 0 represents no gain, the greater the value, the higher the gain."]
    pub CompressionGaindB: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPAudioAgcConfig() {
    const UNINIT: ::std::mem::MaybeUninit<IMPAudioAgcConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPAudioAgcConfig>(),
        8usize,
        concat!("Size of: ", stringify!(IMPAudioAgcConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPAudioAgcConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPAudioAgcConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetLevelDbfs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioAgcConfig),
            "::",
            stringify!(TargetLevelDbfs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CompressionGaindB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPAudioAgcConfig),
            "::",
            stringify!(CompressionGaindB)
        )
    );
}
pub const Agc_mode_kAgcModeAdaptiveAnalog: Agc_mode = 1;
pub const Agc_mode_kAgcModeAdaptiveDigital: Agc_mode = 2;
pub const Agc_mode_kAgcModeFixedDigital: Agc_mode = 3;
pub type Agc_mode = ::std::os::raw::c_uint;
#[doc = "< Low level noise suppression"]
pub const Level_ns_NS_LOW: Level_ns = 0;
#[doc = "< Medium level noise suppression"]
pub const Level_ns_NS_MODERATE: Level_ns = 1;
#[doc = "< High level noise suppression"]
pub const Level_ns_NS_HIGH: Level_ns = 2;
#[doc = "< Maximum level noise suppression"]
pub const Level_ns_NS_VERYHIGH: Level_ns = 3;
#[doc = " Defines level of noise suppression."]
pub type Level_ns = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @fn int IMP_AI_SetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n Set audio input device attribute.\n\n @param[in] audioDevId Audio device number\n @param[in] attr Audio device attribute pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks Sample code\n @code\n int devID = 1;\n IMPAudioIOAttr attr;\n attr.samplerate = AUDIO_SAMPLE_RATE_8000;\n attr.bitwidth = AUDIO_BIT_WIDTH_16;\n attr.soundmode = AUDIO_SOUND_MODE_MONO;\n attr.frmNum = 20;\n attr.numPerFrm = 400;\n attr.chnCnt = 1;\n ret = IMP_AI_SetPubAttr(devID, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Set Audio in %d attr err: %d\\n\", devID, ret);\n\t\treturn ret;\n }\n @endcode\n\n @attention Need to be called before IMP_AI_Enable."]
    pub fn IMP_AI_SetPubAttr(
        audioDevId: ::std::os::raw::c_int,
        attr: *mut IMPAudioIOAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n Get the attribute of the audio input device\n\n @param[in] audioDevId Audio device number\n @param[out] attr Audio device attribute pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_GetPubAttr(
        audioDevId: ::std::os::raw::c_int,
        attr: *mut IMPAudioIOAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_Enable(int audioDevId)\n\n Enable audio input device.\n\n @param[in] audioDevId Audio device number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_Enable(audioDevId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_Disable(int audioDevId)\n\n Disable audio input device\n\n @param[in] audioDevId Audio device number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention It supports the use of IMP_AI_Enable. IMP_AI_Disable must be performed before putting the system in sleeping mode."]
    pub fn IMP_AI_Disable(audioDevId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableChn(int audioDevId, int aiChn)\n\n Enable audio input channel\n\n @param[in] audioDevId Audio device number\n @param[in] aiChn Audio input channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention Must first enable device."]
    pub fn IMP_AI_EnableChn(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableChn(int audioDevId, int aiChn)\n\n Disable audio input channel\n\n @param[in] audioDevId Audio device number\n @param[in] aiChn Audio input channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention It supports the use of IMP_AI_EnableChn."]
    pub fn IMP_AI_DisableChn(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_PollingFrame(int audioDevId, int aiChn, unsigned int timeout_ms)\n\n Polling audio stream cache.\n\n @param[in] audioDevId Audio device number\n @param[in] aiChn Audio input channel number\n @param[in] timeout_ms Polling timeout time.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention Use the interface before using IMP_AI_GetFrame, and when the interface is called successfully, then the audio data is ready, and you can use IMP_AI_GetFrame to get audio data."]
    pub fn IMP_AI_PollingFrame(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        timeout_ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetFrame(int audioDevId, int aiChn, IMPAudioFrame *frm, IMPBlock block)\n\n Get audio frame.\n\n @param[in] audioDevId Audio device number\n @param[in] aiChn Audio input channel number\n @param[out] frm Audio frame structure pointer.\n @param[in] block Blocking / non blocking identifier.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks Sample code\n @code\n IMPAudioFrame frm;\n // Get audio frame\n ret = IMP_AI_GetFrame(devID, chnID, &frm, BLOCK);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Get Frame Data error\\n\");\n\t\treturn ret;\n }\n\n fwrite(frm.virAddr, 1, frm.len, record_file); // use audio frame data\n\n // Release audio frame\n ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio release frame data error\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention no."]
    pub fn IMP_AI_GetFrame(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        frm: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_ReleaseFrame(int audioDevId, int aiChn, IMPAudioFrame *frm)\n\n Release audio frame\n\n @param[in] audioDevId Audio device number\n @param[in] aiChn Audio input channel number\n @param[in] frm Audio frame structure pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention It supports the use of IMP_AI_GetFrame."]
    pub fn IMP_AI_ReleaseFrame(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        frm: *mut IMPAudioFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetChnParam(int audioDevId, int aiChn, IMPAudioIChnParam *chnParam)\n\n Set audio input channel parameters.\n\n @param[in] audioDevId Audio device number\n @param[in] aiChn audio input channel number\n @param[in] chnParam audio frame structure pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks sample code\n @code\n int chnID = 0;\n IMPAudioIChnParam chnParam;\n chnParam.usrFrmDepth = 20;\n ret = IMP_AI_SetChnParam(devID, chnID, &chnParam);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"set ai %d channel %d attr err: %d\\n\", devID, chnID, ret);\n\t\treturn ret;\n }\n @endcode\n\n @attention Supporting the use of IMP_AI_EnableChn."]
    pub fn IMP_AI_SetChnParam(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        chnParam: *mut IMPAudioIChnParam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetChnParam(int audioDevId, int aiChn, IMPAudioIChnParam *chnParam)\n\n Set audio input channel parameters\n\n @param[in] audioDevId audio device number\n @param[in] aiChn audio input channel number\n @param[out] chnParam audio channel parameters\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_GetChnParam(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        chnParam: *mut IMPAudioIChnParam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAec(int aiDevId, int aiChn, int aoDevId, int aoChn)\n\n Enable audio echo cancellation feature of the specified audio input and audio output.\n\n @param[in] aiDevId Need to perform audio echo cancellation of the audio input device number.\n @param[in] aiChn Need to perform audio echo cancellation of the audio input channel number.\n @param[in] aoDevId Need to perform audio echo cancellation of the audio output device number.\n @param[in] aoChn Need to perform audio echo cancellation of the audio output channel number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks The Audio echo cancellation for different devices and different packages will have different sound effects.\n @remarks Adaptive support is not available in Audio Echo Cancellation (the AEC is not automatically configured), so for different devices there will be different echo cancellation parameters, \\n\n @remarks Only use the functional effect is not really good.\n @remarks The parameter file of the Audio echo cancellation is located in the /etc/webrtc_profile.ini configuration file. \\n\n\n @remarks The profile format is as follows (Main need to debug the three parameters): \\n\n @remarks [Set_Far_Frame] \\n\n @remarks Frame_V=0.3 \\n\n @remarks [Set_Near_Frame] \\n\n @remarks Frame_V=0.1 \\n\n @remarks delay_ms=150 \\n\n\n @remarks [Set_Far_Frame] represents the remote(far-end) parameter, the SPK represents the playback data parameters. \\n\n @remarks Fram_V represents audio amplitude scaling, the playback data can be adjusted by adjusting these parameters (this is used only for echo cancellation). \\n\n @remarks [Set_Near_Frame] represents the proximal(near-end) parameter, the MIC represents record data parameters. \\n\n @remarks Fram_V represents the audio amplitude ratio, the adjustment of these parameters can adjust the amplitude of the recording data (this is only used for echo cancellation). \\n\n @remarks Delay_ms, because of the delay between software and hardware, and the position between the SPK and MIC(they are placed at a certain distance), the SPK playback data will be processed by the MIC again. So, there will be some delay because the SPK data will have some impact on the MIC data. \\n\n @remarks This time represents the time difference of the playback data in data recording. (delay to assure that there won't be any echo at all). \\n\n\n @attention In fact, the interface will only check for aiDevId and aiChn, but it is better to enabele these two channels at the same time and then call the current one. \\n\n when the audio input channel is closed, the Audio Echo Cancellation feature also is turned off. In case of using it again, you will have to turn it on."]
    pub fn IMP_AI_EnableAec(
        aiDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        aoDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn  int IMP_AI_Set_WebrtcProfileIni_Path(char *path)\nSet AEC profile \" webrtc_profile.ini\" pass.\n\npath parameter:It is used to set the path of the configuration file.\n\nFor example, the user wants to place the configuration file in the /system directory:                     IMP_AI_Set_WebrtcProfileIni_Path(\"/system\");\n\nThis function must be in   IMP_AI_EnableAec(int aiDevId, int aiChn, int aoDevId, int aoChn)before used。\n\nreturn value 0"]
    pub fn IMP_AI_Set_WebrtcProfileIni_Path(
        path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAec(int aiDevId, int aiChn)\n\n Disable audio echo cancellation feature.\n\n @param[in] aiDevId Audio input device number\n @param[in] aiChn audio input channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_DisableAec(
        aiDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableNs(IMPAudioIOAttr *attr, int mode)\n\n Enable specified audio input noise suppression.\n\n @param[in] attr Noise suppression is required for the audio attribute.\n @param[in] mode Noise suppression level 0 ~ 3, see Level_ns.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks The mode parameter of noise suppression represents the noise suppression level (range [0 ~ 3]), the higher the level, the cleaner the noise suppression.\n @remarks However, The cleaner the noise is, more details of the sound will be lost, here we have a contradiction so we need to make tradeoff while processing the noise suppression.\n\n @attention Audio echo cancellation contains the noise suppression function, if the audio echo cancellation is enabled, it is not required to enable the noise suppression."]
    pub fn IMP_AI_EnableNs(
        attr: *mut IMPAudioIOAttr,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableNs(void)\n\n Disable noise suppression\n\n @param no.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_DisableNs() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetAgcMode(int mode);\n\n Set the agc working mode.\n\n @param[in] mode agc working mode selection, see Agc_mode definition.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks It should be noted that the agcmode setting needs to be enabled before the agc function.\n"]
    pub fn IMP_AI_SetAgcMode(mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAgc(IMPAudioIOAttr *attr, IMPAudioAgcConfig agcConfig)\n\n Enable automatic gain of audio input.\n\n @param[in] attr Requires automatic gain of the audio attribute.\n @param[in] agcConfig Automatic gain parameter configuration, configuration magnification.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks Note the configuration of the AGC. agcConfig amplification's main parameters have their own configuration, check the specific gain IMPAudioAgcConfig instructions.\n @remarks Note that AGC can gain sound amplification, but if the gain parameter is not appropriate, it will lead to broken noise, please adjust carefully the parameters.\n\n @attention Audio echo cancellation contains the AGC function, which means it is not required to perform automatic gain if the echo cancellation is enabled."]
    pub fn IMP_AI_EnableAgc(
        attr: *mut IMPAudioIOAttr,
        agcConfig: IMPAudioAgcConfig,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAgc(void)\n\n Disable AI automatic gain feature.\n\n @param no.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_DisableAgc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableAgc(IMPAudioIOAttr *attr, IMPAudioAgcConfig agcConfig)\n\n Enable audio output automatic gain feature.\n\n @param[in] attr need automatic gain of the audio attribute.\n @param[in] agcConfig automatic gain parameter configuration, configuration magnification.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks agcConfig amplification's main parameters have their own configuration, check the specific gain IMPAudioAgcConfig instructions.\n @remarks Note that AGC can gain sound amplification, but if the gain parameter is not appropriate, it will lead to broken noise, please adjust carefully the parameters.\n\n @attention Audio echo cancellation contains the AGC function, which means it is not required to perform automatic gain if the echo cancellation is enabled."]
    pub fn IMP_AO_EnableAgc(
        attr: *mut IMPAudioIOAttr,
        agcConfig: IMPAudioAgcConfig,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableAgc(void)\n\n Disable AO automatic gain feature.\n\n @param no.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_DisableAgc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableHpf(IMPAudioIOAttr *attr)\n\n Enable audio input for high pass filtering.\n\n @param[in] attr need high pass filtering of audio attribute.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention Audio echo cancellation contains the HPF function, if Audio Echo Cancellation is enabled, so HPF will be automatically enabled."]
    pub fn IMP_AI_EnableHpf(attr: *mut IMPAudioIOAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetHpfCoFrequency(int cofrequency)\n\n Set the cut-off frequency of high pass filtering for audio input.\n\n @param[in] cofrequency the cut-off frequency of high pass filter.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention while enabling the high-pass filter for audio input,setting the cut-off frequency of the high-pass filter first."]
    pub fn IMP_AI_SetHpfCoFrequency(cofrequency: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableHpf(void)\n\n Disable AI high pass filtering function.\n\n @param no.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_DisableHpf() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableHpf(IMPAudioIOAttr *attr)\n\n Enable audio output for high pass filtering.\n\n @param[in] attr need high pass filtering of audio attribute.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention Audio echo cancellation contains the HPF function, if audio echo cancellation is enabled, so you do not need to enable HPF."]
    pub fn IMP_AO_EnableHpf(attr: *mut IMPAudioIOAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetHpfCoFrequency(int cofrequency)\n\n Set the cut-off frequency of high pass filtering for audio output.\n\n @param[in] cofrequency the cut-off frequency of high pass filter.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention while enabling the high-pass filter for audio output,setting the cut-off frequency of the high-pass filter first."]
    pub fn IMP_AO_SetHpfCoFrequency(cofrequency: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableHpf(void)\n\n Disable AO high pass filtering function.\n\n @param no.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_DisableHpf() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n Set audio input and output device attribute.\n\n @param[in] audioDevId audio device number\n @param[in] attr audio output device attribute pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_SetPubAttr(
        audioDevId: ::std::os::raw::c_int,
        attr: *mut IMPAudioIOAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetPubAttr(int audioDevId, IMPAudioIOAttr *attr)\n\n Get audio input and output device attribute.\n\n @param[in] audioDevId audio device number\n @param[out] attr audio output device attribute pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_GetPubAttr(
        audioDevId: ::std::os::raw::c_int,
        attr: *mut IMPAudioIOAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Enable(int audioDevId)\n\n Enable audio output device\n\n @param[in] audioDevId audio device number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention The IMP_AO_SetPubAttr. must be called before"]
    pub fn IMP_AO_Enable(audioDevId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Disable(int audioDevId)\n\n Disable audio output device\n\n @param[in] audioDevId audio device number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_Disable(audioDevId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_EnableChn(int audioDevId, int aoChn)\n\n Enable audio output channel\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_EnableChn(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_DisableChn(int audioDevId, int aoChn)\n\n Disable audio output channel\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_DisableChn(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SendFrame(int audioDevId, int aoChn, IMPAudioFrame *data, IMPBlock block)\n\n Send audio output frame.\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n @param[in] data audio frame sturcture pointer\n @param[in] block Blocking / non blocking identifier.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks sample code\n @code\n while(1) {\n\t\tsize = fread(buf, 1, IMP_AUDIO_BUF_SIZE, play_file);\n\t\tif(size < IMP_AUDIO_BUF_SIZE)\n\t\t\tbreak;\n\n\t\tIMPAudioFrame frm;\n\t\tfrm.virAddr = (uint32_t *)buf;\n\t\tfrm.len = size;\n\t\tret = IMP_AO_SendFrame(devID, chnID, &frm, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"send Frame Data error\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention no."]
    pub fn IMP_AO_SendFrame(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
        data: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_PauseChn(int audioDevId, int aoChn)\n\n Pause audio output channel\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_PauseChn(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_ResumeChn(int audioDevId, int aoChn)\n\n Resume audio output channel\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_ResumeChn(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_ClearChnBuf(int audioDevId, int aoChn)\n\n Clear the current audio data cache in the audio output channel.\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_ClearChnBuf(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_QueryChnStat(int audioDevId, int aoChn, IMPAudioOChnState *status)\n\n Query the current audio data cache status in the audio output channel.\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n @param[out] status Cache state structure pointer.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_QueryChnStat(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
        status: *mut IMPAudioOChnState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_CreateChn(int aeChn, IMPAudioEncChnAttr *attr)\n\n Create audio encode channel.\n\n @param[in] aeChn channel number\n @param[in] attr Audio encode channel attribute pointer.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks sample code\n @code\n int AeChn = 0;\n IMPAudioEncChnAttr attr;\n attr.type = PT_G711A;\n attr.bufSize = 20;\n ret = IMP_AENC_CreateChn(AeChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio encode create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention The Current SDK supports PT_G711A, PT_G711U and PT_G726 encoding. \\n\n So the use of SDK encoding, only needs attr.type = PT_G711A. \\n\n How to use a custom encoder? You need to register the encoder, the sample code is in the registration interface instructions."]
    pub fn IMP_AENC_CreateChn(
        aeChn: ::std::os::raw::c_int,
        attr: *mut IMPAudioEncChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_DestroyChn(int aeChn)\n\n Destory audio encode channel\n\n @param[in] aeChn channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention Supporting the use of IMP_AENC_CreateChn."]
    pub fn IMP_AENC_DestroyChn(aeChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_SendFrame(int aeChn, IMPAudioFrame *frm)\n\n Send audio encoding audio frame\n\n @param[in] aeChn channel number\n @param[in] frm Audio frame structure pointer.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks sample code\n @code\n while(1) {\n\t\t// Read a frame of data\n\t\tret = fread(buf_pcm, 1, IMP_AUDIO_BUF_SIZE, file_pcm);\n\t\tif(ret < IMP_AUDIO_BUF_SIZE)\n\t\t\tbreak;\n\n\t\t// encode\n\t\tIMPAudioFrame frm;\n\t\tfrm.virAddr = (uint32_t *)buf_pcm;\n\t\tfrm.len = ret;\n\t\tret = IMP_AENC_SendFrame(AeChn, &frm);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode send frame failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// Get encode stream\n\t\tIMPAudioStream stream;\n\t\tret = IMP_AENC_GetStream(AeChn, &stream, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode get stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// Use encode stream\n\t\tfwrite(stream.stream, 1, stream.len, file_g711);\n\n\t\t// Release encode stream\n\t\tret = IMP_AENC_ReleaseStream(AeChn, &stream);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode release stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention no."]
    pub fn IMP_AENC_SendFrame(
        aeChn: ::std::os::raw::c_int,
        frm: *mut IMPAudioFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_PollingStream(int AeChn, unsigned int timeout_ms)\n\n Polling encoded audio stream cache.\n\n @param[in] AeChn Audio encoding input channel number.\n @param[in] timeout_ms Polling timeout time\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention The current interface is used before using IMP_AENC_GetStream. After calling successfully the current interface, we will have the audio encoding data ready then you can use the IMP_AENC_GetStream to get the encoded data."]
    pub fn IMP_AENC_PollingStream(
        AeChn: ::std::os::raw::c_int,
        timeout_ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_GetStream(int aeChn, IMPAudioStream *stream ,IMPBlock block)\n\n Get the encoded stream.\n\n @param[in] aeChn channel number\n @param[in] stream Get audio encoding\n @param[in] block Blocking / non blocking identifier.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks see the IMP_AENC_SendFrame function description for deeper understanding.\n\n @attention no."]
    pub fn IMP_AENC_GetStream(
        aeChn: ::std::os::raw::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_ReleaseStream(int aeChn,IMPAudioStream *stream)\n\n Releases the stream from the audio encoding channel.\n\n @param[in] aeChn channel number\n @param[in] stream Get audio stream pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks see the IMP_AENC_SendFrame function description.\n\n @attention no."]
    pub fn IMP_AENC_ReleaseStream(
        aeChn: ::std::os::raw::c_int,
        stream: *mut IMPAudioStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_RegisterEncoder(int *handle, IMPAudioEncEncoder *encoder)\n\n Register encoder\n\n @param[in] ps32handle register handle\n @param[in] encoder Encoder attribute structure.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks sample code\n @code\n int handle_g711a = 0;\n IMPAudioEncEncoder my_encoder;\n my_encoder.maxFrmLen = 1024;\n sprintf(my_encoder.name, \"%s\", \"MY_G711A\");\n my_encoder.openEncoder = NULL; // Encoder callback function\n my_encoder.encoderFrm = MY_G711A_Encode_Frm; // Encoder callback function\n my_encoder.closeEncoder = NULL; // Encoder callback function\n\n ret = IMP_AENC_RegisterEncoder(&handle_g711a, &my_encoder);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"IMP_AENC_RegisterEncoder failed\\n\");\n\t\treturn ret;\n }\n\n // use encoder\n int AeChn = 0;\n IMPAudioEncChnAttr attr;\n attr.type = handle_g711a; // The encoder type is equal to the value of the handle_g711a returned by the successfully registered.\n attr.bufSize = 20;\n ret = IMP_AENC_CreateChn(AeChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio encode create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention After registration, the use of the method and the use of SDK in the encoder are all the same. (After registration, clients' methods and SDK prebuilt functions are considered as the SDK functions, that means the clients can change the content of the SDK as they wish)"]
    pub fn IMP_AENC_RegisterEncoder(
        handle: *mut ::std::os::raw::c_int,
        encoder: *mut IMPAudioEncEncoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AENC_UnRegisterEncoder(int *handle)\n\n Release encoder\n\n @param[in] ps32handle Register handle (the handle obtained at the time of registration of the encoder).\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AENC_UnRegisterEncoder(handle: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_CreateChn(int adChn, IMPAudioDecChnAttr *attr)\n\n Create audio decode channel\n\n @param[in] adChn channel number\n @param[in] attr Channel attribute pointer.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks sample code\n @code\n int adChn = 0;\n IMPAudioDecChnAttr attr;\n attr.type = PT_G711A;\n attr.bufSize = 20;\n attr.mode = ADEC_MODE_PACK;\n ret = IMP_ADEC_CreateChn(adChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio decoder create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention no."]
    pub fn IMP_ADEC_CreateChn(
        adChn: ::std::os::raw::c_int,
        attr: *mut IMPAudioDecChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_DestroyChn(int adChn)\n\n Destory audio decoding channel\n\n @param[in] adChn channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_ADEC_DestroyChn(adChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_SendStream(int adChn, IMPAudioStream *stream, IMPBlock block)\n\n Send audio stream to audio decoding channel.\n\n @param[in] adChn channel number\n @param[in] stream audio stream\n @param[in] block Blocking / non blocking identifier.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks sample code\n @code\n while(1) {\n\t\t// Get the data that needs to be decoded\n\t\tret = fread(buf_g711, 1, IMP_AUDIO_BUF_SIZE/2, file_g711);\n\t\tif(ret < IMP_AUDIO_BUF_SIZE/2)\n\t\t\tbreak;\n\n\t\t// Send decoding stream\n\t\tIMPAudioStream stream_in;\n\t\tstream_in.stream = (uint8_t *)buf_g711;\n\t\tstream_in.len = ret;\n\t\tret = IMP_ADEC_SendStream(adChn, &stream_in, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio encode send frame failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// Get decoded data\n\t\tIMPAudioStream stream_out;\n\t\tret = IMP_ADEC_GetStream(adChn, &stream_out, BLOCK);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio decoder get stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t// Use decoded data\n\t\tfwrite(stream_out.stream, 1, stream_out.len, file_pcm);\n\n\t\t// Release decoded data\n\t\tret = IMP_ADEC_ReleaseStream(adChn, &stream_out);\n\t\tif(ret != 0) {\n\t\t\tIMP_LOG_ERR(TAG, \"imp audio decoder release stream failed\\n\");\n\t\t\treturn ret;\n\t\t}\n }\n @endcode\n\n @attention no."]
    pub fn IMP_ADEC_SendStream(
        adChn: ::std::os::raw::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_PollingStream(int AdChn, unsigned int timeout_ms)\n\n Polling decode audio stream cache.\n\n @param[in] AdChn audio decode input channel number\n @param[in] timeout_ms polling timeout time\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention The current interface is used before using IMP_ADEC_GetStream. After calling successfully the current interface, we will have the audio encoding data ready then you can use the IMP_ADEC_GetStream to get the encoded data."]
    pub fn IMP_ADEC_PollingStream(
        AdChn: ::std::os::raw::c_int,
        timeout_ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_GetStream(int adChn, IMPAudioStream *stream ,IMPBlock block)\n\n Get the decoded stream.\n\n @param[in] adChn channel number\n @param[in] stream Get decoded stream\n @param[in] block Blocking / non blocking identifier.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks See the IMP_ADEC_SendFrame function description for further instructions.\n\n @attention no."]
    pub fn IMP_ADEC_GetStream(
        adChn: ::std::os::raw::c_int,
        stream: *mut IMPAudioStream,
        block: IMPBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_ReleaseStream(int adChn,IMPAudioStream *stream)\n\n Release of the stream from the audio decoding channel.\n\n @param[in] adChn channel number\n @param[in] stream audio stream pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks See the IMP_ADEC_SendFrame function description.\n\n @attention no."]
    pub fn IMP_ADEC_ReleaseStream(
        adChn: ::std::os::raw::c_int,
        stream: *mut IMPAudioStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_ClearChnBuf(int adChn)\n\n Clears the current audio data cache in the audio decode channel.\n\n @param[in] adChn channel number\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_ADEC_ClearChnBuf(adChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_RegisterDecoder(int *handle, IMPAudioDecDecoder *decoder)\n\n Register decoder\n\n @param[in] ps32handle register handle\n @param[in] decoder Decoder attributes structure.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks sample code\n @code\n int handle_g711a = 0;\n IMPAudioDecDecoder my_decoder;\n sprintf(my_decoder.name, \"%s\", \"MY_G711A\");\n my_decoder.openDecoder = NULL; // Decoder callback function\n my_decoder.decodeFrm = MY_G711A_Decode_Frm; // Decoder callback function\n my_decoder.getFrmInfo = NULL; // Decoder callback function\n my_decoder.closeDecoder = NULL; // Decoder callback function\n\n // Register decoder\n ret = IMP_ADEC_RegisterDecoder(&handle_g711a, &my_decoder);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"IMP_ADEC_RegisterDecoder failed\\n\");\n\t\treturn ret;\n }\n\n // use decoder\n int adChn = 0;\n IMPAudioDecChnAttr attr;\n attr.type = handle_g711a; // The encoder type is equal to the value of the handle_g711a returned by the successfully registered.\n attr.bufSize = 20;\n attr.mode = ADEC_MODE_PACK;\n // create decode channel\n ret = IMP_ADEC_CreateChn(adChn, &attr);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"imp audio decoder create channel failed\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention After registration, the use of the method as well as the use of SDK comes with an decoder.\n @attention After registration, the use of the method and the use of SDK in the decoder are all the same. (After registration, clients' methods and SDK prebuilt functions are considered as the SDK functions, that means the clients can change the content of the SDK as they wish)"]
    pub fn IMP_ADEC_RegisterDecoder(
        handle: *mut ::std::os::raw::c_int,
        decoder: *mut IMPAudioDecDecoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ADEC_UnRegisterDecoder(int *handle)\n\n Unregister Decoder\n\n @param[in] ps32handle Register handle (the handle obtained at the time of registration of the decoder).\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_ADEC_UnRegisterDecoder(handle: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ACODEC configuration.\n/\n/**\n @fn int IMP_AI_SetVol(int audioDevId, int aiChn, int aiVol)\n\n Set audio input volume.\n\n @param[in] aiDevId audio input device number\n @param[in] aiChn audio input channel number\n @param[in] aiVol audio input volume\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks volume in the range of [-30 ~ 120]. - 30 represents mute, 120 is to amplify the sound of to 30dB, step 0.5dB.\n @remarks 60 is to set the volume to a critical point. In this case, the software does not increase or decrease the volume, when the volume value is less than 60, for each drop of 1, the volume is decreased by 0.5dB; when the volume value is greater than 60, for each rise of 1, the volume is increased by 0.5dB.\n\n sample code\n @code\n int volume = 60;\n ret = IMP_AI_SetVol(devID, chnID, volume);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Record set volume failed\\n\");\n\t\treturn ret;\n }\n @endcode\n @attention If the input of the aiVol exceeds the range of [-30 ~ 120]. when it is less than -30 it will take -30 as value, more than 120 it will be considered as 120."]
    pub fn IMP_AI_SetVol(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        aiVol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetVol(int audioDevId, int aiChn, int *vol)\n\n Get the volume of the audio input.\n\n @param[in] aiDevId Audio input device number\n @param[in] aiChn Audio input channel number\n @param[out] vol audio input volume\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_GetVol(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        vol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetVolMute(int audioDevId, int aiChn, int mute)\n\n Set audio input mute.\n\n @param[in] aiDevId Audio input device number\n @param[in] aiChn Audio input channel number\n @param[out] mute Audio input mute flag, mute = 0: off mute, mute = 1: on mute.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks By calling the interface, it can be muted immediately.\n\n @attention no."]
    pub fn IMP_AI_SetVolMute(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        mute: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetVol(int audioDevId, int aoChn, int aoVol)\n\n Set audio output channel volume.\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n @param[in] aoVol audio output volume\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks volume in the range of [-30 ~ 120]. - 30 represents mute, 120 is to amplify the sound of to 30dB, step 0.5dB.\n @remarks 60 is to set the volume to a critical point. In this case, the software does not increase or decrease the volume, when the volume value is less than 60, for each drop of 1, the volume is decreased by 0.5dB; when the volume value is greater than 60, for each rise of 1, the volume is increased by 0.5dB.\n\n @attention If the input of the aiVol exceeds the range of [-30 ~ 120], when it is less than -30 it will take -30 as value , more than 120 it will be 120."]
    pub fn IMP_AO_SetVol(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
        aoVol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetVol(int audioDevId, int aoChn, int *vol)\n\n Get audio output channel volume.\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n @param[out] aoVol audio output volume\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_GetVol(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
        vol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetVolMute(int audioDevId, int aoChn, int mute)\n\n Set audio output mute\n\n @param[in] audioDevId audio device number\n @param[in] aoChn audio output channel number\n @param[out] mute Audio output mute flag, mute = 0: off mute, mute = 1: on mute.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks By calling the interface, it can be muted immediately.\n\n @attention no."]
    pub fn IMP_AO_SetVolMute(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
        mute: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetGain(int audioDevId, int aiChn, int aiGain)\n\n Set audio input gain.\n\n @param[in] audioDevId Audio input device number\n @param[in] aiChn Audio input channel number\n @param[out] aiGain Audio input gain, range [0 ~ 31], correspond to [-18dB ~ 28.5dB], step is 1.5dB.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention aiGain range of [0 ~ 31], if the input value is less than 0, then the value of aiGain will be set to 0 if the value is greater than 31, the value of aiGain will be set to 31\n"]
    pub fn IMP_AI_SetGain(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        aiGain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetGain(int audioDevId, int aiChn, int *aiGain)\n\n Get AI gain value\n\n @param[in] audioDevId Audio input device number\n @param[in] aiChn Audio input channel number\n @param[out] aiGain audio input gain\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_GetGain(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        aiGain: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_SetAlcGain(int audioDevId, int aiChn, int aiPgaGain)\n\n Set AI alc gain value\n\n @param[in] audioDevId audioDevId Audio input device number.\n @param[in] aiChn aiChn Audio input channel number\n @param[in] aiPgaGain Audio input gain, range [0 ~ 7],correspond to [-13.5dB, +28.5dB], step is 6dB.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention aiGain range of [0 ~ 7], if the input value is less than 0, then the value of aiGain will be set to 0 if the value is greater than 7, the value of aiGain will be set to 7\n"]
    pub fn IMP_AI_SetAlcGain(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        aiPgaGain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetAlcGain(int audioDevId, int aiChn, int *aiPgaGain)\n\n Get AI alc gain value\n\n @param[in] audioDevId audioDevId Audio input device number.\n @param[in] audioDevId audioDevId Audio input device number\n @param[out] aiPgaGain audio input gain\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AI_GetAlcGain(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        aiPgaGain: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_SetGain(int audioDevId, int aoChn, int aoGain)\n\n Set audio output gain.\n\n @param[in] audioDevId Audio output device number\n @param[in] aoChn audio output channel number\n @param[out] aoGain Audio output gain, range [0 ~ 0x1f], correspond to [-39dB ~ 6dB], step is 1.5dB.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention aoGain range of [0 ~ 31], if the input value is less than 0, then the value of aoGain will be set to 0.\\n\n aoGain if the value is greater than 31, the value of aiGain will be set to 31\n"]
    pub fn IMP_AO_SetGain(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
        aoGain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_GetGain(int audioDevId, int aoChn, int *aoGain)\n\n Get audio output gain.\n\n @param[in] audioDevId audio output device number.\n @param[in] aoChn audio output channel number.\n @param[out] aoGain audio output gain.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_AO_GetGain(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
        aoGain: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Soft_Mute(int audioDevId, int aoChn)\n\n Output soft mute control.\n\n @param[in] audioDevId Audio output device number.\n @param[in] aoChn Audio input channel number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks when this interface is called, it wil not be directly in silence mode from normal playback state. It will slow down gradually, until it reaches the silence mode.\n\n @attention no."]
    pub fn IMP_AO_Soft_Mute(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_Soft_UNMute(int audioDevId, int aoChn)\n\n Output soft unmute control.\n\n @param[in] audioDevId Audio output device number.\n @param[in] aoChn Audio input channel number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks when this interface is called, it will not directly restore the current volume. It will gradually increase the volume from silence mode until the volume reaches a set of good volume.\n\n @attention no."]
    pub fn IMP_AO_Soft_UNMute(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_GetFrameAndRef(int audioDevId, int aiChn, IMPAudioFrame *frm, IMPAudioFrame *ref, IMPBlock block)\n\n Get audio frame and output reference frame.\n\n @param[in] audioDevId audio device number.\n @param[in] aiChn audio input channel number.\n @param[out] frm audio frame structure pointer.\n @param[out] ref reference frame structure pointer.\n @param[in] block block and non-block identitifier.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks Sample code\n @code\n IMPAudioFrame frm;\n IMPAudioFrame ref;\n // Get audio frame and output reference frame\n ret = IMP_AI_GetFrameAndRef(devID, chnID, &frm, &ref, BLOCK);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio Get Frame Data error\\n\");\n\t\treturn ret;\n }\n\n fwrite(frm.virAddr, 1, frm.len, record_file); // Use audio frame data\n fwrite(ref.virAddr, 1, ref.len, ref_file); // Use audio reference frame\n\n // Release audio frame\n ret = IMP_AI_ReleaseFrame(devID, chnID, &frm);\n if(ret != 0) {\n\t\tIMP_LOG_ERR(TAG, \"Audio release frame data error\\n\");\n\t\treturn ret;\n }\n @endcode\n\n @attention no."]
    pub fn IMP_AI_GetFrameAndRef(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        frm: *mut IMPAudioFrame,
        ref_: *mut IMPAudioFrame,
        block: IMPBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_EnableAecRefFrame(int audioDevId, int aiChn, int audioAoDevId, int aoChn)\n\n Open access reference frame.\n\n @param[in] audioDevId audio device number.\n @param[in] aiChn audio input channel number.\n @param[in] audioAoDevId audio output device number.\n @param[in] aoChn audio output channel number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks Use this current interface before using IMP_AI_GetFrameAndRef.\n @attention no."]
    pub fn IMP_AI_EnableAecRefFrame(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        audioAoDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AI_DisableAecRefFrame(int audioDevId, int aiChn, int audioAoDevId, int aoChn)\n\n Close access to the reference frame.\n\n @param[in] audioDevId audio device number.\n @param[in] aiChn audio input channel number.\n @param[in] audioAoDevId audio output device number.\n @param[in] aoChn audio output channel number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n @attention no."]
    pub fn IMP_AI_DisableAecRefFrame(
        audioDevId: ::std::os::raw::c_int,
        aiChn: ::std::os::raw::c_int,
        audioAoDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_CacheSwitch(int audioDevId, int aoChn, int cache_en)\n close audio play cache\n @param[in] audioDevId audio device number.\n @param[in] aoChn audio output channel number.\n @param[in] cache_en switch of control cache.\n\n @retval 0 success\n @retval non-0 failure.\n\n @remarks no\n @attention no."]
    pub fn IMP_AO_CacheSwitch(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
        cache_en: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_AO_FlushChnBuf(int audioDevId, int aoChn);\n Wait for last audio data to play.\n @param[in] audioDevId audio device number.\n @param[in] aoChn audio output channel number.\n\n @retval 0 success\n @retval non-0 failure.\n\n @remarks no\n @attention no."]
    pub fn IMP_AO_FlushChnBuf(
        audioDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = 0;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = 0;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_edid {
    pub pad: __u32,
    pub start_block: __u32,
    pub blocks: __u32,
    pub reserved: [__u32; 5usize],
    pub edid: *mut __u8,
}
#[test]
fn bindgen_test_layout_v4l2_edid() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_edid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_edid>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_edid))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_edid>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_edid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_block) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(start_block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_edid),
            "::",
            stringify!(edid)
        )
    );
}
pub const v4l2_power_line_frequency_V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:
    v4l2_power_line_frequency = 0;
pub const v4l2_power_line_frequency_V4L2_CID_POWER_LINE_FREQUENCY_50HZ: v4l2_power_line_frequency =
    1;
pub const v4l2_power_line_frequency_V4L2_CID_POWER_LINE_FREQUENCY_60HZ: v4l2_power_line_frequency =
    2;
pub const v4l2_power_line_frequency_V4L2_CID_POWER_LINE_FREQUENCY_AUTO: v4l2_power_line_frequency =
    3;
pub type v4l2_power_line_frequency = ::std::os::raw::c_uint;
pub const v4l2_colorfx_V4L2_COLORFX_NONE: v4l2_colorfx = 0;
pub const v4l2_colorfx_V4L2_COLORFX_BW: v4l2_colorfx = 1;
pub const v4l2_colorfx_V4L2_COLORFX_SEPIA: v4l2_colorfx = 2;
pub const v4l2_colorfx_V4L2_COLORFX_NEGATIVE: v4l2_colorfx = 3;
pub const v4l2_colorfx_V4L2_COLORFX_EMBOSS: v4l2_colorfx = 4;
pub const v4l2_colorfx_V4L2_COLORFX_SKETCH: v4l2_colorfx = 5;
pub const v4l2_colorfx_V4L2_COLORFX_SKY_BLUE: v4l2_colorfx = 6;
pub const v4l2_colorfx_V4L2_COLORFX_GRASS_GREEN: v4l2_colorfx = 7;
pub const v4l2_colorfx_V4L2_COLORFX_SKIN_WHITEN: v4l2_colorfx = 8;
pub const v4l2_colorfx_V4L2_COLORFX_VIVID: v4l2_colorfx = 9;
pub const v4l2_colorfx_V4L2_COLORFX_AQUA: v4l2_colorfx = 10;
pub const v4l2_colorfx_V4L2_COLORFX_ART_FREEZE: v4l2_colorfx = 11;
pub const v4l2_colorfx_V4L2_COLORFX_SILHOUETTE: v4l2_colorfx = 12;
pub const v4l2_colorfx_V4L2_COLORFX_SOLARIZATION: v4l2_colorfx = 13;
pub const v4l2_colorfx_V4L2_COLORFX_ANTIQUE: v4l2_colorfx = 14;
pub const v4l2_colorfx_V4L2_COLORFX_SET_CBCR: v4l2_colorfx = 15;
pub type v4l2_colorfx = ::std::os::raw::c_uint;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG2_PS: v4l2_mpeg_stream_type = 0;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG2_TS: v4l2_mpeg_stream_type = 1;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG1_SS: v4l2_mpeg_stream_type = 2;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG2_DVD: v4l2_mpeg_stream_type = 3;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG1_VCD: v4l2_mpeg_stream_type = 4;
pub const v4l2_mpeg_stream_type_V4L2_MPEG_STREAM_TYPE_MPEG2_SVCD: v4l2_mpeg_stream_type = 5;
pub type v4l2_mpeg_stream_type = ::std::os::raw::c_uint;
pub const v4l2_mpeg_stream_vbi_fmt_V4L2_MPEG_STREAM_VBI_FMT_NONE: v4l2_mpeg_stream_vbi_fmt = 0;
pub const v4l2_mpeg_stream_vbi_fmt_V4L2_MPEG_STREAM_VBI_FMT_IVTV: v4l2_mpeg_stream_vbi_fmt = 1;
pub type v4l2_mpeg_stream_vbi_fmt = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_sampling_freq_V4L2_MPEG_AUDIO_SAMPLING_FREQ_44100:
    v4l2_mpeg_audio_sampling_freq = 0;
pub const v4l2_mpeg_audio_sampling_freq_V4L2_MPEG_AUDIO_SAMPLING_FREQ_48000:
    v4l2_mpeg_audio_sampling_freq = 1;
pub const v4l2_mpeg_audio_sampling_freq_V4L2_MPEG_AUDIO_SAMPLING_FREQ_32000:
    v4l2_mpeg_audio_sampling_freq = 2;
pub type v4l2_mpeg_audio_sampling_freq = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_LAYER_1: v4l2_mpeg_audio_encoding = 0;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_LAYER_2: v4l2_mpeg_audio_encoding = 1;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_LAYER_3: v4l2_mpeg_audio_encoding = 2;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_AAC: v4l2_mpeg_audio_encoding = 3;
pub const v4l2_mpeg_audio_encoding_V4L2_MPEG_AUDIO_ENCODING_AC3: v4l2_mpeg_audio_encoding = 4;
pub type v4l2_mpeg_audio_encoding = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_32K: v4l2_mpeg_audio_l1_bitrate = 0;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_64K: v4l2_mpeg_audio_l1_bitrate = 1;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_96K: v4l2_mpeg_audio_l1_bitrate = 2;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_128K: v4l2_mpeg_audio_l1_bitrate =
    3;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_160K: v4l2_mpeg_audio_l1_bitrate =
    4;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_192K: v4l2_mpeg_audio_l1_bitrate =
    5;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_224K: v4l2_mpeg_audio_l1_bitrate =
    6;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_256K: v4l2_mpeg_audio_l1_bitrate =
    7;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_288K: v4l2_mpeg_audio_l1_bitrate =
    8;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_320K: v4l2_mpeg_audio_l1_bitrate =
    9;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_352K: v4l2_mpeg_audio_l1_bitrate =
    10;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_384K: v4l2_mpeg_audio_l1_bitrate =
    11;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_416K: v4l2_mpeg_audio_l1_bitrate =
    12;
pub const v4l2_mpeg_audio_l1_bitrate_V4L2_MPEG_AUDIO_L1_BITRATE_448K: v4l2_mpeg_audio_l1_bitrate =
    13;
pub type v4l2_mpeg_audio_l1_bitrate = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_32K: v4l2_mpeg_audio_l2_bitrate = 0;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_48K: v4l2_mpeg_audio_l2_bitrate = 1;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_56K: v4l2_mpeg_audio_l2_bitrate = 2;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_64K: v4l2_mpeg_audio_l2_bitrate = 3;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_80K: v4l2_mpeg_audio_l2_bitrate = 4;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_96K: v4l2_mpeg_audio_l2_bitrate = 5;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_112K: v4l2_mpeg_audio_l2_bitrate =
    6;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_128K: v4l2_mpeg_audio_l2_bitrate =
    7;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_160K: v4l2_mpeg_audio_l2_bitrate =
    8;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_192K: v4l2_mpeg_audio_l2_bitrate =
    9;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_224K: v4l2_mpeg_audio_l2_bitrate =
    10;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_256K: v4l2_mpeg_audio_l2_bitrate =
    11;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_320K: v4l2_mpeg_audio_l2_bitrate =
    12;
pub const v4l2_mpeg_audio_l2_bitrate_V4L2_MPEG_AUDIO_L2_BITRATE_384K: v4l2_mpeg_audio_l2_bitrate =
    13;
pub type v4l2_mpeg_audio_l2_bitrate = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_32K: v4l2_mpeg_audio_l3_bitrate = 0;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_40K: v4l2_mpeg_audio_l3_bitrate = 1;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_48K: v4l2_mpeg_audio_l3_bitrate = 2;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_56K: v4l2_mpeg_audio_l3_bitrate = 3;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_64K: v4l2_mpeg_audio_l3_bitrate = 4;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_80K: v4l2_mpeg_audio_l3_bitrate = 5;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_96K: v4l2_mpeg_audio_l3_bitrate = 6;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_112K: v4l2_mpeg_audio_l3_bitrate =
    7;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_128K: v4l2_mpeg_audio_l3_bitrate =
    8;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_160K: v4l2_mpeg_audio_l3_bitrate =
    9;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_192K: v4l2_mpeg_audio_l3_bitrate =
    10;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_224K: v4l2_mpeg_audio_l3_bitrate =
    11;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_256K: v4l2_mpeg_audio_l3_bitrate =
    12;
pub const v4l2_mpeg_audio_l3_bitrate_V4L2_MPEG_AUDIO_L3_BITRATE_320K: v4l2_mpeg_audio_l3_bitrate =
    13;
pub type v4l2_mpeg_audio_l3_bitrate = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_mode_V4L2_MPEG_AUDIO_MODE_STEREO: v4l2_mpeg_audio_mode = 0;
pub const v4l2_mpeg_audio_mode_V4L2_MPEG_AUDIO_MODE_JOINT_STEREO: v4l2_mpeg_audio_mode = 1;
pub const v4l2_mpeg_audio_mode_V4L2_MPEG_AUDIO_MODE_DUAL: v4l2_mpeg_audio_mode = 2;
pub const v4l2_mpeg_audio_mode_V4L2_MPEG_AUDIO_MODE_MONO: v4l2_mpeg_audio_mode = 3;
pub type v4l2_mpeg_audio_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_mode_extension_V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_4:
    v4l2_mpeg_audio_mode_extension = 0;
pub const v4l2_mpeg_audio_mode_extension_V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_8:
    v4l2_mpeg_audio_mode_extension = 1;
pub const v4l2_mpeg_audio_mode_extension_V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_12:
    v4l2_mpeg_audio_mode_extension = 2;
pub const v4l2_mpeg_audio_mode_extension_V4L2_MPEG_AUDIO_MODE_EXTENSION_BOUND_16:
    v4l2_mpeg_audio_mode_extension = 3;
pub type v4l2_mpeg_audio_mode_extension = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_emphasis_V4L2_MPEG_AUDIO_EMPHASIS_NONE: v4l2_mpeg_audio_emphasis = 0;
pub const v4l2_mpeg_audio_emphasis_V4L2_MPEG_AUDIO_EMPHASIS_50_DIV_15_uS: v4l2_mpeg_audio_emphasis =
    1;
pub const v4l2_mpeg_audio_emphasis_V4L2_MPEG_AUDIO_EMPHASIS_CCITT_J17: v4l2_mpeg_audio_emphasis = 2;
pub type v4l2_mpeg_audio_emphasis = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_crc_V4L2_MPEG_AUDIO_CRC_NONE: v4l2_mpeg_audio_crc = 0;
pub const v4l2_mpeg_audio_crc_V4L2_MPEG_AUDIO_CRC_CRC16: v4l2_mpeg_audio_crc = 1;
pub type v4l2_mpeg_audio_crc = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_32K: v4l2_mpeg_audio_ac3_bitrate =
    0;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_40K: v4l2_mpeg_audio_ac3_bitrate =
    1;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_48K: v4l2_mpeg_audio_ac3_bitrate =
    2;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_56K: v4l2_mpeg_audio_ac3_bitrate =
    3;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_64K: v4l2_mpeg_audio_ac3_bitrate =
    4;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_80K: v4l2_mpeg_audio_ac3_bitrate =
    5;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_96K: v4l2_mpeg_audio_ac3_bitrate =
    6;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_112K:
    v4l2_mpeg_audio_ac3_bitrate = 7;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_128K:
    v4l2_mpeg_audio_ac3_bitrate = 8;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_160K:
    v4l2_mpeg_audio_ac3_bitrate = 9;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_192K:
    v4l2_mpeg_audio_ac3_bitrate = 10;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_224K:
    v4l2_mpeg_audio_ac3_bitrate = 11;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_256K:
    v4l2_mpeg_audio_ac3_bitrate = 12;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_320K:
    v4l2_mpeg_audio_ac3_bitrate = 13;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_384K:
    v4l2_mpeg_audio_ac3_bitrate = 14;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_448K:
    v4l2_mpeg_audio_ac3_bitrate = 15;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_512K:
    v4l2_mpeg_audio_ac3_bitrate = 16;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_576K:
    v4l2_mpeg_audio_ac3_bitrate = 17;
pub const v4l2_mpeg_audio_ac3_bitrate_V4L2_MPEG_AUDIO_AC3_BITRATE_640K:
    v4l2_mpeg_audio_ac3_bitrate = 18;
pub type v4l2_mpeg_audio_ac3_bitrate = ::std::os::raw::c_uint;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_AUTO:
    v4l2_mpeg_audio_dec_playback = 0;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_STEREO:
    v4l2_mpeg_audio_dec_playback = 1;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_LEFT:
    v4l2_mpeg_audio_dec_playback = 2;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_RIGHT:
    v4l2_mpeg_audio_dec_playback = 3;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_MONO:
    v4l2_mpeg_audio_dec_playback = 4;
pub const v4l2_mpeg_audio_dec_playback_V4L2_MPEG_AUDIO_DEC_PLAYBACK_SWAPPED_STEREO:
    v4l2_mpeg_audio_dec_playback = 5;
pub type v4l2_mpeg_audio_dec_playback = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_encoding_V4L2_MPEG_VIDEO_ENCODING_MPEG_1: v4l2_mpeg_video_encoding = 0;
pub const v4l2_mpeg_video_encoding_V4L2_MPEG_VIDEO_ENCODING_MPEG_2: v4l2_mpeg_video_encoding = 1;
pub const v4l2_mpeg_video_encoding_V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC: v4l2_mpeg_video_encoding =
    2;
pub type v4l2_mpeg_video_encoding = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_aspect_V4L2_MPEG_VIDEO_ASPECT_1x1: v4l2_mpeg_video_aspect = 0;
pub const v4l2_mpeg_video_aspect_V4L2_MPEG_VIDEO_ASPECT_4x3: v4l2_mpeg_video_aspect = 1;
pub const v4l2_mpeg_video_aspect_V4L2_MPEG_VIDEO_ASPECT_16x9: v4l2_mpeg_video_aspect = 2;
pub const v4l2_mpeg_video_aspect_V4L2_MPEG_VIDEO_ASPECT_221x100: v4l2_mpeg_video_aspect = 3;
pub type v4l2_mpeg_video_aspect = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_bitrate_mode_V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:
    v4l2_mpeg_video_bitrate_mode = 0;
pub const v4l2_mpeg_video_bitrate_mode_V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:
    v4l2_mpeg_video_bitrate_mode = 1;
pub const v4l2_mpeg_video_bitrate_mode_V4L2_MPEG_VIDEO_BITRATE_MODE_CQ:
    v4l2_mpeg_video_bitrate_mode = 2;
pub type v4l2_mpeg_video_bitrate_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_header_mode_V4L2_MPEG_VIDEO_HEADER_MODE_SEPARATE:
    v4l2_mpeg_video_header_mode = 0;
pub const v4l2_mpeg_video_header_mode_V4L2_MPEG_VIDEO_HEADER_MODE_JOINED_WITH_1ST_FRAME:
    v4l2_mpeg_video_header_mode = 1;
pub type v4l2_mpeg_video_header_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE:
    v4l2_mpeg_video_multi_slice_mode = 0;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB:
    v4l2_mpeg_video_multi_slice_mode = 1;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_BYTES:
    v4l2_mpeg_video_multi_slice_mode = 2;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_MB:
    v4l2_mpeg_video_multi_slice_mode = 1;
pub const v4l2_mpeg_video_multi_slice_mode_V4L2_MPEG_VIDEO_MULTI_SICE_MODE_MAX_BYTES:
    v4l2_mpeg_video_multi_slice_mode = 2;
pub type v4l2_mpeg_video_multi_slice_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_mpeg2_level_V4L2_MPEG_VIDEO_MPEG2_LEVEL_LOW: v4l2_mpeg_video_mpeg2_level =
    0;
pub const v4l2_mpeg_video_mpeg2_level_V4L2_MPEG_VIDEO_MPEG2_LEVEL_MAIN:
    v4l2_mpeg_video_mpeg2_level = 1;
pub const v4l2_mpeg_video_mpeg2_level_V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH_1440:
    v4l2_mpeg_video_mpeg2_level = 2;
pub const v4l2_mpeg_video_mpeg2_level_V4L2_MPEG_VIDEO_MPEG2_LEVEL_HIGH:
    v4l2_mpeg_video_mpeg2_level = 3;
pub type v4l2_mpeg_video_mpeg2_level = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_SIMPLE:
    v4l2_mpeg_video_mpeg2_profile = 0;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_MAIN:
    v4l2_mpeg_video_mpeg2_profile = 1;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_SNR_SCALABLE:
    v4l2_mpeg_video_mpeg2_profile = 2;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_SPATIALLY_SCALABLE:
    v4l2_mpeg_video_mpeg2_profile = 3;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_HIGH:
    v4l2_mpeg_video_mpeg2_profile = 4;
pub const v4l2_mpeg_video_mpeg2_profile_V4L2_MPEG_VIDEO_MPEG2_PROFILE_MULTIVIEW:
    v4l2_mpeg_video_mpeg2_profile = 5;
pub type v4l2_mpeg_video_mpeg2_profile = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_entropy_mode_V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC:
    v4l2_mpeg_video_h264_entropy_mode = 0;
pub const v4l2_mpeg_video_h264_entropy_mode_V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC:
    v4l2_mpeg_video_h264_entropy_mode = 1;
pub type v4l2_mpeg_video_h264_entropy_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1_0: v4l2_mpeg_video_h264_level = 0;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1B: v4l2_mpeg_video_h264_level = 1;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1_1: v4l2_mpeg_video_h264_level = 2;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1_2: v4l2_mpeg_video_h264_level = 3;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_1_3: v4l2_mpeg_video_h264_level = 4;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_2_0: v4l2_mpeg_video_h264_level = 5;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_2_1: v4l2_mpeg_video_h264_level = 6;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_2_2: v4l2_mpeg_video_h264_level = 7;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_3_0: v4l2_mpeg_video_h264_level = 8;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_3_1: v4l2_mpeg_video_h264_level = 9;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_3_2: v4l2_mpeg_video_h264_level =
    10;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_4_0: v4l2_mpeg_video_h264_level =
    11;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_4_1: v4l2_mpeg_video_h264_level =
    12;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_4_2: v4l2_mpeg_video_h264_level =
    13;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_5_0: v4l2_mpeg_video_h264_level =
    14;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_5_1: v4l2_mpeg_video_h264_level =
    15;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_5_2: v4l2_mpeg_video_h264_level =
    16;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_6_0: v4l2_mpeg_video_h264_level =
    17;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_6_1: v4l2_mpeg_video_h264_level =
    18;
pub const v4l2_mpeg_video_h264_level_V4L2_MPEG_VIDEO_H264_LEVEL_6_2: v4l2_mpeg_video_h264_level =
    19;
pub type v4l2_mpeg_video_h264_level = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_loop_filter_mode_V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED:
    v4l2_mpeg_video_h264_loop_filter_mode = 0;
pub const v4l2_mpeg_video_h264_loop_filter_mode_V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED:
    v4l2_mpeg_video_h264_loop_filter_mode = 1;
pub const v4l2_mpeg_video_h264_loop_filter_mode_V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY : v4l2_mpeg_video_h264_loop_filter_mode = 2 ;
pub type v4l2_mpeg_video_h264_loop_filter_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:
    v4l2_mpeg_video_h264_profile = 0;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:
    v4l2_mpeg_video_h264_profile = 1;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:
    v4l2_mpeg_video_h264_profile = 2;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED:
    v4l2_mpeg_video_h264_profile = 3;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:
    v4l2_mpeg_video_h264_profile = 4;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10:
    v4l2_mpeg_video_h264_profile = 5;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422:
    v4l2_mpeg_video_h264_profile = 6;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE:
    v4l2_mpeg_video_h264_profile = 7;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA:
    v4l2_mpeg_video_h264_profile = 8;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA:
    v4l2_mpeg_video_h264_profile = 9;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA:
    v4l2_mpeg_video_h264_profile = 10;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA:
    v4l2_mpeg_video_h264_profile = 11;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE:
    v4l2_mpeg_video_h264_profile = 12;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH:
    v4l2_mpeg_video_h264_profile = 13;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA:
    v4l2_mpeg_video_h264_profile = 14;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH:
    v4l2_mpeg_video_h264_profile = 15;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH:
    v4l2_mpeg_video_h264_profile = 16;
pub const v4l2_mpeg_video_h264_profile_V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_HIGH:
    v4l2_mpeg_video_h264_profile = 17;
pub type v4l2_mpeg_video_h264_profile = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_UNSPECIFIED:
    v4l2_mpeg_video_h264_vui_sar_idc = 0;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1:
    v4l2_mpeg_video_h264_vui_sar_idc = 1;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_12x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 2;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_10x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 3;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_16x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 4;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_40x33:
    v4l2_mpeg_video_h264_vui_sar_idc = 5;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_24x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 6;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_20x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 7;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_32x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 8;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_80x33:
    v4l2_mpeg_video_h264_vui_sar_idc = 9;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_18x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 10;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_15x11:
    v4l2_mpeg_video_h264_vui_sar_idc = 11;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_64x33:
    v4l2_mpeg_video_h264_vui_sar_idc = 12;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_160x99:
    v4l2_mpeg_video_h264_vui_sar_idc = 13;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_4x3:
    v4l2_mpeg_video_h264_vui_sar_idc = 14;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_3x2:
    v4l2_mpeg_video_h264_vui_sar_idc = 15;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_2x1:
    v4l2_mpeg_video_h264_vui_sar_idc = 16;
pub const v4l2_mpeg_video_h264_vui_sar_idc_V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_EXTENDED:
    v4l2_mpeg_video_h264_vui_sar_idc = 17;
pub type v4l2_mpeg_video_h264_vui_sar_idc = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_CHECKERBOARD : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 0 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_COLUMN : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 1 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_ROW : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 2 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_SIDE_BY_SIDE : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 3 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 4 ;
pub const v4l2_mpeg_video_h264_sei_fp_arrangement_type_V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TEMPORAL : v4l2_mpeg_video_h264_sei_fp_arrangement_type = 5 ;
pub type v4l2_mpeg_video_h264_sei_fp_arrangement_type = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_INTERLEAVED_SLICES:
    v4l2_mpeg_video_h264_fmo_map_type = 0;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_SCATTERED_SLICES:
    v4l2_mpeg_video_h264_fmo_map_type = 1;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_FOREGROUND_WITH_LEFT_OVER : v4l2_mpeg_video_h264_fmo_map_type = 2 ;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_BOX_OUT:
    v4l2_mpeg_video_h264_fmo_map_type = 3;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_RASTER_SCAN:
    v4l2_mpeg_video_h264_fmo_map_type = 4;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_WIPE_SCAN:
    v4l2_mpeg_video_h264_fmo_map_type = 5;
pub const v4l2_mpeg_video_h264_fmo_map_type_V4L2_MPEG_VIDEO_H264_FMO_MAP_TYPE_EXPLICIT:
    v4l2_mpeg_video_h264_fmo_map_type = 6;
pub type v4l2_mpeg_video_h264_fmo_map_type = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_fmo_change_dir_V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_RIGHT:
    v4l2_mpeg_video_h264_fmo_change_dir = 0;
pub const v4l2_mpeg_video_h264_fmo_change_dir_V4L2_MPEG_VIDEO_H264_FMO_CHANGE_DIR_LEFT:
    v4l2_mpeg_video_h264_fmo_change_dir = 1;
pub type v4l2_mpeg_video_h264_fmo_change_dir = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_h264_hierarchical_coding_type_V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_B : v4l2_mpeg_video_h264_hierarchical_coding_type = 0 ;
pub const v4l2_mpeg_video_h264_hierarchical_coding_type_V4L2_MPEG_VIDEO_H264_HIERARCHICAL_CODING_P : v4l2_mpeg_video_h264_hierarchical_coding_type = 1 ;
pub type v4l2_mpeg_video_h264_hierarchical_coding_type = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_0: v4l2_mpeg_video_mpeg4_level =
    0;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_0B: v4l2_mpeg_video_mpeg4_level =
    1;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_1: v4l2_mpeg_video_mpeg4_level =
    2;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_2: v4l2_mpeg_video_mpeg4_level =
    3;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_3: v4l2_mpeg_video_mpeg4_level =
    4;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_3B: v4l2_mpeg_video_mpeg4_level =
    5;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_4: v4l2_mpeg_video_mpeg4_level =
    6;
pub const v4l2_mpeg_video_mpeg4_level_V4L2_MPEG_VIDEO_MPEG4_LEVEL_5: v4l2_mpeg_video_mpeg4_level =
    7;
pub type v4l2_mpeg_video_mpeg4_level = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE:
    v4l2_mpeg_video_mpeg4_profile = 0;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_SIMPLE:
    v4l2_mpeg_video_mpeg4_profile = 1;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_CORE:
    v4l2_mpeg_video_mpeg4_profile = 2;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_SIMPLE_SCALABLE:
    v4l2_mpeg_video_mpeg4_profile = 3;
pub const v4l2_mpeg_video_mpeg4_profile_V4L2_MPEG_VIDEO_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY:
    v4l2_mpeg_video_mpeg4_profile = 4;
pub type v4l2_mpeg_video_mpeg4_profile = ::std::os::raw::c_uint;
pub const v4l2_vp8_num_partitions_V4L2_CID_MPEG_VIDEO_VPX_1_PARTITION: v4l2_vp8_num_partitions = 0;
pub const v4l2_vp8_num_partitions_V4L2_CID_MPEG_VIDEO_VPX_2_PARTITIONS: v4l2_vp8_num_partitions = 1;
pub const v4l2_vp8_num_partitions_V4L2_CID_MPEG_VIDEO_VPX_4_PARTITIONS: v4l2_vp8_num_partitions = 2;
pub const v4l2_vp8_num_partitions_V4L2_CID_MPEG_VIDEO_VPX_8_PARTITIONS: v4l2_vp8_num_partitions = 3;
pub type v4l2_vp8_num_partitions = ::std::os::raw::c_uint;
pub const v4l2_vp8_num_ref_frames_V4L2_CID_MPEG_VIDEO_VPX_1_REF_FRAME: v4l2_vp8_num_ref_frames = 0;
pub const v4l2_vp8_num_ref_frames_V4L2_CID_MPEG_VIDEO_VPX_2_REF_FRAME: v4l2_vp8_num_ref_frames = 1;
pub const v4l2_vp8_num_ref_frames_V4L2_CID_MPEG_VIDEO_VPX_3_REF_FRAME: v4l2_vp8_num_ref_frames = 2;
pub type v4l2_vp8_num_ref_frames = ::std::os::raw::c_uint;
pub const v4l2_vp8_golden_frame_sel_V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_PREV:
    v4l2_vp8_golden_frame_sel = 0;
pub const v4l2_vp8_golden_frame_sel_V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_USE_REF_PERIOD:
    v4l2_vp8_golden_frame_sel = 1;
pub type v4l2_vp8_golden_frame_sel = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_vp8_profile_V4L2_MPEG_VIDEO_VP8_PROFILE_0: v4l2_mpeg_video_vp8_profile =
    0;
pub const v4l2_mpeg_video_vp8_profile_V4L2_MPEG_VIDEO_VP8_PROFILE_1: v4l2_mpeg_video_vp8_profile =
    1;
pub const v4l2_mpeg_video_vp8_profile_V4L2_MPEG_VIDEO_VP8_PROFILE_2: v4l2_mpeg_video_vp8_profile =
    2;
pub const v4l2_mpeg_video_vp8_profile_V4L2_MPEG_VIDEO_VP8_PROFILE_3: v4l2_mpeg_video_vp8_profile =
    3;
pub type v4l2_mpeg_video_vp8_profile = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_vp9_profile_V4L2_MPEG_VIDEO_VP9_PROFILE_0: v4l2_mpeg_video_vp9_profile =
    0;
pub const v4l2_mpeg_video_vp9_profile_V4L2_MPEG_VIDEO_VP9_PROFILE_1: v4l2_mpeg_video_vp9_profile =
    1;
pub const v4l2_mpeg_video_vp9_profile_V4L2_MPEG_VIDEO_VP9_PROFILE_2: v4l2_mpeg_video_vp9_profile =
    2;
pub const v4l2_mpeg_video_vp9_profile_V4L2_MPEG_VIDEO_VP9_PROFILE_3: v4l2_mpeg_video_vp9_profile =
    3;
pub type v4l2_mpeg_video_vp9_profile = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_1_0: v4l2_mpeg_video_vp9_level = 0;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_1_1: v4l2_mpeg_video_vp9_level = 1;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_2_0: v4l2_mpeg_video_vp9_level = 2;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_2_1: v4l2_mpeg_video_vp9_level = 3;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_3_0: v4l2_mpeg_video_vp9_level = 4;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_3_1: v4l2_mpeg_video_vp9_level = 5;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_4_0: v4l2_mpeg_video_vp9_level = 6;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_4_1: v4l2_mpeg_video_vp9_level = 7;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_5_0: v4l2_mpeg_video_vp9_level = 8;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_5_1: v4l2_mpeg_video_vp9_level = 9;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_5_2: v4l2_mpeg_video_vp9_level = 10;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_6_0: v4l2_mpeg_video_vp9_level = 11;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_6_1: v4l2_mpeg_video_vp9_level = 12;
pub const v4l2_mpeg_video_vp9_level_V4L2_MPEG_VIDEO_VP9_LEVEL_6_2: v4l2_mpeg_video_vp9_level = 13;
pub type v4l2_mpeg_video_vp9_level = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_hevc_hier_coding_type_V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_B:
    v4l2_mpeg_video_hevc_hier_coding_type = 0;
pub const v4l2_mpeg_video_hevc_hier_coding_type_V4L2_MPEG_VIDEO_HEVC_HIERARCHICAL_CODING_P:
    v4l2_mpeg_video_hevc_hier_coding_type = 1;
pub type v4l2_mpeg_video_hevc_hier_coding_type = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_hevc_profile_V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN:
    v4l2_mpeg_video_hevc_profile = 0;
pub const v4l2_mpeg_video_hevc_profile_V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_STILL_PICTURE:
    v4l2_mpeg_video_hevc_profile = 1;
pub const v4l2_mpeg_video_hevc_profile_V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10:
    v4l2_mpeg_video_hevc_profile = 2;
pub type v4l2_mpeg_video_hevc_profile = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_1: v4l2_mpeg_video_hevc_level = 0;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_2: v4l2_mpeg_video_hevc_level = 1;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_2_1: v4l2_mpeg_video_hevc_level = 2;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_3: v4l2_mpeg_video_hevc_level = 3;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_3_1: v4l2_mpeg_video_hevc_level = 4;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_4: v4l2_mpeg_video_hevc_level = 5;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_4_1: v4l2_mpeg_video_hevc_level = 6;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_5: v4l2_mpeg_video_hevc_level = 7;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1: v4l2_mpeg_video_hevc_level = 8;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_5_2: v4l2_mpeg_video_hevc_level = 9;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_6: v4l2_mpeg_video_hevc_level = 10;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_6_1: v4l2_mpeg_video_hevc_level =
    11;
pub const v4l2_mpeg_video_hevc_level_V4L2_MPEG_VIDEO_HEVC_LEVEL_6_2: v4l2_mpeg_video_hevc_level =
    12;
pub type v4l2_mpeg_video_hevc_level = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_hevc_tier_V4L2_MPEG_VIDEO_HEVC_TIER_MAIN: v4l2_mpeg_video_hevc_tier = 0;
pub const v4l2_mpeg_video_hevc_tier_V4L2_MPEG_VIDEO_HEVC_TIER_HIGH: v4l2_mpeg_video_hevc_tier = 1;
pub type v4l2_mpeg_video_hevc_tier = ::std::os::raw::c_uint;
pub const v4l2_cid_mpeg_video_hevc_loop_filter_mode_V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED : v4l2_cid_mpeg_video_hevc_loop_filter_mode = 0 ;
pub const v4l2_cid_mpeg_video_hevc_loop_filter_mode_V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_ENABLED : v4l2_cid_mpeg_video_hevc_loop_filter_mode = 1 ;
pub const v4l2_cid_mpeg_video_hevc_loop_filter_mode_V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY : v4l2_cid_mpeg_video_hevc_loop_filter_mode = 2 ;
pub type v4l2_cid_mpeg_video_hevc_loop_filter_mode = ::std::os::raw::c_uint;
pub const v4l2_cid_mpeg_video_hevc_refresh_type_V4L2_MPEG_VIDEO_HEVC_REFRESH_NONE:
    v4l2_cid_mpeg_video_hevc_refresh_type = 0;
pub const v4l2_cid_mpeg_video_hevc_refresh_type_V4L2_MPEG_VIDEO_HEVC_REFRESH_CRA:
    v4l2_cid_mpeg_video_hevc_refresh_type = 1;
pub const v4l2_cid_mpeg_video_hevc_refresh_type_V4L2_MPEG_VIDEO_HEVC_REFRESH_IDR:
    v4l2_cid_mpeg_video_hevc_refresh_type = 2;
pub type v4l2_cid_mpeg_video_hevc_refresh_type = ::std::os::raw::c_uint;
pub const v4l2_cid_mpeg_video_hevc_size_of_length_field_V4L2_MPEG_VIDEO_HEVC_SIZE_0:
    v4l2_cid_mpeg_video_hevc_size_of_length_field = 0;
pub const v4l2_cid_mpeg_video_hevc_size_of_length_field_V4L2_MPEG_VIDEO_HEVC_SIZE_1:
    v4l2_cid_mpeg_video_hevc_size_of_length_field = 1;
pub const v4l2_cid_mpeg_video_hevc_size_of_length_field_V4L2_MPEG_VIDEO_HEVC_SIZE_2:
    v4l2_cid_mpeg_video_hevc_size_of_length_field = 2;
pub const v4l2_cid_mpeg_video_hevc_size_of_length_field_V4L2_MPEG_VIDEO_HEVC_SIZE_4:
    v4l2_cid_mpeg_video_hevc_size_of_length_field = 3;
pub type v4l2_cid_mpeg_video_hevc_size_of_length_field = ::std::os::raw::c_uint;
pub const v4l2_mpeg_video_frame_skip_mode_V4L2_MPEG_VIDEO_FRAME_SKIP_MODE_DISABLED:
    v4l2_mpeg_video_frame_skip_mode = 0;
pub const v4l2_mpeg_video_frame_skip_mode_V4L2_MPEG_VIDEO_FRAME_SKIP_MODE_LEVEL_LIMIT:
    v4l2_mpeg_video_frame_skip_mode = 1;
pub const v4l2_mpeg_video_frame_skip_mode_V4L2_MPEG_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT:
    v4l2_mpeg_video_frame_skip_mode = 2;
pub type v4l2_mpeg_video_frame_skip_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_cx2341x_video_spatial_filter_mode_V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_MANUAL : v4l2_mpeg_cx2341x_video_spatial_filter_mode = 0 ;
pub const v4l2_mpeg_cx2341x_video_spatial_filter_mode_V4L2_MPEG_CX2341X_VIDEO_SPATIAL_FILTER_MODE_AUTO : v4l2_mpeg_cx2341x_video_spatial_filter_mode = 1 ;
pub type v4l2_mpeg_cx2341x_video_spatial_filter_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_OFF : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 0 ;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_HOR : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 1 ;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_1D_VERT : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 2 ;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_HV_SEPARABLE : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 3 ;
pub const v4l2_mpeg_cx2341x_video_luma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_LUMA_SPATIAL_FILTER_TYPE_2D_SYM_NON_SEPARABLE : v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = 4 ;
pub type v4l2_mpeg_cx2341x_video_luma_spatial_filter_type = ::std::os::raw::c_uint;
pub const v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_OFF : v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type = 0 ;
pub const v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type_V4L2_MPEG_CX2341X_VIDEO_CHROMA_SPATIAL_FILTER_TYPE_1D_HOR : v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type = 1 ;
pub type v4l2_mpeg_cx2341x_video_chroma_spatial_filter_type = ::std::os::raw::c_uint;
pub const v4l2_mpeg_cx2341x_video_temporal_filter_mode_V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_MANUAL : v4l2_mpeg_cx2341x_video_temporal_filter_mode = 0 ;
pub const v4l2_mpeg_cx2341x_video_temporal_filter_mode_V4L2_MPEG_CX2341X_VIDEO_TEMPORAL_FILTER_MODE_AUTO : v4l2_mpeg_cx2341x_video_temporal_filter_mode = 1 ;
pub type v4l2_mpeg_cx2341x_video_temporal_filter_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_OFF : v4l2_mpeg_cx2341x_video_median_filter_type = 0 ;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR : v4l2_mpeg_cx2341x_video_median_filter_type = 1 ;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_VERT : v4l2_mpeg_cx2341x_video_median_filter_type = 2 ;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_HOR_VERT : v4l2_mpeg_cx2341x_video_median_filter_type = 3 ;
pub const v4l2_mpeg_cx2341x_video_median_filter_type_V4L2_MPEG_CX2341X_VIDEO_MEDIAN_FILTER_TYPE_DIAG : v4l2_mpeg_cx2341x_video_median_filter_type = 4 ;
pub type v4l2_mpeg_cx2341x_video_median_filter_type = ::std::os::raw::c_uint;
pub const v4l2_mpeg_mfc51_video_frame_skip_mode_V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_DISABLED:
    v4l2_mpeg_mfc51_video_frame_skip_mode = 0;
pub const v4l2_mpeg_mfc51_video_frame_skip_mode_V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_LEVEL_LIMIT : v4l2_mpeg_mfc51_video_frame_skip_mode = 1 ;
pub const v4l2_mpeg_mfc51_video_frame_skip_mode_V4L2_MPEG_MFC51_VIDEO_FRAME_SKIP_MODE_BUF_LIMIT:
    v4l2_mpeg_mfc51_video_frame_skip_mode = 2;
pub type v4l2_mpeg_mfc51_video_frame_skip_mode = ::std::os::raw::c_uint;
pub const v4l2_mpeg_mfc51_video_force_frame_type_V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_DISABLED:
    v4l2_mpeg_mfc51_video_force_frame_type = 0;
pub const v4l2_mpeg_mfc51_video_force_frame_type_V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_I_FRAME:
    v4l2_mpeg_mfc51_video_force_frame_type = 1;
pub const v4l2_mpeg_mfc51_video_force_frame_type_V4L2_MPEG_MFC51_VIDEO_FORCE_FRAME_TYPE_NOT_CODED : v4l2_mpeg_mfc51_video_force_frame_type = 2 ;
pub type v4l2_mpeg_mfc51_video_force_frame_type = ::std::os::raw::c_uint;
pub const v4l2_exposure_auto_type_V4L2_EXPOSURE_AUTO: v4l2_exposure_auto_type = 0;
pub const v4l2_exposure_auto_type_V4L2_EXPOSURE_MANUAL: v4l2_exposure_auto_type = 1;
pub const v4l2_exposure_auto_type_V4L2_EXPOSURE_SHUTTER_PRIORITY: v4l2_exposure_auto_type = 2;
pub const v4l2_exposure_auto_type_V4L2_EXPOSURE_APERTURE_PRIORITY: v4l2_exposure_auto_type = 3;
pub type v4l2_exposure_auto_type = ::std::os::raw::c_uint;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_MANUAL:
    v4l2_auto_n_preset_white_balance = 0;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_AUTO:
    v4l2_auto_n_preset_white_balance = 1;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_INCANDESCENT:
    v4l2_auto_n_preset_white_balance = 2;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_FLUORESCENT:
    v4l2_auto_n_preset_white_balance = 3;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_FLUORESCENT_H:
    v4l2_auto_n_preset_white_balance = 4;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_HORIZON:
    v4l2_auto_n_preset_white_balance = 5;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_DAYLIGHT:
    v4l2_auto_n_preset_white_balance = 6;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_FLASH:
    v4l2_auto_n_preset_white_balance = 7;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_CLOUDY:
    v4l2_auto_n_preset_white_balance = 8;
pub const v4l2_auto_n_preset_white_balance_V4L2_WHITE_BALANCE_SHADE:
    v4l2_auto_n_preset_white_balance = 9;
pub type v4l2_auto_n_preset_white_balance = ::std::os::raw::c_uint;
pub const v4l2_iso_sensitivity_auto_type_V4L2_ISO_SENSITIVITY_MANUAL:
    v4l2_iso_sensitivity_auto_type = 0;
pub const v4l2_iso_sensitivity_auto_type_V4L2_ISO_SENSITIVITY_AUTO: v4l2_iso_sensitivity_auto_type =
    1;
pub type v4l2_iso_sensitivity_auto_type = ::std::os::raw::c_uint;
pub const v4l2_exposure_metering_V4L2_EXPOSURE_METERING_AVERAGE: v4l2_exposure_metering = 0;
pub const v4l2_exposure_metering_V4L2_EXPOSURE_METERING_CENTER_WEIGHTED: v4l2_exposure_metering = 1;
pub const v4l2_exposure_metering_V4L2_EXPOSURE_METERING_SPOT: v4l2_exposure_metering = 2;
pub const v4l2_exposure_metering_V4L2_EXPOSURE_METERING_MATRIX: v4l2_exposure_metering = 3;
pub type v4l2_exposure_metering = ::std::os::raw::c_uint;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_NONE: v4l2_scene_mode = 0;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_BACKLIGHT: v4l2_scene_mode = 1;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_BEACH_SNOW: v4l2_scene_mode = 2;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_CANDLE_LIGHT: v4l2_scene_mode = 3;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_DAWN_DUSK: v4l2_scene_mode = 4;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_FALL_COLORS: v4l2_scene_mode = 5;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_FIREWORKS: v4l2_scene_mode = 6;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_LANDSCAPE: v4l2_scene_mode = 7;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_NIGHT: v4l2_scene_mode = 8;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_PARTY_INDOOR: v4l2_scene_mode = 9;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_PORTRAIT: v4l2_scene_mode = 10;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_SPORTS: v4l2_scene_mode = 11;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_SUNSET: v4l2_scene_mode = 12;
pub const v4l2_scene_mode_V4L2_SCENE_MODE_TEXT: v4l2_scene_mode = 13;
pub type v4l2_scene_mode = ::std::os::raw::c_uint;
pub const v4l2_auto_focus_range_V4L2_AUTO_FOCUS_RANGE_AUTO: v4l2_auto_focus_range = 0;
pub const v4l2_auto_focus_range_V4L2_AUTO_FOCUS_RANGE_NORMAL: v4l2_auto_focus_range = 1;
pub const v4l2_auto_focus_range_V4L2_AUTO_FOCUS_RANGE_MACRO: v4l2_auto_focus_range = 2;
pub const v4l2_auto_focus_range_V4L2_AUTO_FOCUS_RANGE_INFINITY: v4l2_auto_focus_range = 3;
pub type v4l2_auto_focus_range = ::std::os::raw::c_uint;
pub const v4l2_preemphasis_V4L2_PREEMPHASIS_DISABLED: v4l2_preemphasis = 0;
pub const v4l2_preemphasis_V4L2_PREEMPHASIS_50_uS: v4l2_preemphasis = 1;
pub const v4l2_preemphasis_V4L2_PREEMPHASIS_75_uS: v4l2_preemphasis = 2;
pub type v4l2_preemphasis = ::std::os::raw::c_uint;
pub const v4l2_flash_led_mode_V4L2_FLASH_LED_MODE_NONE: v4l2_flash_led_mode = 0;
pub const v4l2_flash_led_mode_V4L2_FLASH_LED_MODE_FLASH: v4l2_flash_led_mode = 1;
pub const v4l2_flash_led_mode_V4L2_FLASH_LED_MODE_TORCH: v4l2_flash_led_mode = 2;
pub type v4l2_flash_led_mode = ::std::os::raw::c_uint;
pub const v4l2_flash_strobe_source_V4L2_FLASH_STROBE_SOURCE_SOFTWARE: v4l2_flash_strobe_source = 0;
pub const v4l2_flash_strobe_source_V4L2_FLASH_STROBE_SOURCE_EXTERNAL: v4l2_flash_strobe_source = 1;
pub type v4l2_flash_strobe_source = ::std::os::raw::c_uint;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_444:
    v4l2_jpeg_chroma_subsampling = 0;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_422:
    v4l2_jpeg_chroma_subsampling = 1;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_420:
    v4l2_jpeg_chroma_subsampling = 2;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_411:
    v4l2_jpeg_chroma_subsampling = 3;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_410:
    v4l2_jpeg_chroma_subsampling = 4;
pub const v4l2_jpeg_chroma_subsampling_V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY:
    v4l2_jpeg_chroma_subsampling = 5;
pub type v4l2_jpeg_chroma_subsampling = ::std::os::raw::c_uint;
pub const v4l2_dv_tx_mode_V4L2_DV_TX_MODE_DVI_D: v4l2_dv_tx_mode = 0;
pub const v4l2_dv_tx_mode_V4L2_DV_TX_MODE_HDMI: v4l2_dv_tx_mode = 1;
pub type v4l2_dv_tx_mode = ::std::os::raw::c_uint;
pub const v4l2_dv_rgb_range_V4L2_DV_RGB_RANGE_AUTO: v4l2_dv_rgb_range = 0;
pub const v4l2_dv_rgb_range_V4L2_DV_RGB_RANGE_LIMITED: v4l2_dv_rgb_range = 1;
pub const v4l2_dv_rgb_range_V4L2_DV_RGB_RANGE_FULL: v4l2_dv_rgb_range = 2;
pub type v4l2_dv_rgb_range = ::std::os::raw::c_uint;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_GRAPHICS: v4l2_dv_it_content_type = 0;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_PHOTO: v4l2_dv_it_content_type = 1;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_CINEMA: v4l2_dv_it_content_type = 2;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_GAME: v4l2_dv_it_content_type = 3;
pub const v4l2_dv_it_content_type_V4L2_DV_IT_CONTENT_TYPE_NO_ITC: v4l2_dv_it_content_type = 4;
pub type v4l2_dv_it_content_type = ::std::os::raw::c_uint;
pub const v4l2_deemphasis_V4L2_DEEMPHASIS_DISABLED: v4l2_deemphasis = 0;
pub const v4l2_deemphasis_V4L2_DEEMPHASIS_50_uS: v4l2_deemphasis = 1;
pub const v4l2_deemphasis_V4L2_DEEMPHASIS_75_uS: v4l2_deemphasis = 2;
pub type v4l2_deemphasis = ::std::os::raw::c_uint;
pub const v4l2_detect_md_mode_V4L2_DETECT_MD_MODE_DISABLED: v4l2_detect_md_mode = 0;
pub const v4l2_detect_md_mode_V4L2_DETECT_MD_MODE_GLOBAL: v4l2_detect_md_mode = 1;
pub const v4l2_detect_md_mode_V4L2_DETECT_MD_MODE_THRESHOLD_GRID: v4l2_detect_md_mode = 2;
pub const v4l2_detect_md_mode_V4L2_DETECT_MD_MODE_REGION_GRID: v4l2_detect_md_mode = 3;
pub type v4l2_detect_md_mode = ::std::os::raw::c_uint;
pub const v4l2_stateless_h264_decode_mode_V4L2_STATELESS_H264_DECODE_MODE_SLICE_BASED:
    v4l2_stateless_h264_decode_mode = 0;
pub const v4l2_stateless_h264_decode_mode_V4L2_STATELESS_H264_DECODE_MODE_FRAME_BASED:
    v4l2_stateless_h264_decode_mode = 1;
pub type v4l2_stateless_h264_decode_mode = ::std::os::raw::c_uint;
pub const v4l2_stateless_h264_start_code_V4L2_STATELESS_H264_START_CODE_NONE:
    v4l2_stateless_h264_start_code = 0;
pub const v4l2_stateless_h264_start_code_V4L2_STATELESS_H264_START_CODE_ANNEX_B:
    v4l2_stateless_h264_start_code = 1;
pub type v4l2_stateless_h264_start_code = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_h264_sps {
    pub profile_idc: __u8,
    pub constraint_set_flags: __u8,
    pub level_idc: __u8,
    pub seq_parameter_set_id: __u8,
    pub chroma_format_idc: __u8,
    pub bit_depth_luma_minus8: __u8,
    pub bit_depth_chroma_minus8: __u8,
    pub log2_max_frame_num_minus4: __u8,
    pub pic_order_cnt_type: __u8,
    pub log2_max_pic_order_cnt_lsb_minus4: __u8,
    pub max_num_ref_frames: __u8,
    pub num_ref_frames_in_pic_order_cnt_cycle: __u8,
    pub offset_for_ref_frame: [__s32; 255usize],
    pub offset_for_non_ref_pic: __s32,
    pub offset_for_top_to_bottom_field: __s32,
    pub pic_width_in_mbs_minus1: __u16,
    pub pic_height_in_map_units_minus1: __u16,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_h264_sps() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_h264_sps> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_h264_sps>(),
        1048usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_h264_sps))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_h264_sps>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_h264_sps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile_idc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(profile_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constraint_set_flags) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(constraint_set_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level_idc) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(level_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_parameter_set_id) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(seq_parameter_set_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_format_idc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(chroma_format_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_luma_minus8) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(bit_depth_luma_minus8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_depth_chroma_minus8) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(bit_depth_chroma_minus8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_max_frame_num_minus4) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(log2_max_frame_num_minus4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_order_cnt_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(pic_order_cnt_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).log2_max_pic_order_cnt_lsb_minus4) as usize - ptr as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(log2_max_pic_order_cnt_lsb_minus4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_num_ref_frames) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(max_num_ref_frames)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_frames_in_pic_order_cnt_cycle) as usize
                - ptr as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(num_ref_frames_in_pic_order_cnt_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_for_ref_frame) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(offset_for_ref_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset_for_non_ref_pic) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(offset_for_non_ref_pic)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).offset_for_top_to_bottom_field) as usize - ptr as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(offset_for_top_to_bottom_field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_width_in_mbs_minus1) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(pic_width_in_mbs_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).pic_height_in_map_units_minus1) as usize - ptr as usize
        },
        1042usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(pic_height_in_map_units_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_sps),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_h264_pps {
    pub pic_parameter_set_id: __u8,
    pub seq_parameter_set_id: __u8,
    pub num_slice_groups_minus1: __u8,
    pub num_ref_idx_l0_default_active_minus1: __u8,
    pub num_ref_idx_l1_default_active_minus1: __u8,
    pub weighted_bipred_idc: __u8,
    pub pic_init_qp_minus26: __s8,
    pub pic_init_qs_minus26: __s8,
    pub chroma_qp_index_offset: __s8,
    pub second_chroma_qp_index_offset: __s8,
    pub flags: __u16,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_h264_pps() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_h264_pps> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_h264_pps>(),
        12usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_h264_pps))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_h264_pps>(),
        2usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_h264_pps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_parameter_set_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(pic_parameter_set_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_parameter_set_id) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(seq_parameter_set_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_slice_groups_minus1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(num_slice_groups_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_idx_l0_default_active_minus1) as usize
                - ptr as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(num_ref_idx_l0_default_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_idx_l1_default_active_minus1) as usize
                - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(num_ref_idx_l1_default_active_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weighted_bipred_idc) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(weighted_bipred_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_init_qp_minus26) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(pic_init_qp_minus26)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_init_qs_minus26) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(pic_init_qs_minus26)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_qp_index_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(chroma_qp_index_offset)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).second_chroma_qp_index_offset) as usize - ptr as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(second_chroma_qp_index_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pps),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_h264_scaling_matrix {
    pub scaling_list_4x4: [[__u8; 16usize]; 6usize],
    pub scaling_list_8x8: [[__u8; 64usize]; 6usize],
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_h264_scaling_matrix() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_h264_scaling_matrix> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_h264_scaling_matrix>(),
        480usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_h264_scaling_matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_h264_scaling_matrix>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_h264_scaling_matrix))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling_list_4x4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_scaling_matrix),
            "::",
            stringify!(scaling_list_4x4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling_list_8x8) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_scaling_matrix),
            "::",
            stringify!(scaling_list_8x8)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_h264_weight_factors {
    pub luma_weight: [__s16; 32usize],
    pub luma_offset: [__s16; 32usize],
    pub chroma_weight: [[__s16; 2usize]; 32usize],
    pub chroma_offset: [[__s16; 2usize]; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_h264_weight_factors() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_h264_weight_factors> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_h264_weight_factors>(),
        384usize,
        concat!("Size of: ", stringify!(v4l2_h264_weight_factors))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_h264_weight_factors>(),
        2usize,
        concat!("Alignment of ", stringify!(v4l2_h264_weight_factors))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luma_weight) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_weight_factors),
            "::",
            stringify!(luma_weight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luma_offset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_weight_factors),
            "::",
            stringify!(luma_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_weight) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_weight_factors),
            "::",
            stringify!(chroma_weight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_offset) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_weight_factors),
            "::",
            stringify!(chroma_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_h264_pred_weights {
    pub luma_log2_weight_denom: __u16,
    pub chroma_log2_weight_denom: __u16,
    pub weight_factors: [v4l2_h264_weight_factors; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_h264_pred_weights() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_h264_pred_weights> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_h264_pred_weights>(),
        772usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_h264_pred_weights))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_h264_pred_weights>(),
        2usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_h264_pred_weights))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luma_log2_weight_denom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pred_weights),
            "::",
            stringify!(luma_log2_weight_denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_log2_weight_denom) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pred_weights),
            "::",
            stringify!(chroma_log2_weight_denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weight_factors) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_pred_weights),
            "::",
            stringify!(weight_factors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_h264_reference {
    pub fields: __u8,
    pub index: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_h264_reference() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_h264_reference> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_h264_reference>(),
        2usize,
        concat!("Size of: ", stringify!(v4l2_h264_reference))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_h264_reference>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_h264_reference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_reference),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_reference),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_h264_slice_params {
    pub header_bit_size: __u32,
    pub first_mb_in_slice: __u32,
    pub slice_type: __u8,
    pub colour_plane_id: __u8,
    pub redundant_pic_cnt: __u8,
    pub cabac_init_idc: __u8,
    pub slice_qp_delta: __s8,
    pub slice_qs_delta: __s8,
    pub disable_deblocking_filter_idc: __u8,
    pub slice_alpha_c0_offset_div2: __s8,
    pub slice_beta_offset_div2: __s8,
    pub num_ref_idx_l0_active_minus1: __u8,
    pub num_ref_idx_l1_active_minus1: __u8,
    pub reserved: __u8,
    pub ref_pic_list0: [v4l2_h264_reference; 32usize],
    pub ref_pic_list1: [v4l2_h264_reference; 32usize],
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_h264_slice_params() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_h264_slice_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_h264_slice_params>(),
        152usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_h264_slice_params))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_h264_slice_params>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_h264_slice_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_bit_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(header_bit_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_mb_in_slice) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(first_mb_in_slice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(slice_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colour_plane_id) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(colour_plane_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).redundant_pic_cnt) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(redundant_pic_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cabac_init_idc) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(cabac_init_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_qp_delta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(slice_qp_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_qs_delta) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(slice_qs_delta)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).disable_deblocking_filter_idc) as usize - ptr as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(disable_deblocking_filter_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_alpha_c0_offset_div2) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(slice_alpha_c0_offset_div2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_beta_offset_div2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(slice_beta_offset_div2)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_idx_l0_active_minus1) as usize - ptr as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(num_ref_idx_l0_active_minus1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).num_ref_idx_l1_active_minus1) as usize - ptr as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(num_ref_idx_l1_active_minus1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_pic_list0) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(ref_pic_list0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_pic_list1) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(ref_pic_list1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_slice_params),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_h264_dpb_entry {
    pub reference_ts: __u64,
    pub pic_num: __u32,
    pub frame_num: __u16,
    pub fields: __u8,
    pub reserved: [__u8; 5usize],
    pub top_field_order_cnt: __s32,
    pub bottom_field_order_cnt: __s32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_h264_dpb_entry() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_h264_dpb_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_h264_dpb_entry>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_h264_dpb_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_h264_dpb_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_h264_dpb_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reference_ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_dpb_entry),
            "::",
            stringify!(reference_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_dpb_entry),
            "::",
            stringify!(pic_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_dpb_entry),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_dpb_entry),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_dpb_entry),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_field_order_cnt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_dpb_entry),
            "::",
            stringify!(top_field_order_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom_field_order_cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_dpb_entry),
            "::",
            stringify!(bottom_field_order_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_h264_dpb_entry),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_h264_decode_params {
    pub dpb: [v4l2_h264_dpb_entry; 16usize],
    pub nal_ref_idc: __u16,
    pub frame_num: __u16,
    pub top_field_order_cnt: __s32,
    pub bottom_field_order_cnt: __s32,
    pub idr_pic_id: __u16,
    pub pic_order_cnt_lsb: __u16,
    pub delta_pic_order_cnt_bottom: __s32,
    pub delta_pic_order_cnt0: __s32,
    pub delta_pic_order_cnt1: __s32,
    pub dec_ref_pic_marking_bit_size: __u32,
    pub pic_order_cnt_bit_size: __u32,
    pub slice_group_change_cycle: __u32,
    pub reserved: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_h264_decode_params() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_h264_decode_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_h264_decode_params>(),
        560usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_h264_decode_params))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_h264_decode_params>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_h264_decode_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dpb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(dpb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nal_ref_idc) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(nal_ref_idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_num) as usize - ptr as usize },
        514usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(frame_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top_field_order_cnt) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(top_field_order_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bottom_field_order_cnt) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(bottom_field_order_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idr_pic_id) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(idr_pic_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_order_cnt_lsb) as usize - ptr as usize },
        526usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(pic_order_cnt_lsb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_pic_order_cnt_bottom) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(delta_pic_order_cnt_bottom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_pic_order_cnt0) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(delta_pic_order_cnt0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_pic_order_cnt1) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(delta_pic_order_cnt1)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).dec_ref_pic_marking_bit_size) as usize - ptr as usize
        },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(dec_ref_pic_marking_bit_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_order_cnt_bit_size) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(pic_order_cnt_bit_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slice_group_change_cycle) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(slice_group_change_cycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_h264_decode_params),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_fwht_params {
    pub backward_ref_ts: __u64,
    pub version: __u32,
    pub width: __u32,
    pub height: __u32,
    pub flags: __u32,
    pub colorspace: __u32,
    pub xfer_func: __u32,
    pub ycbcr_enc: __u32,
    pub quantization: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_fwht_params() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_fwht_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_fwht_params>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_fwht_params))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_fwht_params>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_fwht_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backward_ref_ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(backward_ref_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xfer_func) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(xfer_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycbcr_enc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(ycbcr_enc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantization) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_fwht_params),
            "::",
            stringify!(quantization)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_vp8_segment {
    pub quant_update: [__s8; 4usize],
    pub lf_update: [__s8; 4usize],
    pub segment_probs: [__u8; 3usize],
    pub padding: __u8,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_vp8_segment() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_vp8_segment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_vp8_segment>(),
        16usize,
        concat!("Size of: ", stringify!(v4l2_vp8_segment))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_vp8_segment>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_vp8_segment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quant_update) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_segment),
            "::",
            stringify!(quant_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lf_update) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_segment),
            "::",
            stringify!(lf_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segment_probs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_segment),
            "::",
            stringify!(segment_probs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_segment),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_segment),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_vp8_loop_filter {
    pub ref_frm_delta: [__s8; 4usize],
    pub mb_mode_delta: [__s8; 4usize],
    pub sharpness_level: __u8,
    pub level: __u8,
    pub padding: __u16,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_vp8_loop_filter() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_vp8_loop_filter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_vp8_loop_filter>(),
        16usize,
        concat!("Size of: ", stringify!(v4l2_vp8_loop_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_vp8_loop_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_vp8_loop_filter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_frm_delta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_loop_filter),
            "::",
            stringify!(ref_frm_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mb_mode_delta) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_loop_filter),
            "::",
            stringify!(mb_mode_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharpness_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_loop_filter),
            "::",
            stringify!(sharpness_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_loop_filter),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_loop_filter),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_loop_filter),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_vp8_quantization {
    pub y_ac_qi: __u8,
    pub y_dc_delta: __s8,
    pub y2_dc_delta: __s8,
    pub y2_ac_delta: __s8,
    pub uv_dc_delta: __s8,
    pub uv_ac_delta: __s8,
    pub padding: __u16,
}
#[test]
fn bindgen_test_layout_v4l2_vp8_quantization() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_vp8_quantization> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_vp8_quantization>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_vp8_quantization))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_vp8_quantization>(),
        2usize,
        concat!("Alignment of ", stringify!(v4l2_vp8_quantization))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_ac_qi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_quantization),
            "::",
            stringify!(y_ac_qi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_dc_delta) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_quantization),
            "::",
            stringify!(y_dc_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y2_dc_delta) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_quantization),
            "::",
            stringify!(y2_dc_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y2_ac_delta) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_quantization),
            "::",
            stringify!(y2_ac_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_dc_delta) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_quantization),
            "::",
            stringify!(uv_dc_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_ac_delta) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_quantization),
            "::",
            stringify!(uv_ac_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_quantization),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_vp8_entropy {
    pub coeff_probs: [[[[__u8; 11usize]; 3usize]; 8usize]; 4usize],
    pub y_mode_probs: [__u8; 4usize],
    pub uv_mode_probs: [__u8; 3usize],
    pub mv_probs: [[__u8; 19usize]; 2usize],
    pub padding: [__u8; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_vp8_entropy() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_vp8_entropy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_vp8_entropy>(),
        1104usize,
        concat!("Size of: ", stringify!(v4l2_vp8_entropy))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_vp8_entropy>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_vp8_entropy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coeff_probs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy),
            "::",
            stringify!(coeff_probs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_mode_probs) as usize - ptr as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy),
            "::",
            stringify!(y_mode_probs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_mode_probs) as usize - ptr as usize },
        1060usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy),
            "::",
            stringify!(uv_mode_probs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mv_probs) as usize - ptr as usize },
        1063usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy),
            "::",
            stringify!(mv_probs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        1101usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_vp8_entropy_coder_state {
    pub range: __u8,
    pub value: __u8,
    pub bit_count: __u8,
    pub padding: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_vp8_entropy_coder_state() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_vp8_entropy_coder_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_vp8_entropy_coder_state>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_vp8_entropy_coder_state))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_vp8_entropy_coder_state>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_vp8_entropy_coder_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy_coder_state),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy_coder_state),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bit_count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy_coder_state),
            "::",
            stringify!(bit_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vp8_entropy_coder_state),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_vp8_frame {
    pub segment: v4l2_vp8_segment,
    pub lf: v4l2_vp8_loop_filter,
    pub quant: v4l2_vp8_quantization,
    pub entropy: v4l2_vp8_entropy,
    pub coder_state: v4l2_vp8_entropy_coder_state,
    pub width: __u16,
    pub height: __u16,
    pub horizontal_scale: __u8,
    pub vertical_scale: __u8,
    pub version: __u8,
    pub prob_skip_false: __u8,
    pub prob_intra: __u8,
    pub prob_last: __u8,
    pub prob_gf: __u8,
    pub num_dct_parts: __u8,
    pub first_part_size: __u32,
    pub first_part_header_bits: __u32,
    pub dct_part_sizes: [__u32; 8usize],
    pub last_frame_ts: __u64,
    pub golden_frame_ts: __u64,
    pub alt_frame_ts: __u64,
    pub flags: __u64,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_vp8_frame() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_vp8_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_vp8_frame>(),
        1232usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_vp8_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_vp8_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_vp8_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(lf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quant) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(quant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entropy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(entropy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coder_state) as usize - ptr as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(coder_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        1148usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        1150usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horizontal_scale) as usize - ptr as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(horizontal_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertical_scale) as usize - ptr as usize },
        1153usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(vertical_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        1154usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prob_skip_false) as usize - ptr as usize },
        1155usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(prob_skip_false)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prob_intra) as usize - ptr as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(prob_intra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prob_last) as usize - ptr as usize },
        1157usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(prob_last)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prob_gf) as usize - ptr as usize },
        1158usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(prob_gf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_dct_parts) as usize - ptr as usize },
        1159usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(num_dct_parts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_part_size) as usize - ptr as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(first_part_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_part_header_bits) as usize - ptr as usize },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(first_part_header_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dct_part_sizes) as usize - ptr as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(dct_part_sizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_frame_ts) as usize - ptr as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(last_frame_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).golden_frame_ts) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(golden_frame_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alt_frame_ts) as usize - ptr as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(alt_frame_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_vp8_frame),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_mpeg2_sequence {
    pub horizontal_size: __u16,
    pub vertical_size: __u16,
    pub vbv_buffer_size: __u32,
    pub profile_and_level_indication: __u16,
    pub chroma_format: __u8,
    pub flags: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_mpeg2_sequence() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_mpeg2_sequence> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_mpeg2_sequence>(),
        12usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_mpeg2_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_mpeg2_sequence>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_mpeg2_sequence))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horizontal_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_sequence),
            "::",
            stringify!(horizontal_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertical_size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_sequence),
            "::",
            stringify!(vertical_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vbv_buffer_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_sequence),
            "::",
            stringify!(vbv_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).profile_and_level_indication) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_sequence),
            "::",
            stringify!(profile_and_level_indication)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_format) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_sequence),
            "::",
            stringify!(chroma_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_sequence),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_mpeg2_picture {
    pub backward_ref_ts: __u64,
    pub forward_ref_ts: __u64,
    pub flags: __u32,
    pub f_code: [[__u8; 2usize]; 2usize],
    pub picture_coding_type: __u8,
    pub picture_structure: __u8,
    pub intra_dc_precision: __u8,
    pub reserved: [__u8; 5usize],
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_mpeg2_picture() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_mpeg2_picture> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_mpeg2_picture>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_mpeg2_picture))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_mpeg2_picture>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_mpeg2_picture))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backward_ref_ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_picture),
            "::",
            stringify!(backward_ref_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forward_ref_ts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_picture),
            "::",
            stringify!(forward_ref_ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_picture),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f_code) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_picture),
            "::",
            stringify!(f_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picture_coding_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_picture),
            "::",
            stringify!(picture_coding_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picture_structure) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_picture),
            "::",
            stringify!(picture_structure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_dc_precision) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_picture),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_picture),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_mpeg2_quantisation {
    pub intra_quantiser_matrix: [__u8; 64usize],
    pub non_intra_quantiser_matrix: [__u8; 64usize],
    pub chroma_intra_quantiser_matrix: [__u8; 64usize],
    pub chroma_non_intra_quantiser_matrix: [__u8; 64usize],
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_mpeg2_quantisation() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_mpeg2_quantisation> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_mpeg2_quantisation>(),
        256usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_mpeg2_quantisation))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_mpeg2_quantisation>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_mpeg2_quantisation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_quantiser_matrix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_quantisation),
            "::",
            stringify!(intra_quantiser_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).non_intra_quantiser_matrix) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_quantisation),
            "::",
            stringify!(non_intra_quantiser_matrix)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).chroma_intra_quantiser_matrix) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_quantisation),
            "::",
            stringify!(chroma_intra_quantiser_matrix)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).chroma_non_intra_quantiser_matrix) as usize - ptr as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_mpeg2_quantisation),
            "::",
            stringify!(chroma_non_intra_quantiser_matrix)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_hdr10_cll_info {
    pub max_content_light_level: __u16,
    pub max_pic_average_light_level: __u16,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_hdr10_cll_info() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_hdr10_cll_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_hdr10_cll_info>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_hdr10_cll_info))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_hdr10_cll_info>(),
        2usize,
        concat!("Alignment of ", stringify!(v4l2_ctrl_hdr10_cll_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_content_light_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_hdr10_cll_info),
            "::",
            stringify!(max_content_light_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_pic_average_light_level) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_hdr10_cll_info),
            "::",
            stringify!(max_pic_average_light_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_ctrl_hdr10_mastering_display {
    pub display_primaries_x: [__u16; 3usize],
    pub display_primaries_y: [__u16; 3usize],
    pub white_point_x: __u16,
    pub white_point_y: __u16,
    pub max_display_mastering_luminance: __u32,
    pub min_display_mastering_luminance: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_ctrl_hdr10_mastering_display() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ctrl_hdr10_mastering_display> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ctrl_hdr10_mastering_display>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_ctrl_hdr10_mastering_display))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ctrl_hdr10_mastering_display>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_ctrl_hdr10_mastering_display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_primaries_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_hdr10_mastering_display),
            "::",
            stringify!(display_primaries_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_primaries_y) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_hdr10_mastering_display),
            "::",
            stringify!(display_primaries_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_hdr10_mastering_display),
            "::",
            stringify!(white_point_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point_y) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_hdr10_mastering_display),
            "::",
            stringify!(white_point_y)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_display_mastering_luminance) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_hdr10_mastering_display),
            "::",
            stringify!(max_display_mastering_luminance)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).min_display_mastering_luminance) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ctrl_hdr10_mastering_display),
            "::",
            stringify!(min_display_mastering_luminance)
        )
    );
}
pub const v4l2_field_V4L2_FIELD_ANY: v4l2_field = 0;
pub const v4l2_field_V4L2_FIELD_NONE: v4l2_field = 1;
pub const v4l2_field_V4L2_FIELD_TOP: v4l2_field = 2;
pub const v4l2_field_V4L2_FIELD_BOTTOM: v4l2_field = 3;
pub const v4l2_field_V4L2_FIELD_INTERLACED: v4l2_field = 4;
pub const v4l2_field_V4L2_FIELD_SEQ_TB: v4l2_field = 5;
pub const v4l2_field_V4L2_FIELD_SEQ_BT: v4l2_field = 6;
pub const v4l2_field_V4L2_FIELD_ALTERNATE: v4l2_field = 7;
pub const v4l2_field_V4L2_FIELD_INTERLACED_TB: v4l2_field = 8;
pub const v4l2_field_V4L2_FIELD_INTERLACED_BT: v4l2_field = 9;
pub type v4l2_field = ::std::os::raw::c_uint;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_CAPTURE: v4l2_buf_type = 1;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_OUTPUT: v4l2_buf_type = 2;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_OVERLAY: v4l2_buf_type = 3;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VBI_CAPTURE: v4l2_buf_type = 4;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VBI_OUTPUT: v4l2_buf_type = 5;
pub const v4l2_buf_type_V4L2_BUF_TYPE_SLICED_VBI_CAPTURE: v4l2_buf_type = 6;
pub const v4l2_buf_type_V4L2_BUF_TYPE_SLICED_VBI_OUTPUT: v4l2_buf_type = 7;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY: v4l2_buf_type = 8;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE: v4l2_buf_type = 9;
pub const v4l2_buf_type_V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE: v4l2_buf_type = 10;
pub const v4l2_buf_type_V4L2_BUF_TYPE_SDR_CAPTURE: v4l2_buf_type = 11;
pub const v4l2_buf_type_V4L2_BUF_TYPE_SDR_OUTPUT: v4l2_buf_type = 12;
pub const v4l2_buf_type_V4L2_BUF_TYPE_META_CAPTURE: v4l2_buf_type = 13;
pub const v4l2_buf_type_V4L2_BUF_TYPE_META_OUTPUT: v4l2_buf_type = 14;
pub const v4l2_buf_type_V4L2_BUF_TYPE_PRIVATE: v4l2_buf_type = 128;
pub type v4l2_buf_type = ::std::os::raw::c_uint;
pub const v4l2_tuner_type_V4L2_TUNER_RADIO: v4l2_tuner_type = 1;
pub const v4l2_tuner_type_V4L2_TUNER_ANALOG_TV: v4l2_tuner_type = 2;
pub const v4l2_tuner_type_V4L2_TUNER_DIGITAL_TV: v4l2_tuner_type = 3;
pub const v4l2_tuner_type_V4L2_TUNER_SDR: v4l2_tuner_type = 4;
pub const v4l2_tuner_type_V4L2_TUNER_RF: v4l2_tuner_type = 5;
pub type v4l2_tuner_type = ::std::os::raw::c_uint;
pub const v4l2_memory_V4L2_MEMORY_MMAP: v4l2_memory = 1;
pub const v4l2_memory_V4L2_MEMORY_USERPTR: v4l2_memory = 2;
pub const v4l2_memory_V4L2_MEMORY_OVERLAY: v4l2_memory = 3;
pub const v4l2_memory_V4L2_MEMORY_DMABUF: v4l2_memory = 4;
pub type v4l2_memory = ::std::os::raw::c_uint;
pub const v4l2_colorspace_V4L2_COLORSPACE_DEFAULT: v4l2_colorspace = 0;
pub const v4l2_colorspace_V4L2_COLORSPACE_SMPTE170M: v4l2_colorspace = 1;
pub const v4l2_colorspace_V4L2_COLORSPACE_SMPTE240M: v4l2_colorspace = 2;
pub const v4l2_colorspace_V4L2_COLORSPACE_REC709: v4l2_colorspace = 3;
pub const v4l2_colorspace_V4L2_COLORSPACE_BT878: v4l2_colorspace = 4;
pub const v4l2_colorspace_V4L2_COLORSPACE_470_SYSTEM_M: v4l2_colorspace = 5;
pub const v4l2_colorspace_V4L2_COLORSPACE_470_SYSTEM_BG: v4l2_colorspace = 6;
pub const v4l2_colorspace_V4L2_COLORSPACE_JPEG: v4l2_colorspace = 7;
pub const v4l2_colorspace_V4L2_COLORSPACE_SRGB: v4l2_colorspace = 8;
pub const v4l2_colorspace_V4L2_COLORSPACE_OPRGB: v4l2_colorspace = 9;
pub const v4l2_colorspace_V4L2_COLORSPACE_BT2020: v4l2_colorspace = 10;
pub const v4l2_colorspace_V4L2_COLORSPACE_RAW: v4l2_colorspace = 11;
pub const v4l2_colorspace_V4L2_COLORSPACE_DCI_P3: v4l2_colorspace = 12;
pub type v4l2_colorspace = ::std::os::raw::c_uint;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_DEFAULT: v4l2_xfer_func = 0;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_709: v4l2_xfer_func = 1;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_SRGB: v4l2_xfer_func = 2;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_OPRGB: v4l2_xfer_func = 3;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_SMPTE240M: v4l2_xfer_func = 4;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_NONE: v4l2_xfer_func = 5;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_DCI_P3: v4l2_xfer_func = 6;
pub const v4l2_xfer_func_V4L2_XFER_FUNC_SMPTE2084: v4l2_xfer_func = 7;
pub type v4l2_xfer_func = ::std::os::raw::c_uint;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_DEFAULT: v4l2_ycbcr_encoding = 0;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_601: v4l2_ycbcr_encoding = 1;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_709: v4l2_ycbcr_encoding = 2;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_XV601: v4l2_ycbcr_encoding = 3;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_XV709: v4l2_ycbcr_encoding = 4;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_SYCC: v4l2_ycbcr_encoding = 5;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_BT2020: v4l2_ycbcr_encoding = 6;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_BT2020_CONST_LUM: v4l2_ycbcr_encoding = 7;
pub const v4l2_ycbcr_encoding_V4L2_YCBCR_ENC_SMPTE240M: v4l2_ycbcr_encoding = 8;
pub type v4l2_ycbcr_encoding = ::std::os::raw::c_uint;
pub const v4l2_hsv_encoding_V4L2_HSV_ENC_180: v4l2_hsv_encoding = 128;
pub const v4l2_hsv_encoding_V4L2_HSV_ENC_256: v4l2_hsv_encoding = 129;
pub type v4l2_hsv_encoding = ::std::os::raw::c_uint;
pub const v4l2_quantization_V4L2_QUANTIZATION_DEFAULT: v4l2_quantization = 0;
pub const v4l2_quantization_V4L2_QUANTIZATION_FULL_RANGE: v4l2_quantization = 1;
pub const v4l2_quantization_V4L2_QUANTIZATION_LIM_RANGE: v4l2_quantization = 2;
pub type v4l2_quantization = ::std::os::raw::c_uint;
pub const v4l2_priority_V4L2_PRIORITY_UNSET: v4l2_priority = 0;
pub const v4l2_priority_V4L2_PRIORITY_BACKGROUND: v4l2_priority = 1;
pub const v4l2_priority_V4L2_PRIORITY_INTERACTIVE: v4l2_priority = 2;
pub const v4l2_priority_V4L2_PRIORITY_RECORD: v4l2_priority = 3;
pub const v4l2_priority_V4L2_PRIORITY_DEFAULT: v4l2_priority = 2;
pub type v4l2_priority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_rect {
    pub left: __s32,
    pub top: __s32,
    pub width: __u32,
    pub height: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_rect() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_rect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_rect>(),
        16usize,
        concat!("Size of: ", stringify!(v4l2_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_rect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rect),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rect),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rect),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_fract() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_fract> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_fract>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_fract>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_fract))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numerator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denominator) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fract),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_area {
    pub width: __u32,
    pub height: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_area() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_area> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_area>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_area))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_area>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_area))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_area),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_area),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_capability {
    pub driver: [__u8; 16usize],
    pub card: [__u8; 32usize],
    pub bus_info: [__u8; 32usize],
    pub version: __u32,
    pub capabilities: __u32,
    pub device_caps: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_capability() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_capability> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_capability>(),
        104usize,
        concat!("Size of: ", stringify!(v4l2_capability))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_capability>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_capability))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).card) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(card)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(bus_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_caps) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(device_caps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_capability),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_pix_format {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub bytesperline: __u32,
    pub sizeimage: __u32,
    pub colorspace: __u32,
    pub priv_: __u32,
    pub flags: __u32,
    pub __bindgen_anon_1: v4l2_pix_format__bindgen_ty_1,
    pub quantization: __u32,
    pub xfer_func: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_pix_format__bindgen_ty_1 {
    pub ycbcr_enc: __u32,
    pub hsv_enc: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_pix_format__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_pix_format__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_pix_format__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_pix_format__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_pix_format__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_pix_format__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycbcr_enc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format__bindgen_ty_1),
            "::",
            stringify!(ycbcr_enc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hsv_enc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format__bindgen_ty_1),
            "::",
            stringify!(hsv_enc)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_pix_format() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_pix_format> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_pix_format>(),
        48usize,
        concat!("Size of: ", stringify!(v4l2_pix_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_pix_format>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_pix_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelformat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesperline) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(bytesperline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeimage) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(sizeimage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantization) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(quantization)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xfer_func) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format),
            "::",
            stringify!(xfer_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_fmtdesc {
    pub index: __u32,
    pub type_: __u32,
    pub flags: __u32,
    pub description: [__u8; 32usize],
    pub pixelformat: __u32,
    pub mbus_code: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_fmtdesc() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_fmtdesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_fmtdesc>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_fmtdesc))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_fmtdesc>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_fmtdesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelformat) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbus_code) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(mbus_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_fmtdesc),
            "::",
            stringify!(reserved)
        )
    );
}
pub const v4l2_frmsizetypes_V4L2_FRMSIZE_TYPE_DISCRETE: v4l2_frmsizetypes = 1;
pub const v4l2_frmsizetypes_V4L2_FRMSIZE_TYPE_CONTINUOUS: v4l2_frmsizetypes = 2;
pub const v4l2_frmsizetypes_V4L2_FRMSIZE_TYPE_STEPWISE: v4l2_frmsizetypes = 3;
pub type v4l2_frmsizetypes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frmsize_discrete {
    pub width: __u32,
    pub height: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_frmsize_discrete() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frmsize_discrete> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmsize_discrete>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_frmsize_discrete))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmsize_discrete>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmsize_discrete))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_discrete),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_discrete),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frmsize_stepwise {
    pub min_width: __u32,
    pub max_width: __u32,
    pub step_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
    pub step_height: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_frmsize_stepwise() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frmsize_stepwise> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmsize_stepwise>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_frmsize_stepwise))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmsize_stepwise>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmsize_stepwise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(step_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_height) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsize_stepwise),
            "::",
            stringify!(step_height)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_frmsizeenum {
    pub index: __u32,
    pub pixel_format: __u32,
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_frmsizeenum__bindgen_ty_1,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_frmsizeenum__bindgen_ty_1 {
    pub discrete: v4l2_frmsize_discrete,
    pub stepwise: v4l2_frmsize_stepwise,
}
#[test]
fn bindgen_test_layout_v4l2_frmsizeenum__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frmsizeenum__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmsizeenum__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_frmsizeenum__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmsizeenum__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmsizeenum__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discrete) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum__bindgen_ty_1),
            "::",
            stringify!(discrete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stepwise) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum__bindgen_ty_1),
            "::",
            stringify!(stepwise)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_frmsizeenum() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frmsizeenum> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmsizeenum>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_frmsizeenum))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmsizeenum>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmsizeenum))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmsizeenum),
            "::",
            stringify!(reserved)
        )
    );
}
pub const v4l2_frmivaltypes_V4L2_FRMIVAL_TYPE_DISCRETE: v4l2_frmivaltypes = 1;
pub const v4l2_frmivaltypes_V4L2_FRMIVAL_TYPE_CONTINUOUS: v4l2_frmivaltypes = 2;
pub const v4l2_frmivaltypes_V4L2_FRMIVAL_TYPE_STEPWISE: v4l2_frmivaltypes = 3;
pub type v4l2_frmivaltypes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frmival_stepwise {
    pub min: v4l2_fract,
    pub max: v4l2_fract,
    pub step: v4l2_fract,
}
#[test]
fn bindgen_test_layout_v4l2_frmival_stepwise() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frmival_stepwise> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmival_stepwise>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_frmival_stepwise))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmival_stepwise>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmival_stepwise))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmival_stepwise),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmival_stepwise),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmival_stepwise),
            "::",
            stringify!(step)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_frmivalenum {
    pub index: __u32,
    pub pixel_format: __u32,
    pub width: __u32,
    pub height: __u32,
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_frmivalenum__bindgen_ty_1,
    pub reserved: [__u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_frmivalenum__bindgen_ty_1 {
    pub discrete: v4l2_fract,
    pub stepwise: v4l2_frmival_stepwise,
}
#[test]
fn bindgen_test_layout_v4l2_frmivalenum__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frmivalenum__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmivalenum__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_frmivalenum__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmivalenum__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmivalenum__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).discrete) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum__bindgen_ty_1),
            "::",
            stringify!(discrete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stepwise) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum__bindgen_ty_1),
            "::",
            stringify!(stepwise)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_frmivalenum() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frmivalenum> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frmivalenum>(),
        52usize,
        concat!("Size of: ", stringify!(v4l2_frmivalenum))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frmivalenum>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frmivalenum))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frmivalenum),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_timecode {
    pub type_: __u32,
    pub flags: __u32,
    pub frames: __u8,
    pub seconds: __u8,
    pub minutes: __u8,
    pub hours: __u8,
    pub userbits: [__u8; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_timecode() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_timecode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_timecode>(),
        16usize,
        concat!("Size of: ", stringify!(v4l2_timecode))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_timecode>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_timecode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minutes) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hours) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userbits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_timecode),
            "::",
            stringify!(userbits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_jpegcompression {
    pub quality: ::std::os::raw::c_int,
    pub APPn: ::std::os::raw::c_int,
    pub APP_len: ::std::os::raw::c_int,
    pub APP_data: [::std::os::raw::c_char; 60usize],
    pub COM_len: ::std::os::raw::c_int,
    pub COM_data: [::std::os::raw::c_char; 60usize],
    pub jpeg_markers: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_jpegcompression() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_jpegcompression> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_jpegcompression>(),
        140usize,
        concat!("Size of: ", stringify!(v4l2_jpegcompression))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_jpegcompression>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_jpegcompression))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).APPn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(APPn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).APP_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(APP_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).APP_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(APP_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).COM_len) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(COM_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).COM_data) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(COM_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jpeg_markers) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_jpegcompression),
            "::",
            stringify!(jpeg_markers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_requestbuffers {
    pub count: __u32,
    pub type_: __u32,
    pub memory: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 1usize],
}
#[test]
fn bindgen_test_layout_v4l2_requestbuffers() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_requestbuffers> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_requestbuffers>(),
        20usize,
        concat!("Size of: ", stringify!(v4l2_requestbuffers))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_requestbuffers>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_requestbuffers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_requestbuffers),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_plane {
    pub bytesused: __u32,
    pub length: __u32,
    pub m: v4l2_plane__bindgen_ty_1,
    pub data_offset: __u32,
    pub reserved: [__u32; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_plane__bindgen_ty_1 {
    pub mem_offset: __u32,
    pub userptr: ::std::os::raw::c_ulong,
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_v4l2_plane__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_plane__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_plane__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_plane__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_plane__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_plane__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane__bindgen_ty_1),
            "::",
            stringify!(mem_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane__bindgen_ty_1),
            "::",
            stringify!(userptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_plane() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_plane> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_plane>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_plane))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_plane>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_plane))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(bytesused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_buffer {
    pub index: __u32,
    pub type_: __u32,
    pub bytesused: __u32,
    pub flags: __u32,
    pub field: __u32,
    pub timestamp: timeval,
    pub timecode: v4l2_timecode,
    pub sequence: __u32,
    pub memory: __u32,
    pub m: v4l2_buffer__bindgen_ty_1,
    pub length: __u32,
    pub reserved2: __u32,
    pub __bindgen_anon_1: v4l2_buffer__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_buffer__bindgen_ty_1 {
    pub offset: __u32,
    pub userptr: ::std::os::raw::c_ulong,
    pub planes: *mut v4l2_plane,
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_v4l2_buffer__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_buffer__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_buffer__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_buffer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_buffer__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_buffer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_1),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_1),
            "::",
            stringify!(userptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).planes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_1),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_buffer__bindgen_ty_2 {
    pub request_fd: __s32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_buffer__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_buffer__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_buffer__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_buffer__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_buffer__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_buffer__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_2),
            "::",
            stringify!(request_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_buffer>(),
        88usize,
        concat!("Size of: ", stringify!(v4l2_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesused) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(bytesused)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timecode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(timecode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_buffer),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_exportbuffer {
    pub type_: __u32,
    pub index: __u32,
    pub plane: __u32,
    pub flags: __u32,
    pub fd: __s32,
    pub reserved: [__u32; 11usize],
}
#[test]
fn bindgen_test_layout_v4l2_exportbuffer() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_exportbuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_exportbuffer>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_exportbuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_exportbuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_exportbuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plane) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(plane)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_exportbuffer),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_framebuffer {
    pub capability: __u32,
    pub flags: __u32,
    pub base: *mut ::std::os::raw::c_void,
    pub fmt: v4l2_framebuffer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_framebuffer__bindgen_ty_1 {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub bytesperline: __u32,
    pub sizeimage: __u32,
    pub colorspace: __u32,
    pub priv_: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_framebuffer__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_framebuffer__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_framebuffer__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_framebuffer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_framebuffer__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_framebuffer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelformat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesperline) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(bytesperline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeimage) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(sizeimage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer__bindgen_ty_1),
            "::",
            stringify!(priv_)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_framebuffer() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_framebuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_framebuffer>(),
        48usize,
        concat!("Size of: ", stringify!(v4l2_framebuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_framebuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_framebuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_framebuffer),
            "::",
            stringify!(fmt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_clip {
    pub c: v4l2_rect,
    pub next: *mut v4l2_clip,
}
#[test]
fn bindgen_test_layout_v4l2_clip() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_clip> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_clip>(),
        24usize,
        concat!("Size of: ", stringify!(v4l2_clip))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_clip>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_clip))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_clip),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_clip),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_window {
    pub w: v4l2_rect,
    pub field: __u32,
    pub chromakey: __u32,
    pub clips: *mut v4l2_clip,
    pub clipcount: __u32,
    pub bitmap: *mut ::std::os::raw::c_void,
    pub global_alpha: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_window() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_window> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_window>(),
        56usize,
        concat!("Size of: ", stringify!(v4l2_window))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_window>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_window))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chromakey) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(chromakey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clips) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(clips)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clipcount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(clipcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmap) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_alpha) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_window),
            "::",
            stringify!(global_alpha)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_captureparm {
    pub capability: __u32,
    pub capturemode: __u32,
    pub timeperframe: v4l2_fract,
    pub extendedmode: __u32,
    pub readbuffers: __u32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_captureparm() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_captureparm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_captureparm>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_captureparm))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_captureparm>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_captureparm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capturemode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(capturemode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeperframe) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(timeperframe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extendedmode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(extendedmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readbuffers) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(readbuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_captureparm),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_outputparm {
    pub capability: __u32,
    pub outputmode: __u32,
    pub timeperframe: v4l2_fract,
    pub extendedmode: __u32,
    pub writebuffers: __u32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_outputparm() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_outputparm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_outputparm>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_outputparm))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_outputparm>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_outputparm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(outputmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeperframe) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(timeperframe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extendedmode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(extendedmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writebuffers) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(writebuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_outputparm),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_cropcap {
    pub type_: __u32,
    pub bounds: v4l2_rect,
    pub defrect: v4l2_rect,
    pub pixelaspect: v4l2_fract,
}
#[test]
fn bindgen_test_layout_v4l2_cropcap() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_cropcap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_cropcap>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_cropcap))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_cropcap>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_cropcap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_cropcap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bounds) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_cropcap),
            "::",
            stringify!(bounds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defrect) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_cropcap),
            "::",
            stringify!(defrect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelaspect) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_cropcap),
            "::",
            stringify!(pixelaspect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_crop {
    pub type_: __u32,
    pub c: v4l2_rect,
}
#[test]
fn bindgen_test_layout_v4l2_crop() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_crop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_crop>(),
        20usize,
        concat!("Size of: ", stringify!(v4l2_crop))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_crop>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_crop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_crop),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_crop),
            "::",
            stringify!(c)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_selection {
    pub type_: __u32,
    pub target: __u32,
    pub flags: __u32,
    pub r: v4l2_rect,
    pub reserved: [__u32; 9usize],
}
#[test]
fn bindgen_test_layout_v4l2_selection() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_selection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_selection>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_selection))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_selection>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_selection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_selection),
            "::",
            stringify!(reserved)
        )
    );
}
pub type v4l2_std_id = __u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_standard {
    pub index: __u32,
    pub id: v4l2_std_id,
    pub name: [__u8; 24usize],
    pub frameperiod: v4l2_fract,
    pub framelines: __u32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_standard() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_standard> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_standard>(),
        72usize,
        concat!("Size of: ", stringify!(v4l2_standard))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_standard>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_standard))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameperiod) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(frameperiod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framelines) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(framelines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_standard),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_bt_timings {
    pub width: __u32,
    pub height: __u32,
    pub interlaced: __u32,
    pub polarities: __u32,
    pub pixelclock: __u64,
    pub hfrontporch: __u32,
    pub hsync: __u32,
    pub hbackporch: __u32,
    pub vfrontporch: __u32,
    pub vsync: __u32,
    pub vbackporch: __u32,
    pub il_vfrontporch: __u32,
    pub il_vsync: __u32,
    pub il_vbackporch: __u32,
    pub standards: __u32,
    pub flags: __u32,
    pub picture_aspect: v4l2_fract,
    pub cea861_vic: __u8,
    pub hdmi_vic: __u8,
    pub reserved: [__u8; 46usize],
}
#[test]
fn bindgen_test_layout_v4l2_bt_timings() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_bt_timings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_bt_timings>(),
        124usize,
        concat!("Size of: ", stringify!(v4l2_bt_timings))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_bt_timings>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_bt_timings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlaced) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(interlaced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).polarities) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(polarities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelclock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(pixelclock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hfrontporch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(hfrontporch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hsync) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(hsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hbackporch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(hbackporch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfrontporch) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(vfrontporch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsync) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(vsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vbackporch) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(vbackporch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).il_vfrontporch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(il_vfrontporch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).il_vsync) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(il_vsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).il_vbackporch) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(il_vbackporch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).standards) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(standards)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picture_aspect) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(picture_aspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cea861_vic) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(cea861_vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdmi_vic) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(hdmi_vic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dv_timings {
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_dv_timings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dv_timings__bindgen_ty_1 {
    pub bt: v4l2_bt_timings,
    pub reserved: [__u32; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_dv_timings__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_dv_timings__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_dv_timings__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(v4l2_dv_timings__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dv_timings__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_dv_timings__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings__bindgen_ty_1),
            "::",
            stringify!(bt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_dv_timings() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_dv_timings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_dv_timings>(),
        132usize,
        concat!("Size of: ", stringify!(v4l2_dv_timings))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dv_timings>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_dv_timings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_enum_dv_timings {
    pub index: __u32,
    pub pad: __u32,
    pub reserved: [__u32; 2usize],
    pub timings: v4l2_dv_timings,
}
#[test]
fn bindgen_test_layout_v4l2_enum_dv_timings() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_enum_dv_timings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_enum_dv_timings>(),
        148usize,
        concat!("Size of: ", stringify!(v4l2_enum_dv_timings))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_enum_dv_timings>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_enum_dv_timings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enum_dv_timings),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enum_dv_timings),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enum_dv_timings),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timings) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enum_dv_timings),
            "::",
            stringify!(timings)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_bt_timings_cap {
    pub min_width: __u32,
    pub max_width: __u32,
    pub min_height: __u32,
    pub max_height: __u32,
    pub min_pixelclock: __u64,
    pub max_pixelclock: __u64,
    pub standards: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 16usize],
}
#[test]
fn bindgen_test_layout_v4l2_bt_timings_cap() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_bt_timings_cap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_bt_timings_cap>(),
        104usize,
        concat!("Size of: ", stringify!(v4l2_bt_timings_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_bt_timings_cap>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_bt_timings_cap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(min_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(min_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_pixelclock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(min_pixelclock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_pixelclock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(max_pixelclock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).standards) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(standards)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_bt_timings_cap),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_dv_timings_cap {
    pub type_: __u32,
    pub pad: __u32,
    pub reserved: [__u32; 2usize],
    pub __bindgen_anon_1: v4l2_dv_timings_cap__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dv_timings_cap__bindgen_ty_1 {
    pub bt: v4l2_bt_timings_cap,
    pub raw_data: [__u32; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_dv_timings_cap__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_dv_timings_cap__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_dv_timings_cap__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(v4l2_dv_timings_cap__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dv_timings_cap__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_dv_timings_cap__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap__bindgen_ty_1),
            "::",
            stringify!(bt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap__bindgen_ty_1),
            "::",
            stringify!(raw_data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_dv_timings_cap() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_dv_timings_cap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_dv_timings_cap>(),
        144usize,
        concat!("Size of: ", stringify!(v4l2_dv_timings_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dv_timings_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_dv_timings_cap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dv_timings_cap),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_input {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub audioset: __u32,
    pub tuner: __u32,
    pub std: v4l2_std_id,
    pub status: __u32,
    pub capabilities: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_input() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_input> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_input>(),
        80usize,
        concat!("Size of: ", stringify!(v4l2_input))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_input>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_input))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(audioset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tuner) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(tuner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).std) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(std)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_input),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_output {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub audioset: __u32,
    pub modulator: __u32,
    pub std: v4l2_std_id,
    pub capabilities: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_output() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_output> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_output>(),
        72usize,
        concat!("Size of: ", stringify!(v4l2_output))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_output>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_output))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audioset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(audioset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modulator) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(modulator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).std) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(std)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_output),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_control {
    pub id: __u32,
    pub value: __s32,
}
#[test]
fn bindgen_test_layout_v4l2_control() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_control> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_control>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_control))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_control>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_control),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_control),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_ext_control {
    pub id: __u32,
    pub size: __u32,
    pub reserved2: [__u32; 1usize],
    pub __bindgen_anon_1: v4l2_ext_control__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_ext_control__bindgen_ty_1 {
    pub value: __s32,
    pub value64: __s64,
    pub string: *mut ::std::os::raw::c_char,
    pub p_u8: *mut __u8,
    pub p_u16: *mut __u16,
    pub p_u32: *mut __u32,
    pub p_area: *mut v4l2_area,
    pub p_h264_sps: *mut v4l2_ctrl_h264_sps,
    pub p_h264_pps: *mut v4l2_ctrl_h264_pps,
    pub p_h264_scaling_matrix: *mut v4l2_ctrl_h264_scaling_matrix,
    pub p_h264_pred_weights: *mut v4l2_ctrl_h264_pred_weights,
    pub p_h264_slice_params: *mut v4l2_ctrl_h264_slice_params,
    pub p_h264_decode_params: *mut v4l2_ctrl_h264_decode_params,
    pub p_fwht_params: *mut v4l2_ctrl_fwht_params,
    pub p_vp8_frame: *mut v4l2_ctrl_vp8_frame,
    pub p_mpeg2_sequence: *mut v4l2_ctrl_mpeg2_sequence,
    pub p_mpeg2_picture: *mut v4l2_ctrl_mpeg2_picture,
    pub p_mpeg2_quantisation: *mut v4l2_ctrl_mpeg2_quantisation,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_v4l2_ext_control__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ext_control__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ext_control__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_ext_control__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ext_control__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_ext_control__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_u8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_u8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_u16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_u16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_u32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_u32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_area) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_h264_sps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_h264_sps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_h264_pps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_h264_pps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_h264_scaling_matrix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_h264_scaling_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_h264_pred_weights) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_h264_pred_weights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_h264_slice_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_h264_slice_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_h264_decode_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_h264_decode_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_fwht_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_fwht_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_vp8_frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_vp8_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_mpeg2_sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_mpeg2_sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_mpeg2_picture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_mpeg2_picture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_mpeg2_quantisation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(p_mpeg2_quantisation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_ext_control() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ext_control> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ext_control>(),
        20usize,
        concat!("Size of: ", stringify!(v4l2_ext_control))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ext_control>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_ext_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_control),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_ext_controls {
    pub __bindgen_anon_1: v4l2_ext_controls__bindgen_ty_1,
    pub count: __u32,
    pub error_idx: __u32,
    pub request_fd: __s32,
    pub reserved: [__u32; 1usize],
    pub controls: *mut v4l2_ext_control,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_ext_controls__bindgen_ty_1 {
    pub ctrl_class: __u32,
    pub which: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_ext_controls__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ext_controls__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ext_controls__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_ext_controls__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ext_controls__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_ext_controls__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrl_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls__bindgen_ty_1),
            "::",
            stringify!(ctrl_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls__bindgen_ty_1),
            "::",
            stringify!(which)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_ext_controls() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_ext_controls> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_ext_controls>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_ext_controls))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_ext_controls>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_ext_controls))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_idx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(error_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_fd) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(request_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).controls) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_ext_controls),
            "::",
            stringify!(controls)
        )
    );
}
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_INTEGER: v4l2_ctrl_type = 1;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_BOOLEAN: v4l2_ctrl_type = 2;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_MENU: v4l2_ctrl_type = 3;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_BUTTON: v4l2_ctrl_type = 4;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_INTEGER64: v4l2_ctrl_type = 5;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_CTRL_CLASS: v4l2_ctrl_type = 6;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_STRING: v4l2_ctrl_type = 7;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_BITMASK: v4l2_ctrl_type = 8;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_INTEGER_MENU: v4l2_ctrl_type = 9;
pub const v4l2_ctrl_type_V4L2_CTRL_COMPOUND_TYPES: v4l2_ctrl_type = 256;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_U8: v4l2_ctrl_type = 256;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_U16: v4l2_ctrl_type = 257;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_U32: v4l2_ctrl_type = 258;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_AREA: v4l2_ctrl_type = 262;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_HDR10_CLL_INFO: v4l2_ctrl_type = 272;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY: v4l2_ctrl_type = 273;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_H264_SPS: v4l2_ctrl_type = 512;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_H264_PPS: v4l2_ctrl_type = 513;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_H264_SCALING_MATRIX: v4l2_ctrl_type = 514;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_H264_SLICE_PARAMS: v4l2_ctrl_type = 515;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_H264_DECODE_PARAMS: v4l2_ctrl_type = 516;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_H264_PRED_WEIGHTS: v4l2_ctrl_type = 517;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_FWHT_PARAMS: v4l2_ctrl_type = 544;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_VP8_FRAME: v4l2_ctrl_type = 576;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_MPEG2_QUANTISATION: v4l2_ctrl_type = 592;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_MPEG2_SEQUENCE: v4l2_ctrl_type = 593;
pub const v4l2_ctrl_type_V4L2_CTRL_TYPE_MPEG2_PICTURE: v4l2_ctrl_type = 594;
pub type v4l2_ctrl_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_queryctrl {
    pub id: __u32,
    pub type_: __u32,
    pub name: [__u8; 32usize],
    pub minimum: __s32,
    pub maximum: __s32,
    pub step: __s32,
    pub default_value: __s32,
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_queryctrl() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_queryctrl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_queryctrl>(),
        68usize,
        concat!("Size of: ", stringify!(v4l2_queryctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_queryctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_queryctrl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_queryctrl),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_query_ext_ctrl {
    pub id: __u32,
    pub type_: __u32,
    pub name: [::std::os::raw::c_char; 32usize],
    pub minimum: __s64,
    pub maximum: __s64,
    pub step: __u64,
    pub default_value: __s64,
    pub flags: __u32,
    pub elem_size: __u32,
    pub elems: __u32,
    pub nr_of_dims: __u32,
    pub dims: [__u32; 4usize],
    pub reserved: [__u32; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_query_ext_ctrl() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_query_ext_ctrl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_query_ext_ctrl>(),
        232usize,
        concat!("Size of: ", stringify!(v4l2_query_ext_ctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_query_ext_ctrl>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_query_ext_ctrl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elem_size) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(elem_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(elems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nr_of_dims) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(nr_of_dims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dims) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_query_ext_ctrl),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_querymenu {
    pub id: __u32,
    pub index: __u32,
    pub __bindgen_anon_1: v4l2_querymenu__bindgen_ty_1,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_querymenu__bindgen_ty_1 {
    pub name: [__u8; 32usize],
    pub value: __s64,
}
#[test]
fn bindgen_test_layout_v4l2_querymenu__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_querymenu__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_querymenu__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_querymenu__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_querymenu__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_querymenu__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_querymenu() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_querymenu> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_querymenu>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_querymenu))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_querymenu>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_querymenu))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_querymenu),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_tuner {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub type_: __u32,
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub rxsubchans: __u32,
    pub audmode: __u32,
    pub signal: __s32,
    pub afc: __s32,
    pub reserved: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout_v4l2_tuner() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_tuner> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_tuner>(),
        84usize,
        concat!("Size of: ", stringify!(v4l2_tuner))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_tuner>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_tuner))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangelow) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(rangelow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangehigh) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(rangehigh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxsubchans) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(rxsubchans)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).audmode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(audmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).afc) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(afc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_tuner),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_modulator {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub txsubchans: __u32,
    pub type_: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_modulator() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_modulator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_modulator>(),
        68usize,
        concat!("Size of: ", stringify!(v4l2_modulator))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_modulator>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_modulator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangelow) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(rangelow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangehigh) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(rangehigh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txsubchans) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(txsubchans)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_modulator),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frequency {
    pub tuner: __u32,
    pub type_: __u32,
    pub frequency: __u32,
    pub reserved: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_v4l2_frequency() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frequency> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frequency>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_frequency))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frequency>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frequency))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tuner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency),
            "::",
            stringify!(tuner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_frequency_band {
    pub tuner: __u32,
    pub type_: __u32,
    pub index: __u32,
    pub capability: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub modulation: __u32,
    pub reserved: [__u32; 9usize],
}
#[test]
fn bindgen_test_layout_v4l2_frequency_band() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_frequency_band> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_frequency_band>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_frequency_band))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_frequency_band>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_frequency_band))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tuner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(tuner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangelow) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(rangelow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangehigh) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(rangehigh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modulation) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(modulation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_frequency_band),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_hw_freq_seek {
    pub tuner: __u32,
    pub type_: __u32,
    pub seek_upward: __u32,
    pub wrap_around: __u32,
    pub spacing: __u32,
    pub rangelow: __u32,
    pub rangehigh: __u32,
    pub reserved: [__u32; 5usize],
}
#[test]
fn bindgen_test_layout_v4l2_hw_freq_seek() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_hw_freq_seek> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_hw_freq_seek>(),
        48usize,
        concat!("Size of: ", stringify!(v4l2_hw_freq_seek))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_hw_freq_seek>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_hw_freq_seek))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tuner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(tuner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek_upward) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(seek_upward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wrap_around) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(wrap_around)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spacing) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(spacing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangelow) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(rangelow)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rangehigh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(rangehigh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_hw_freq_seek),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_rds_data {
    pub lsb: __u8,
    pub msb: __u8,
    pub block: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_rds_data() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_rds_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_rds_data>(),
        3usize,
        concat!("Size of: ", stringify!(v4l2_rds_data))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_rds_data>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_rds_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lsb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rds_data),
            "::",
            stringify!(lsb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msb) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rds_data),
            "::",
            stringify!(msb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_rds_data),
            "::",
            stringify!(block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_audio {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub mode: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_audio() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_audio> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_audio>(),
        52usize,
        concat!("Size of: ", stringify!(v4l2_audio))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_audio>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_audio))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audio),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_audioout {
    pub index: __u32,
    pub name: [__u8; 32usize],
    pub capability: __u32,
    pub mode: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_audioout() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_audioout> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_audioout>(),
        52usize,
        concat!("Size of: ", stringify!(v4l2_audioout))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_audioout>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_audioout))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_audioout),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_enc_idx_entry {
    pub offset: __u64,
    pub pts: __u64,
    pub length: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_enc_idx_entry() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_enc_idx_entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_enc_idx_entry>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_enc_idx_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_enc_idx_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_enc_idx_entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx_entry),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_enc_idx {
    pub entries: __u32,
    pub entries_cap: __u32,
    pub reserved: [__u32; 4usize],
    pub entry: [v4l2_enc_idx_entry; 64usize],
}
#[test]
fn bindgen_test_layout_v4l2_enc_idx() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_enc_idx> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_enc_idx>(),
        2072usize,
        concat!("Size of: ", stringify!(v4l2_enc_idx))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_enc_idx>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_enc_idx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entries_cap) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx),
            "::",
            stringify!(entries_cap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_enc_idx),
            "::",
            stringify!(entry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_encoder_cmd {
    pub cmd: __u32,
    pub flags: __u32,
    pub __bindgen_anon_1: v4l2_encoder_cmd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_encoder_cmd__bindgen_ty_1 {
    pub raw: v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub data: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_encoder_cmd__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_encoder_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_encoder_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_encoder_cmd__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_encoder_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_encoder_cmd__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_encoder_cmd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_encoder_cmd__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_encoder_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_encoder_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_encoder_cmd>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_encoder_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_encoder_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_encoder_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_encoder_cmd),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_encoder_cmd),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_decoder_cmd {
    pub cmd: __u32,
    pub flags: __u32,
    pub __bindgen_anon_1: v4l2_decoder_cmd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_decoder_cmd__bindgen_ty_1 {
    pub stop: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1,
    pub start: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2,
    pub raw: v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub pts: __u64,
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2 {
    pub speed: __s32,
    pub format: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3 {
    pub data: [__u32; 16usize],
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_decoder_cmd__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_decoder_cmd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_decoder_cmd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_decoder_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_decoder_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_decoder_cmd>(),
        72usize,
        concat!("Size of: ", stringify!(v4l2_decoder_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_decoder_cmd>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_decoder_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_decoder_cmd),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_vbi_format {
    pub sampling_rate: __u32,
    pub offset: __u32,
    pub samples_per_line: __u32,
    pub sample_format: __u32,
    pub start: [__s32; 2usize],
    pub count: [__u32; 2usize],
    pub flags: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_vbi_format() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_vbi_format> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_vbi_format>(),
        44usize,
        concat!("Size of: ", stringify!(v4l2_vbi_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_vbi_format>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_vbi_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampling_rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(sampling_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samples_per_line) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(samples_per_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample_format) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(sample_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_vbi_format),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sliced_vbi_format {
    pub service_set: __u16,
    pub service_lines: [[__u16; 24usize]; 2usize],
    pub io_size: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_v4l2_sliced_vbi_format() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_sliced_vbi_format> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_sliced_vbi_format>(),
        112usize,
        concat!("Size of: ", stringify!(v4l2_sliced_vbi_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_sliced_vbi_format>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_sliced_vbi_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_format),
            "::",
            stringify!(service_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_lines) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_format),
            "::",
            stringify!(service_lines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_size) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_format),
            "::",
            stringify!(io_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_format),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sliced_vbi_cap {
    pub service_set: __u16,
    pub service_lines: [[__u16; 24usize]; 2usize],
    pub type_: __u32,
    pub reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_v4l2_sliced_vbi_cap() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_sliced_vbi_cap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_sliced_vbi_cap>(),
        116usize,
        concat!("Size of: ", stringify!(v4l2_sliced_vbi_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_sliced_vbi_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_sliced_vbi_cap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_cap),
            "::",
            stringify!(service_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_lines) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_cap),
            "::",
            stringify!(service_lines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_cap),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_cap),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sliced_vbi_data {
    pub id: __u32,
    pub field: __u32,
    pub line: __u32,
    pub reserved: __u32,
    pub data: [__u8; 48usize],
}
#[test]
fn bindgen_test_layout_v4l2_sliced_vbi_data() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_sliced_vbi_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_sliced_vbi_data>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_sliced_vbi_data))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_sliced_vbi_data>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_sliced_vbi_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sliced_vbi_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_itv0_line {
    pub id: __u8,
    pub data: [__u8; 42usize],
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_itv0_line() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_mpeg_vbi_itv0_line> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_itv0_line>(),
        43usize,
        concat!("Size of: ", stringify!(v4l2_mpeg_vbi_itv0_line))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_itv0_line>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_mpeg_vbi_itv0_line))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_itv0_line),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_itv0_line),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_itv0 {
    pub linemask: [__le32; 2usize],
    pub line: [v4l2_mpeg_vbi_itv0_line; 35usize],
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_itv0() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_mpeg_vbi_itv0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_itv0>(),
        1513usize,
        concat!("Size of: ", stringify!(v4l2_mpeg_vbi_itv0))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_itv0>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_mpeg_vbi_itv0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linemask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_itv0),
            "::",
            stringify!(linemask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_itv0),
            "::",
            stringify!(line)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_mpeg_vbi_ITV0 {
    pub line: [v4l2_mpeg_vbi_itv0_line; 36usize],
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_ITV0() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_mpeg_vbi_ITV0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_ITV0>(),
        1548usize,
        concat!("Size of: ", stringify!(v4l2_mpeg_vbi_ITV0))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_ITV0>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_mpeg_vbi_ITV0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_ITV0),
            "::",
            stringify!(line)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_mpeg_vbi_fmt_ivtv {
    pub magic: [__u8; 4usize],
    pub __bindgen_anon_1: v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1 {
    pub itv0: v4l2_mpeg_vbi_itv0,
    pub ITV0: v4l2_mpeg_vbi_ITV0,
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>(),
        1548usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itv0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1),
            "::",
            stringify!(itv0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ITV0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv__bindgen_ty_1),
            "::",
            stringify!(ITV0)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_mpeg_vbi_fmt_ivtv() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_mpeg_vbi_fmt_ivtv> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_mpeg_vbi_fmt_ivtv>(),
        1552usize,
        concat!("Size of: ", stringify!(v4l2_mpeg_vbi_fmt_ivtv))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_mpeg_vbi_fmt_ivtv>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_mpeg_vbi_fmt_ivtv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_mpeg_vbi_fmt_ivtv),
            "::",
            stringify!(magic)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_plane_pix_format {
    pub sizeimage: __u32,
    pub bytesperline: __u32,
    pub reserved: [__u16; 6usize],
}
#[test]
fn bindgen_test_layout_v4l2_plane_pix_format() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_plane_pix_format> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_plane_pix_format>(),
        20usize,
        concat!("Size of: ", stringify!(v4l2_plane_pix_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_plane_pix_format>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_plane_pix_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeimage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane_pix_format),
            "::",
            stringify!(sizeimage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesperline) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane_pix_format),
            "::",
            stringify!(bytesperline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_plane_pix_format),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_pix_format_mplane {
    pub width: __u32,
    pub height: __u32,
    pub pixelformat: __u32,
    pub field: __u32,
    pub colorspace: __u32,
    pub plane_fmt: [v4l2_plane_pix_format; 8usize],
    pub num_planes: __u8,
    pub flags: __u8,
    pub __bindgen_anon_1: v4l2_pix_format_mplane__bindgen_ty_1,
    pub quantization: __u8,
    pub xfer_func: __u8,
    pub reserved: [__u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_pix_format_mplane__bindgen_ty_1 {
    pub ycbcr_enc: __u8,
    pub hsv_enc: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_pix_format_mplane__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_pix_format_mplane__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_pix_format_mplane__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(v4l2_pix_format_mplane__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_pix_format_mplane__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(v4l2_pix_format_mplane__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ycbcr_enc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane__bindgen_ty_1),
            "::",
            stringify!(ycbcr_enc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hsv_enc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane__bindgen_ty_1),
            "::",
            stringify!(hsv_enc)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_pix_format_mplane() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_pix_format_mplane> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_pix_format_mplane>(),
        192usize,
        concat!("Size of: ", stringify!(v4l2_pix_format_mplane))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_pix_format_mplane>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_pix_format_mplane))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelformat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plane_fmt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(plane_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_planes) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(num_planes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        181usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantization) as usize - ptr as usize },
        183usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(quantization)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xfer_func) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(xfer_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        185usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_pix_format_mplane),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_sdr_format {
    pub pixelformat: __u32,
    pub buffersize: __u32,
    pub reserved: [__u8; 24usize],
}
#[test]
fn bindgen_test_layout_v4l2_sdr_format() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_sdr_format> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_sdr_format>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_sdr_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_sdr_format>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_sdr_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelformat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sdr_format),
            "::",
            stringify!(pixelformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffersize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sdr_format),
            "::",
            stringify!(buffersize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_sdr_format),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_meta_format {
    pub dataformat: __u32,
    pub buffersize: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_meta_format() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_meta_format> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_meta_format>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_meta_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_meta_format>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_meta_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataformat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_meta_format),
            "::",
            stringify!(dataformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffersize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_meta_format),
            "::",
            stringify!(buffersize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_format {
    pub type_: __u32,
    pub fmt: v4l2_format__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_format__bindgen_ty_1 {
    pub pix: v4l2_pix_format,
    pub pix_mp: v4l2_pix_format_mplane,
    pub win: v4l2_window,
    pub vbi: v4l2_vbi_format,
    pub sliced: v4l2_sliced_vbi_format,
    pub sdr: v4l2_sdr_format,
    pub meta: v4l2_meta_format,
    pub raw_data: [__u8; 200usize],
}
#[test]
fn bindgen_test_layout_v4l2_format__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_format__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_format__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(v4l2_format__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_format__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_format__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix_mp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(pix_mp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).win) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(win)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vbi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(vbi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(sliced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(sdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format__bindgen_ty_1),
            "::",
            stringify!(raw_data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_format() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_format> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_format>(),
        208usize,
        concat!("Size of: ", stringify!(v4l2_format))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_format>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_format))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_format),
            "::",
            stringify!(fmt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_streamparm {
    pub type_: __u32,
    pub parm: v4l2_streamparm__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_streamparm__bindgen_ty_1 {
    pub capture: v4l2_captureparm,
    pub output: v4l2_outputparm,
    pub raw_data: [__u8; 200usize],
}
#[test]
fn bindgen_test_layout_v4l2_streamparm__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_streamparm__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_streamparm__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(v4l2_streamparm__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_streamparm__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_streamparm__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm__bindgen_ty_1),
            "::",
            stringify!(capture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm__bindgen_ty_1),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm__bindgen_ty_1),
            "::",
            stringify!(raw_data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_streamparm() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_streamparm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_streamparm>(),
        204usize,
        concat!("Size of: ", stringify!(v4l2_streamparm))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_streamparm>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_streamparm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parm) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_streamparm),
            "::",
            stringify!(parm)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_vsync {
    pub field: __u8,
}
#[test]
fn bindgen_test_layout_v4l2_event_vsync() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event_vsync> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_vsync>(),
        1usize,
        concat!("Size of: ", stringify!(v4l2_event_vsync))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_vsync>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_event_vsync))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_vsync),
            "::",
            stringify!(field)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_event_ctrl {
    pub changes: __u32,
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_event_ctrl__bindgen_ty_1,
    pub flags: __u32,
    pub minimum: __s32,
    pub maximum: __s32,
    pub step: __s32,
    pub default_value: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_event_ctrl__bindgen_ty_1 {
    pub value: __s32,
    pub value64: __s64,
}
#[test]
fn bindgen_test_layout_v4l2_event_ctrl__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event_ctrl__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_ctrl__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(v4l2_event_ctrl__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_ctrl__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_event_ctrl__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl__bindgen_ty_1),
            "::",
            stringify!(value64)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_event_ctrl() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event_ctrl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_ctrl>(),
        40usize,
        concat!("Size of: ", stringify!(v4l2_event_ctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_ctrl>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_event_ctrl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(changes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_ctrl),
            "::",
            stringify!(default_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_frame_sync {
    pub frame_sequence: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_event_frame_sync() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event_frame_sync> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_frame_sync>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_event_frame_sync))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_frame_sync>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_event_frame_sync))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_frame_sync),
            "::",
            stringify!(frame_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_src_change {
    pub changes: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_event_src_change() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event_src_change> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_src_change>(),
        4usize,
        concat!("Size of: ", stringify!(v4l2_event_src_change))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_src_change>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_event_src_change))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_src_change),
            "::",
            stringify!(changes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_motion_det {
    pub flags: __u32,
    pub frame_sequence: __u32,
    pub region_mask: __u32,
}
#[test]
fn bindgen_test_layout_v4l2_event_motion_det() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event_motion_det> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_motion_det>(),
        12usize,
        concat!("Size of: ", stringify!(v4l2_event_motion_det))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_motion_det>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_event_motion_det))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_motion_det),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_sequence) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_motion_det),
            "::",
            stringify!(frame_sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).region_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_motion_det),
            "::",
            stringify!(region_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_event {
    pub type_: __u32,
    pub u: v4l2_event__bindgen_ty_1,
    pub pending: __u32,
    pub sequence: __u32,
    pub timestamp: timespec,
    pub id: __u32,
    pub reserved: [__u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_event__bindgen_ty_1 {
    pub vsync: v4l2_event_vsync,
    pub ctrl: v4l2_event_ctrl,
    pub frame_sync: v4l2_event_frame_sync,
    pub src_change: v4l2_event_src_change,
    pub motion_det: v4l2_event_motion_det,
    pub data: [__u8; 64usize],
}
#[test]
fn bindgen_test_layout_v4l2_event__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(v4l2_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsync) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(vsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_sync) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(frame_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src_change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(src_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).motion_det) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(motion_det)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_event() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event>(),
        136usize,
        concat!("Size of: ", stringify!(v4l2_event))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct v4l2_event_subscription {
    pub type_: __u32,
    pub id: __u32,
    pub flags: __u32,
    pub reserved: [__u32; 5usize],
}
#[test]
fn bindgen_test_layout_v4l2_event_subscription() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_event_subscription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_event_subscription>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_event_subscription))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_event_subscription>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_event_subscription))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_subscription),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_subscription),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_subscription),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_event_subscription),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_match {
    pub type_: __u32,
    pub __bindgen_anon_1: v4l2_dbg_match__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union v4l2_dbg_match__bindgen_ty_1 {
    pub addr: __u32,
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_dbg_match__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_dbg_match__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_dbg_match__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(v4l2_dbg_match__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dbg_match__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(v4l2_dbg_match__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_match__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_match__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_v4l2_dbg_match() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_dbg_match> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_dbg_match>(),
        36usize,
        concat!("Size of: ", stringify!(v4l2_dbg_match))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dbg_match>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_dbg_match))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_match),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_register {
    pub match_: v4l2_dbg_match,
    pub size: __u32,
    pub reg: __u64,
    pub val: __u64,
}
#[test]
fn bindgen_test_layout_v4l2_dbg_register() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_dbg_register> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_dbg_register>(),
        56usize,
        concat!("Size of: ", stringify!(v4l2_dbg_register))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dbg_register>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_dbg_register))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_register),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_register),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_register),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_register),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct v4l2_dbg_chip_info {
    pub match_: v4l2_dbg_match,
    pub name: [::std::os::raw::c_char; 32usize],
    pub flags: __u32,
    pub reserved: [__u32; 32usize],
}
#[test]
fn bindgen_test_layout_v4l2_dbg_chip_info() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_dbg_chip_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_dbg_chip_info>(),
        200usize,
        concat!("Size of: ", stringify!(v4l2_dbg_chip_info))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_dbg_chip_info>(),
        1usize,
        concat!("Alignment of ", stringify!(v4l2_dbg_chip_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).match_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_chip_info),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_chip_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_chip_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_dbg_chip_info),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct v4l2_create_buffers {
    pub index: __u32,
    pub count: __u32,
    pub memory: __u32,
    pub format: v4l2_format,
    pub capabilities: __u32,
    pub reserved: [__u32; 7usize],
}
#[test]
fn bindgen_test_layout_v4l2_create_buffers() {
    const UNINIT: ::std::mem::MaybeUninit<v4l2_create_buffers> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<v4l2_create_buffers>(),
        256usize,
        concat!("Size of: ", stringify!(v4l2_create_buffers))
    );
    assert_eq!(
        ::std::mem::align_of::<v4l2_create_buffers>(),
        8usize,
        concat!("Alignment of ", stringify!(v4l2_create_buffers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(v4l2_create_buffers),
            "::",
            stringify!(reserved)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = "< Video Source"]
pub const IMPDeviceID_DEV_ID_FS: IMPDeviceID = 0;
#[doc = "< Encoder"]
pub const IMPDeviceID_DEV_ID_ENC: IMPDeviceID = 1;
#[doc = "< Decoder"]
pub const IMPDeviceID_DEV_ID_DEC: IMPDeviceID = 2;
#[doc = "< Algorithm"]
pub const IMPDeviceID_DEV_ID_IVS: IMPDeviceID = 3;
#[doc = "< Image Overlay"]
pub const IMPDeviceID_DEV_ID_OSD: IMPDeviceID = 4;
#[doc = "< FB FG1Direct"]
pub const IMPDeviceID_DEV_ID_FG1DIRECT: IMPDeviceID = 5;
pub const IMPDeviceID_DEV_ID_RESERVED_START: IMPDeviceID = 6;
pub const IMPDeviceID_DEV_ID_RESERVED_END: IMPDeviceID = 23;
pub const IMPDeviceID_NR_MAX_DEVICES: IMPDeviceID = 24;
#[doc = " IMP Device ID enumeration definition"]
pub type IMPDeviceID = ::std::os::raw::c_uint;
#[doc = " IMPCell enumeration definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPCell {
    #[doc = "< Device ID"]
    pub deviceID: IMPDeviceID,
    #[doc = "< Group ID"]
    pub groupID: ::std::os::raw::c_int,
    #[doc = "< output ID"]
    pub outputID: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPCell() {
    const UNINIT: ::std::mem::MaybeUninit<IMPCell> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPCell>(),
        12usize,
        concat!("Size of: ", stringify!(IMPCell))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPCell>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPCell))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPCell),
            "::",
            stringify!(deviceID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).groupID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPCell),
            "::",
            stringify!(groupID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPCell),
            "::",
            stringify!(outputID)
        )
    );
}
#[doc = " IMP frame image information definition"]
#[repr(C)]
#[derive(Debug)]
pub struct IMPFrameInfo {
    #[doc = "< frame index"]
    pub index: ::std::os::raw::c_int,
    #[doc = "< frame Pool's ID"]
    pub pool_idx: ::std::os::raw::c_int,
    #[doc = "< frame's width"]
    pub width: u32,
    #[doc = "< frame's height"]
    pub height: u32,
    #[doc = "< frame's image format"]
    pub pixfmt: u32,
    #[doc = "< frame's occupied space"]
    pub size: u32,
    #[doc = "< frame's physical address"]
    pub phyAddr: u32,
    #[doc = "< frame's virtual address"]
    pub virAddr: u32,
    #[doc = "<  frame time stamp"]
    pub timeStamp: i64,
    pub rotate_osdflag: ::std::os::raw::c_int,
    pub priv_: __IncompleteArrayField<u32>,
}
#[test]
fn bindgen_test_layout_IMPFrameInfo() {
    const UNINIT: ::std::mem::MaybeUninit<IMPFrameInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPFrameInfo>(),
        48usize,
        concat!("Size of: ", stringify!(IMPFrameInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPFrameInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPFrameInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pool_idx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(pool_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixfmt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(pixfmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phyAddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(phyAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virAddr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(virAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rotate_osdflag) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(rotate_osdflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameInfo),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " IMP Frame time parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFrameTimestamp {
    #[doc = "< time"]
    pub ts: u64,
    #[doc = "< time to min"]
    pub minus: u64,
    #[doc = "< max to time"]
    pub plus: u64,
}
#[test]
fn bindgen_test_layout_IMPFrameTimestamp() {
    const UNINIT: ::std::mem::MaybeUninit<IMPFrameTimestamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPFrameTimestamp>(),
        24usize,
        concat!("Size of: ", stringify!(IMPFrameTimestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPFrameTimestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPFrameTimestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameTimestamp),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameTimestamp),
            "::",
            stringify!(minus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFrameTimestamp),
            "::",
            stringify!(plus)
        )
    );
}
#[doc = "< JPEG image protocol type"]
pub const IMPPayloadType_PT_JPEG: IMPPayloadType = 0;
#[doc = "< H264 video protocol type"]
pub const IMPPayloadType_PT_H264: IMPPayloadType = 1;
#[doc = "< H265 video protocol type"]
pub const IMPPayloadType_PT_H265: IMPPayloadType = 2;
#[doc = " Encoding and decoding protocol type"]
pub type IMPPayloadType = ::std::os::raw::c_uint;
#[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
pub const IMPPixelFormat_PIX_FMT_YUV420P: IMPPixelFormat = 0;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
pub const IMPPixelFormat_PIX_FMT_YUYV422: IMPPixelFormat = 1;
#[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
pub const IMPPixelFormat_PIX_FMT_UYVY422: IMPPixelFormat = 2;
#[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const IMPPixelFormat_PIX_FMT_YUV422P: IMPPixelFormat = 3;
#[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
pub const IMPPixelFormat_PIX_FMT_YUV444P: IMPPixelFormat = 4;
#[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
pub const IMPPixelFormat_PIX_FMT_YUV410P: IMPPixelFormat = 5;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
pub const IMPPixelFormat_PIX_FMT_YUV411P: IMPPixelFormat = 6;
#[doc = "<\t   Y\t    ,  8bpp"]
pub const IMPPixelFormat_PIX_FMT_GRAY8: IMPPixelFormat = 7;
#[doc = "<\t   Y\t    ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
pub const IMPPixelFormat_PIX_FMT_MONOWHITE: IMPPixelFormat = 8;
#[doc = "<\t   Y\t    ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
pub const IMPPixelFormat_PIX_FMT_MONOBLACK: IMPPixelFormat = 9;
#[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const IMPPixelFormat_PIX_FMT_NV12: IMPPixelFormat = 10;
#[doc = "< as above, but U and V bytes are swapped"]
pub const IMPPixelFormat_PIX_FMT_NV21: IMPPixelFormat = 11;
#[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
pub const IMPPixelFormat_PIX_FMT_RGB24: IMPPixelFormat = 12;
#[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
pub const IMPPixelFormat_PIX_FMT_BGR24: IMPPixelFormat = 13;
#[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
pub const IMPPixelFormat_PIX_FMT_ARGB: IMPPixelFormat = 14;
#[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
pub const IMPPixelFormat_PIX_FMT_RGBA: IMPPixelFormat = 15;
#[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
pub const IMPPixelFormat_PIX_FMT_ABGR: IMPPixelFormat = 16;
#[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
pub const IMPPixelFormat_PIX_FMT_BGRA: IMPPixelFormat = 17;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)\t  5R 6G 5B(lsb), big-endian"]
pub const IMPPixelFormat_PIX_FMT_RGB565BE: IMPPixelFormat = 18;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)\t  5R 6G 5B(lsb), little-endian"]
pub const IMPPixelFormat_PIX_FMT_RGB565LE: IMPPixelFormat = 19;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), big-endian, most significant bit to 0"]
pub const IMPPixelFormat_PIX_FMT_RGB555BE: IMPPixelFormat = 20;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), little-endian, most significant bit to 0"]
pub const IMPPixelFormat_PIX_FMT_RGB555LE: IMPPixelFormat = 21;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)\t 5B 6G 5R(lsb), big-endian"]
pub const IMPPixelFormat_PIX_FMT_BGR565BE: IMPPixelFormat = 22;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)\t 5B 6G 5R(lsb), little-endian"]
pub const IMPPixelFormat_PIX_FMT_BGR565LE: IMPPixelFormat = 23;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), big-endian, most significant bit to 1"]
pub const IMPPixelFormat_PIX_FMT_BGR555BE: IMPPixelFormat = 24;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), little-endian, most significant bit to 1"]
pub const IMPPixelFormat_PIX_FMT_BGR555LE: IMPPixelFormat = 25;
#[doc = "< packed RGB 8:8:8, 32bpp, 0RGB0RGB..."]
pub const IMPPixelFormat_PIX_FMT_0RGB: IMPPixelFormat = 26;
#[doc = "< packed RGB 8:8:8, 32bpp, RGB0RGB0..."]
pub const IMPPixelFormat_PIX_FMT_RGB0: IMPPixelFormat = 27;
#[doc = "< packed BGR 8:8:8, 32bpp, 0BGR0BGR..."]
pub const IMPPixelFormat_PIX_FMT_0BGR: IMPPixelFormat = 28;
#[doc = "< packed BGR 8:8:8, 32bpp, BGR0BGR0..."]
pub const IMPPixelFormat_PIX_FMT_BGR0: IMPPixelFormat = 29;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
pub const IMPPixelFormat_PIX_FMT_BAYER_BGGR8: IMPPixelFormat = 30;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
pub const IMPPixelFormat_PIX_FMT_BAYER_RGGB8: IMPPixelFormat = 31;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
pub const IMPPixelFormat_PIX_FMT_BAYER_GBRG8: IMPPixelFormat = 32;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
pub const IMPPixelFormat_PIX_FMT_BAYER_GRBG8: IMPPixelFormat = 33;
pub const IMPPixelFormat_PIX_FMT_RAW: IMPPixelFormat = 34;
pub const IMPPixelFormat_PIX_FMT_HSV: IMPPixelFormat = 35;
#[doc = "< number of pixel formats."]
pub const IMPPixelFormat_PIX_FMT_NB: IMPPixelFormat = 36;
#[doc = " IMP image format definition."]
pub type IMPPixelFormat = ::std::os::raw::c_uint;
#[doc = " IMP point coordinate information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPPoint {
    #[doc = "< X-axis"]
    pub x: ::std::os::raw::c_int,
    #[doc = "< Y-axis"]
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPPoint() {
    const UNINIT: ::std::mem::MaybeUninit<IMPPoint> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPPoint>(),
        8usize,
        concat!("Size of: ", stringify!(IMPPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPPoint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPPoint),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " IMP Rectangle area information\n\n According to the image down there, if P0(100,100) is the start point, and we'd like that the width and height are both 100，then P1(199,199)\n width = abs(P1.x-P0.x)+1   height = abs(P1.y-P0.y)+1, Point coordinates are both equal to distance +1.\n P0(100,100) _____100______\n            |              |\n            |              |\n         100|              |\n            |              |\n            |______________|\n                           P1(199,199)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPRect {
    #[doc = "<Upper left corner coordinate information"]
    pub p0: IMPPoint,
    #[doc = "<Lower right corner coordinate information"]
    pub p1: IMPPoint,
}
#[test]
fn bindgen_test_layout_IMPRect() {
    const UNINIT: ::std::mem::MaybeUninit<IMPRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPRect>(),
        16usize,
        concat!("Size of: ", stringify!(IMPRect))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPRect>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPRect),
            "::",
            stringify!(p0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPRect),
            "::",
            stringify!(p1)
        )
    );
}
#[doc = " Attribute of Decoder"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderAttr {
    #[doc = "< Stream payload type"]
    pub decType: IMPPayloadType,
    #[doc = "< Max width of frame"]
    pub maxWidth: u32,
    #[doc = "< Max hight of frame"]
    pub maxHeight: u32,
    #[doc = "< Pixel format of Output frame"]
    pub pixelFormat: IMPPixelFormat,
    #[doc = "< Number of frames in Decoder FIFO"]
    pub nrKeepStream: u32,
    #[doc = "< The number of time units within a second, time unitis its unit. The numerator of framerate"]
    pub frmRateNum: u32,
    #[doc = "< The number of time units in a frame, time unit is its unit. The denominator of framerate"]
    pub frmRateDen: u32,
}
#[test]
fn bindgen_test_layout_IMPDecoderAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPDecoderAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPDecoderAttr>(),
        28usize,
        concat!("Size of: ", stringify!(IMPDecoderAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPDecoderAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPDecoderAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderAttr),
            "::",
            stringify!(decType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxWidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderAttr),
            "::",
            stringify!(maxWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxHeight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderAttr),
            "::",
            stringify!(maxHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderAttr),
            "::",
            stringify!(pixelFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrKeepStream) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderAttr),
            "::",
            stringify!(nrKeepStream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frmRateNum) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderAttr),
            "::",
            stringify!(frmRateNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frmRateDen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderAttr),
            "::",
            stringify!(frmRateDen)
        )
    );
}
#[doc = " Attribute of Decoder Channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderCHNAttr {
    #[doc = "< Decoder attribute"]
    pub decAttr: IMPDecoderAttr,
}
#[test]
fn bindgen_test_layout_IMPDecoderCHNAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPDecoderCHNAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPDecoderCHNAttr>(),
        28usize,
        concat!("Size of: ", stringify!(IMPDecoderCHNAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPDecoderCHNAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPDecoderCHNAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decAttr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderCHNAttr),
            "::",
            stringify!(decAttr)
        )
    );
}
#[doc = " Attribute of decode frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderNal {
    #[doc = "< Length of decode frame"]
    pub i_payload: ::std::os::raw::c_int,
    #[doc = "< Pointer to decode frame"]
    pub p_payload: *mut u8,
    #[doc = "< Timestamp of decode frame"]
    pub timeStamp: i64,
}
#[test]
fn bindgen_test_layout_IMPDecoderNal() {
    const UNINIT: ::std::mem::MaybeUninit<IMPDecoderNal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPDecoderNal>(),
        24usize,
        concat!("Size of: ", stringify!(IMPDecoderNal))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPDecoderNal>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPDecoderNal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i_payload) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderNal),
            "::",
            stringify!(i_payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderNal),
            "::",
            stringify!(p_payload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderNal),
            "::",
            stringify!(timeStamp)
        )
    );
}
#[doc = " Attribute of decode stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDecoderStream {
    #[doc = "< decode stream data structure"]
    pub decoderNal: IMPDecoderNal,
}
#[test]
fn bindgen_test_layout_IMPDecoderStream() {
    const UNINIT: ::std::mem::MaybeUninit<IMPDecoderStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPDecoderStream>(),
        24usize,
        concat!("Size of: ", stringify!(IMPDecoderStream))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPDecoderStream>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPDecoderStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoderNal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDecoderStream),
            "::",
            stringify!(decoderNal)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_CreateChn(int decChn, const IMPDecoderCHNAttr *attr)\n\n Create Decoder channel.\n\n @param[in] decChn Channel Num. Value range: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] attr Pointer to Decoder Channel attribute\n\n @retval 0 Success\n @retval OtherValues Failure\n\n @remarks None.\n @attention None."]
    pub fn IMP_Decoder_CreateChn(
        decChn: ::std::os::raw::c_int,
        attr: *const IMPDecoderCHNAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_DestroyChn(int decChn)\n\n Destroy Decoder channel.\n\n @param[in] decChn Channel Num. Value range: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 Success\n @retval OtherValues Failure\n\n @remarks None.\n @attention None."]
    pub fn IMP_Decoder_DestroyChn(decChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_StartRecvPic(int decChn)\n\n Decoder channel start recieve pictures.\n\n @param[in] decChn Channel Num. Value range: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 Success\n @retval OtherValues Failure\n\n @remarks First Open decoding Channel to receive the image then start decoding.\n\n @attention Failed if the channel isn't created."]
    pub fn IMP_Decoder_StartRecvPic(decChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_StopRecvPic(int decChn)\n\n Decoder channel stop recieve pictures.\n\n @param[in] decChn Channel Num. Value range: [0, @ref NR_MAX_DEC_CHN - 1]\n\n @retval 0 Success\n @retval OtherValues Failure\n\n @remarks Stop decoding the Channel to receive image.\n\n @attention Failed if the channel isn't created."]
    pub fn IMP_Decoder_StopRecvPic(decChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_SendStreamTimeout(int decChn, IMPDecoderStream *stream, uint32_t timeoutMsec)\n\n Send frame to Decoder channel.\n\n @param[in] decChn Channel Num. Value range: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] stream Pointer to the Data stream structure to be decoded\n @param[in] timeoutMsec Decode timeout value(msec).\n\n @retval 0 Success\n @retval OtherValues Failure\n\n @remarks None.\n\n @attention Failed if the channel isn't created."]
    pub fn IMP_Decoder_SendStreamTimeout(
        decChn: ::std::os::raw::c_int,
        stream: *mut IMPDecoderStream,
        timeoutMsec: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_PollingFrame(int decChn, uint32_t timeoutMsec)\n\n Polling Decoder channel, return when decoding finished or timeout.\n\n @param[in] decChn Channel Num. Value range: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] timeoutMsec Wait timeout value(msec).\n\n @retval 0 Success\n @retval OtherValues Failure\n\n @remarks None.\n\n @attention Failed if the channel isn't created."]
    pub fn IMP_Decoder_PollingFrame(
        decChn: ::std::os::raw::c_int,
        timeoutMsec: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_GetFrame(int decChn, IMPFrameInfo **frame)\n\n Get the decoded output frame.\n\n @param[in] decChn Channel Num. Value range: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[out] frame Pointer to output frame's pointer\n\n @retval 0 Success\n @retval OtherValues Failure\n\n @remarks None.\n\n @attention The memory of output buffer is malloced in Decoder, So the input argument is a pointer of a pointer(pointer's address).\n\nThe decoding stream buffer is applied by the decoder, and the current function only needs to be introduced into the structure body pointer."]
    pub fn IMP_Decoder_GetFrame(
        decChn: ::std::os::raw::c_int,
        frame: *mut *mut IMPFrameInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Decoder_ReleaseFrame(int decChn, IMPFrameInfo *frame)\n\n Release the decoded output frame.\n\n @param[in] decChn Channel Num. Value range: [0, @ref NR_MAX_DEC_CHN - 1]\n @param[in] frame Pointer to output frame\n\n @retval 0 Success\n @retval OtherValues Failure\n\n @remarks None.\n\n @attention None."]
    pub fn IMP_Decoder_ReleaseFrame(
        decChn: ::std::os::raw::c_int,
        frame: *mut IMPFrameInfo,
    ) -> ::std::os::raw::c_int;
}
pub const IMPDmicSampleRate_DMIC_SAMPLE_RATE_8000: IMPDmicSampleRate = 8000;
#[doc = "8KHz sampling rate"]
pub const IMPDmicSampleRate_DMIC_SAMPLE_RATE_16000: IMPDmicSampleRate = 16000;
pub type IMPDmicSampleRate = ::std::os::raw::c_uint;
#[doc = "<16 bit sampling precision"]
pub const IMPDmicBitWidth_DMIC_BIT_WIDTH_16: IMPDmicBitWidth = 16;
pub type IMPDmicBitWidth = ::std::os::raw::c_uint;
pub const IMPDmicSoundMode_DMIC_SOUND_MODE_MONO: IMPDmicSoundMode = 1;
pub const IMPDmicSoundMode_DMIC_SOUND_MODE_STEREO: IMPDmicSoundMode = 2;
pub type IMPDmicSoundMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDmicAttr {
    #[doc = "< DMIC sampling rate"]
    pub samplerate: IMPDmicSampleRate,
    #[doc = "<DMIC sampling precision"]
    pub bitwidth: IMPDmicBitWidth,
    pub soundmode: IMPDmicSoundMode,
    pub frmNum: ::std::os::raw::c_int,
    pub numPerFrm: ::std::os::raw::c_int,
    pub chnCnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPDmicAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPDmicAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPDmicAttr>(),
        24usize,
        concat!("Size of: ", stringify!(IMPDmicAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPDmicAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPDmicAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplerate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicAttr),
            "::",
            stringify!(samplerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitwidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicAttr),
            "::",
            stringify!(bitwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).soundmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicAttr),
            "::",
            stringify!(soundmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frmNum) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicAttr),
            "::",
            stringify!(frmNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numPerFrm) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicAttr),
            "::",
            stringify!(numPerFrm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chnCnt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicAttr),
            "::",
            stringify!(chnCnt)
        )
    );
}
#[doc = "DMIC frame structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDmicFrame {
    pub bitwidth: IMPDmicBitWidth,
    pub soundmode: IMPDmicSoundMode,
    pub virAddr: *mut u32,
    pub phyAddr: u32,
    pub timeStamp: i64,
    pub seq: ::std::os::raw::c_int,
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPDmicFrame() {
    const UNINIT: ::std::mem::MaybeUninit<IMPDmicFrame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPDmicFrame>(),
        40usize,
        concat!("Size of: ", stringify!(IMPDmicFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPDmicFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPDmicFrame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitwidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicFrame),
            "::",
            stringify!(bitwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).soundmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicFrame),
            "::",
            stringify!(soundmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virAddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicFrame),
            "::",
            stringify!(virAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phyAddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicFrame),
            "::",
            stringify!(phyAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicFrame),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicFrame),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicFrame),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDmicChnFrame {
    pub rawFrame: IMPDmicFrame,
    pub aecFrame: IMPDmicFrame,
}
#[test]
fn bindgen_test_layout_IMPDmicChnFrame() {
    const UNINIT: ::std::mem::MaybeUninit<IMPDmicChnFrame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPDmicChnFrame>(),
        80usize,
        concat!("Size of: ", stringify!(IMPDmicChnFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPDmicChnFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPDmicChnFrame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rawFrame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicChnFrame),
            "::",
            stringify!(rawFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aecFrame) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicChnFrame),
            "::",
            stringify!(aecFrame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPDmicChnParam {
    #[doc = "<DMIC audio frame buffer depth"]
    pub usrFrmDepth: ::std::os::raw::c_int,
    #[doc = "<retain"]
    pub Rev: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPDmicChnParam() {
    const UNINIT: ::std::mem::MaybeUninit<IMPDmicChnParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPDmicChnParam>(),
        8usize,
        concat!("Size of: ", stringify!(IMPDmicChnParam))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPDmicChnParam>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPDmicChnParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usrFrmDepth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicChnParam),
            "::",
            stringify!(usrFrmDepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPDmicChnParam),
            "::",
            stringify!(Rev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DmicXInfo {
    pub dmic_id: ::std::os::raw::c_int,
    pub dmic_en: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DmicXInfo() {
    const UNINIT: ::std::mem::MaybeUninit<DmicXInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DmicXInfo>(),
        8usize,
        concat!("Size of: ", stringify!(DmicXInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<DmicXInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(DmicXInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmic_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DmicXInfo),
            "::",
            stringify!(dmic_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmic_en) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DmicXInfo),
            "::",
            stringify!(dmic_en)
        )
    );
}
extern "C" {
    #[doc = "@int IMP_DMIC_SetUserInfo(int dmicDevId, int aecDmicId, int need_aec);\nSet up information about the user requirements of the MAC array;\n @param[in] dmicDevId  MAC array device number.\n @param[in] aecDmicId  Dmic ID number of MAC array as aec processing.\n @param[in] need_aec   Whether the user needs to do echo cancellation.(need_aec: 0:no need 1:need)\n @retval 0 success\n @retval non-0 failure."]
    pub fn IMP_DMIC_SetUserInfo(
        dmicDevId: ::std::os::raw::c_int,
        aecDmicId: ::std::os::raw::c_int,
        need_aec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn int IMP_DMIC_SetPubAttr(int dmicDevId, IMPDmicAttr *attr);\nSet MAC array input device attribute.\n @param[in] dmicDevId  MAC array audio device number.\n @param[in] attr  MAC array audio device attribute pointer\n\n @retval 0 success\n @retval non-0 failure.\n\n @attention Need to be called before IMP_DMIC_Enable."]
    pub fn IMP_DMIC_SetPubAttr(
        dmicDevId: ::std::os::raw::c_int,
        attr: *mut IMPDmicAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn int IMP_DMIC_GetPubAttr(int dmicDevId, IMPDmicAttr *attr);\n\nGet MAC array input device attribute.\n @param[in] dmicDevId  MAC array audio device number.\n @param[in] attr  MAC array audio device attribute pointer\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_DMIC_GetPubAttr(
        dmicDevId: ::std::os::raw::c_int,
        attr: *mut IMPDmicAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn int IMP_DMIC_Enable(int dmicDevId);\n\n Enable microphone array audio input device;\n Enable MAC array audio device.\n @param[in] dmicDevId MAC array audio device number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_DMIC_Enable(dmicDevId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn int IMP_DMIC_Disable(int dmicDevId);\n\n Diable MAC array audio device.\n @param[in] dmicDevId MAC array audio device number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention none."]
    pub fn IMP_DMIC_Disable(dmicDevId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn int IMP_DMIC_EnableChn(int dmicDevId, int dmicChnId);\n\n Enable MAC arrayu audio channel\n\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n\n @retval 0 success.\n @retval non-0 failure\n\n @remarks no.\n\n @attention Must first enable MAC array device."]
    pub fn IMP_DMIC_EnableChn(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn int IMP_DMIC_DisableChn(int dmicDevId, int dmicChnId);\n\n Disable MAC array audio channel\n\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n\n @retval 0 success.\n @retval non-0 failure\n @remarks no.\n\n @attention It supports the use of IMP_DMIC_EnableChn."]
    pub fn IMP_DMIC_DisableChn(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn int IMP_DMIC_SetChnParam(int dmicDevId, int dmicChnId, IMPDmicChnParam *chnParam);\n\n Set MAC array audio channel parameters.\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n @param[in] chnParam MAC array channel frame structure pointer.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks none.\n\n @attention Supporting the use of IMP_DMIC_EnableChn."]
    pub fn IMP_DMIC_SetChnParam(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        chnParam: *mut IMPDmicChnParam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@fn int IMP_DMIC_GetChnParam(int dmicDevId, int dmicChnId, IMPDmicChnParam *chnParam);\n\n Set MAC array audio channel parameters.\n\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n @param[in] chnParam MAC array channel frame structure pointer.\n\n @retval 0 success.\n @retval non-0 failure.\n @remarks no.\n\n @attention no."]
    pub fn IMP_DMIC_GetChnParam(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        chnParam: *mut IMPDmicChnParam,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_DMIC_GetFrame(int dmicDevId, int dmicChnId, IMPDmicChnFrame *chnFrm, IMPBlock block);\n\n Get Mac array channel audio frame.\n\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n @param[out] chnFrm   MAC array channel audio frame structure pointer.\n @param[in] block block Blocking / non blocking identifier.\n\n @retval 0 success.\n @retval non-0 failure."]
    pub fn IMP_DMIC_GetFrame(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        chnFrm: *mut IMPDmicChnFrame,
        block: IMPBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_DMIC_ReleaseFrame(int dmicDevId, int dmicChnId, IMPDmicChnFrame *chnFrm);\n\n Release Mac array channel audio frame.\n\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n @param[out] chnFrm   MAC array channel audio frame structure pointer.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention It supports the use of IMP_DMIC_GetFrame."]
    pub fn IMP_DMIC_ReleaseFrame(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        chnFrm: *mut IMPDmicChnFrame,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_DMIC_EnableAecRefFrame(int dmicDevId, int dmicChnId, int audioAoDevId, int aoChn);\n\n Open access reference frame.\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n @param[out] audioAoDevId audio output device number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks Use this current interface before using IMP_DMIC_GetFrameAndRef.\n\n @attention no."]
    pub fn IMP_DMIC_EnableAecRefFrame(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        audioAoDevId: ::std::os::raw::c_int,
        aoChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_DMIC_GetFrameAndRef(int dmicDevId, int dmicChnId, IMPDmicChnFrame *chnFrm, IMPDmicFrame *ref, IMPBlock block);\n Get audio frame and output reference frame.\n\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n @param[out] chnFrm   MAC array channel audio frame structure pointer.\n @param[out] ref reference frame structure pointer.\n @param[in] block block Blocking / non blocking identifier.\n\n @retval 0 success.\n @retval non-0 failure."]
    pub fn IMP_DMIC_GetFrameAndRef(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        chnFrm: *mut IMPDmicChnFrame,
        ref_: *mut IMPDmicFrame,
        block: IMPBlock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_DMIC_EnableAec(int dmicDevId, int dmicChnId, int aoDevId, int aoChId);\n\n Enable audio echo cancellation feature of the specified audio input and audio output.\n\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n @param[in] aoDevId Need to perform audio echo cancellation of the audio output device number.\n @param[in] aoChn Need to perform audio echo cancellation of the audio output channel number.\n @retval 0 success.\n @retval non-0 failure."]
    pub fn IMP_DMIC_EnableAec(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        aoDevId: ::std::os::raw::c_int,
        aoChId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_DMIC_PollingFrame(int dmicDevId, int dmicChnId, unsigned int timeout_ms);\n Polling encoded audio stream cache.\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number\n @param[in] timeout_ms Polling timeout time.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention Use the interface before using IMP_DMIC_GetFrame, and when the interface is called successfully, then the audio data is ready, and you can use IMP_DMIC_GetFrame to get audio data.\n"]
    pub fn IMP_DMIC_DisableAec(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_DMIC_DisableAec(int dmicDevId, int dmicChnId);\n close AEC function.\n @param[in] dmicDevId MAC array audio device number.\n @param[in] dmicChnId MAC array audio channel number.\n\n @retval 0 success.\n @retval non-0 failure.\n\n @remarks no.\n\n @attention IMP_DMIC_DisableAec should be matche with IMP_DMIC_EnableAec\n"]
    pub fn IMP_DMIC_PollingFrame(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        timeout_ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t@fn int IMP_DMIC_SetVol(int dmicDevId, int dmicChnId, int dmicVol);\n   Set audio input volume.\n\n   @param[in] dmicDevId MAC array audio device number.\n   @param[in] dmicChnId MAC array audio channel number\n   @param[in] dmic vol of MAC array\n   @retval 0 success.\n   @retval non-0 failure.\n\t@remarks volume in the range of [-30 ~ 120]. - 30 represents mute, 120 is to amplify the sound of to 30dB, step 0.5dB.\n\t@remarks 60 is to set the volume to a critical point. In this case, the software does not increase or decrease the volume, when the volume          value is less than 60, for each drop of 1, the volume is decreased by 0.5dB; when the volume value is greater than 60, for each rise of 1, the volume is increased by 0.5dB."]
    pub fn IMP_DMIC_SetVol(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        dmicVol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t@fn int IMP_DMIC_SetVol(int dmicDevId, int dmicChnId, int dmicVol);\n   Set audio input volume.\n\n   @param[in] dmicDevId MAC array audio device number.\n   @param[in] dmicChnId MAC array audio channel number\n   @param[out] dmic vol of MAC array.\n   @retval 0 success.\n   @retval non-0 failure.\n\t@remarks no.\n\t@attention no."]
    pub fn IMP_DMIC_GetVol(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        dmicVol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn int IMP_DMIC_SetGain(int dmicDevId, int dmicChnId, int dmicGain);\n  Set MAC array dmic input gain.\n\n   @param[in] dmicDevId MAC array audio device number.\n   @param[in] dmicChnId MAC array audio channel number\n   @param[out] dmic of MAC array input gain, range [0 ~ 31].\n\n   @retval 0 success.\n   @retval non-0 failure."]
    pub fn IMP_DMIC_SetGain(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        dmicGain: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  @fn int IMP_DMIC_GetGain(int dmicDevId, int dmicChnId, int *dmicGain);\n  Get MAC array dmic input gain.\n\n   @param[in] dmicDevId MAC array audio device number.\n   @param[in] dmicChnId MAC array audio channel number\n\t@param[out] dmicGain MAC audio input gain\n   @retval 0 success.\n   @retval non-0 failure.\n\n   @remarks no."]
    pub fn IMP_DMIC_GetGain(
        dmicDevId: ::std::os::raw::c_int,
        dmicChnId: ::std::os::raw::c_int,
        dmicGain: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Undefined"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_UNKNOWN: IMPEncoderH264NaluType = 0;
#[doc = "< A encoding strip for non IDR image"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_SLICE: IMPEncoderH264NaluType = 1;
#[doc = "< Encoding stripe data partition block A"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_SLICE_DPA: IMPEncoderH264NaluType = 2;
#[doc = "< Encoding stripe data partition block B"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_SLICE_DPB: IMPEncoderH264NaluType = 3;
#[doc = "< Encoding stripe data partition block C"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_SLICE_DPC: IMPEncoderH264NaluType = 4;
#[doc = "< Encoding strip of IDR image"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_SLICE_IDR: IMPEncoderH264NaluType = 5;
#[doc = "< SEI(Supplemental Enhancement Information)"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_SEI: IMPEncoderH264NaluType = 6;
#[doc = "< SPS(Sequence Paramater Set)"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_SPS: IMPEncoderH264NaluType = 7;
#[doc = "< PPS(Picture Paramater Set)"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_PPS: IMPEncoderH264NaluType = 8;
#[doc = "< Access unit separator"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_AUD: IMPEncoderH264NaluType = 9;
#[doc = "< Fill in data"]
pub const IMPEncoderH264NaluType_IMP_H264_NAL_FILLER: IMPEncoderH264NaluType = 12;
#[doc = " Defining the Nalu type of H.264"]
pub type IMPEncoderH264NaluType = ::std::os::raw::c_uint;
#[doc = "< Trailing image without reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_TRAIL_N: IMPEncoderH265NaluType = 0;
#[doc = "< Trailing image with reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_TRAIL_R: IMPEncoderH265NaluType = 1;
#[doc = "< Sub layer access point image in time domain without reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_TSA_N: IMPEncoderH265NaluType = 2;
#[doc = "< Sub layer access point image in time domain with reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_TSA_R: IMPEncoderH265NaluType = 3;
#[doc = "< Step by step time domain sub layer access point image without reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_STSA_N: IMPEncoderH265NaluType = 4;
#[doc = "< Step by step time domain sub layer access point image with reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_STSA_R: IMPEncoderH265NaluType = 5;
#[doc = "< The front image can be decoded randomly without reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_RADL_N: IMPEncoderH265NaluType = 6;
#[doc = "< The front image can be decoded randomly with reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_RADL_R: IMPEncoderH265NaluType = 7;
#[doc = "< Skip the front image of random access, without reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_RASL_N: IMPEncoderH265NaluType = 8;
#[doc = "< Skip the front image of random access, with reference information"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_RASL_R: IMPEncoderH265NaluType = 9;
#[doc = "< Breakpoint connection access with front image"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_BLA_W_LP: IMPEncoderH265NaluType = 16;
#[doc = "< Breakpoint connection access with front image RADL"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_BLA_W_RADL: IMPEncoderH265NaluType = 17;
#[doc = "< Breakpoint connection access without front image"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_BLA_N_LP: IMPEncoderH265NaluType = 18;
#[doc = "< Instant decoding refresh with front image RADL"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_IDR_W_RADL: IMPEncoderH265NaluType = 19;
#[doc = "< Instant decoding refresh without front image"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_IDR_N_LP: IMPEncoderH265NaluType = 20;
#[doc = "< Pure random access with front image"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SLICE_CRA: IMPEncoderH265NaluType = 21;
#[doc = "< Video Parameter Set"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_VPS: IMPEncoderH265NaluType = 32;
#[doc = "< SPS(Sequence Paramater Set)"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SPS: IMPEncoderH265NaluType = 33;
#[doc = "< PPS(Picture Paramater Set)"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_PPS: IMPEncoderH265NaluType = 34;
#[doc = "< Access unit separator"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_AUD: IMPEncoderH265NaluType = 35;
#[doc = "< End of sequence"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_EOS: IMPEncoderH265NaluType = 36;
#[doc = "< End of bitstream"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_EOB: IMPEncoderH265NaluType = 37;
#[doc = "< Fill in data"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_FILLER_DATA: IMPEncoderH265NaluType = 38;
#[doc = "< SEI(Supplemental Enhancement Information)"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_PREFIX_SEI: IMPEncoderH265NaluType = 39;
#[doc = "< SEI(Supplemental Enhancement Information)"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_SUFFIX_SEI: IMPEncoderH265NaluType = 40;
#[doc = "< Invalid nal type"]
pub const IMPEncoderH265NaluType_IMP_H265_NAL_INVALID: IMPEncoderH265NaluType = 64;
#[doc = " Defining the Nalu type of H.265"]
pub type IMPEncoderH265NaluType = ::std::os::raw::c_uint;
#[doc = " Define the nal type of H.264 and h.265 encoding channel stream"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPEncoderNalType {
    #[doc = "< H264E NALU"]
    pub h264NalType: IMPEncoderH264NaluType,
    #[doc = "< H265E NALU"]
    pub h265NalType: IMPEncoderH265NaluType,
}
#[test]
fn bindgen_test_layout_IMPEncoderNalType() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderNalType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderNalType>(),
        4usize,
        concat!("Size of: ", stringify!(IMPEncoderNalType))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderNalType>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderNalType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h264NalType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderNalType),
            "::",
            stringify!(h264NalType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h265NalType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderNalType),
            "::",
            stringify!(h265NalType)
        )
    );
}
#[doc = "< AVC SI Slice"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_SI: IMPEncoderSliceType = 4;
#[doc = "< AVC SP Slice"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_SP: IMPEncoderSliceType = 3;
#[doc = "< Golden Slice"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_GOLDEN: IMPEncoderSliceType = 3;
#[doc = "< I Slice (can contain I blocks)"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_I: IMPEncoderSliceType = 2;
#[doc = "< P Slice (can contain I and P blocks)"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_P: IMPEncoderSliceType = 1;
#[doc = "< B Slice (can contain I, P and B blocks)"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_B: IMPEncoderSliceType = 0;
#[doc = "< Conceal Slice (slice was concealed)"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_CONCEAL: IMPEncoderSliceType = 6;
#[doc = "< Skip Slice"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_SKIP: IMPEncoderSliceType = 7;
#[doc = "< Repeat Slice (repeats the content of its reference)"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_REPEAT: IMPEncoderSliceType = 8;
#[doc = "< sentinel"]
pub const IMPEncoderSliceType_IMP_ENC_SLICE_MAX_ENUM: IMPEncoderSliceType = 9;
pub type IMPEncoderSliceType = ::std::os::raw::c_uint;
#[doc = " Define the packet structure of coded frame and stream"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderPack {
    #[doc = "< Stream packet offset"]
    pub offset: u32,
    #[doc = "< Stream packet length"]
    pub length: u32,
    #[doc = "< Time stamp, unit us"]
    pub timestamp: i64,
    #[doc = "< End of frame flag"]
    pub frameEnd: bool,
    #[doc = "< Nal type of encoder channel"]
    pub nalType: IMPEncoderNalType,
    #[doc = "< Nal type of encoder slice"]
    pub sliceType: IMPEncoderSliceType,
}
#[test]
fn bindgen_test_layout_IMPEncoderPack() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderPack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderPack>(),
        32usize,
        concat!("Size of: ", stringify!(IMPEncoderPack))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderPack>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPEncoderPack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderPack),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderPack),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderPack),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameEnd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderPack),
            "::",
            stringify!(frameEnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalType) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderPack),
            "::",
            stringify!(nalType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sliceType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderPack),
            "::",
            stringify!(sliceType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderStreamInfo {
    #[doc = "< Number of bytes in the stream"]
    pub iNumBytes: i32,
    #[doc = "< Number of 8x8 blocks coded with intra mode"]
    pub uNumIntra: u32,
    #[doc = "< Number of 8x8 blocks coded with skip mode"]
    pub uNumSkip: u32,
    #[doc = "< Number of 8x8 CUs"]
    pub uNumCU8x8: u32,
    #[doc = "< Number of 16x16 CUs"]
    pub uNumCU16x16: u32,
    #[doc = "< Number of 32x32 CUs"]
    pub uNumCU32x32: u32,
    #[doc = "< Number of 64x64 CUs"]
    pub uNumCU64x64: u32,
    #[doc = "< Slice QP value"]
    pub iSliceQP: i16,
    #[doc = "< Minimum QP value"]
    pub iMinQP: i16,
    #[doc = "< Maximum QP value"]
    pub iMaxQP: i16,
}
#[test]
fn bindgen_test_layout_IMPEncoderStreamInfo() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderStreamInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderStreamInfo>(),
        36usize,
        concat!("Size of: ", stringify!(IMPEncoderStreamInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderStreamInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderStreamInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iNumBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(iNumBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uNumIntra) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(uNumIntra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uNumSkip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(uNumSkip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uNumCU8x8) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(uNumCU8x8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uNumCU16x16) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(uNumCU16x16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uNumCU32x32) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(uNumCU32x32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uNumCU64x64) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(uNumCU64x64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iSliceQP) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(iSliceQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iMinQP) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(iMinQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iMaxQP) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStreamInfo),
            "::",
            stringify!(iMaxQP)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderJpegInfo {
    #[doc = "< Number of bytes in the stream"]
    pub iNumBytes: i32,
    #[doc = "< JPEG QP param"]
    pub iQPfactor: i16,
}
#[test]
fn bindgen_test_layout_IMPEncoderJpegInfo() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderJpegInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderJpegInfo>(),
        8usize,
        concat!("Size of: ", stringify!(IMPEncoderJpegInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderJpegInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderJpegInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iNumBytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderJpegInfo),
            "::",
            stringify!(iNumBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iQPfactor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderJpegInfo),
            "::",
            stringify!(iQPfactor)
        )
    );
}
#[doc = " Define the structure of coded frame stream type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderStream {
    #[doc = "< Physical address of frame"]
    pub phyAddr: u32,
    #[doc = "< Virtual address of frame"]
    pub virAddr: u32,
    #[doc = "< Size of the allocated virtual address"]
    pub streamSize: u32,
    #[doc = "< Frame stream packet"]
    pub pack: *mut IMPEncoderPack,
    #[doc = "< The number of all packets in a frame stream"]
    pub packCount: u32,
    #[doc = "< Sequence number of coded frame"]
    pub seq: u32,
    pub isVI: bool,
    pub __bindgen_anon_1: IMPEncoderStream__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPEncoderStream__bindgen_ty_1 {
    pub streamInfo: IMPEncoderStreamInfo,
    pub jpegInfo: IMPEncoderJpegInfo,
}
#[test]
fn bindgen_test_layout_IMPEncoderStream__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderStream__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderStream__bindgen_ty_1>(),
        36usize,
        concat!("Size of: ", stringify!(IMPEncoderStream__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderStream__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderStream__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream__bindgen_ty_1),
            "::",
            stringify!(streamInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jpegInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream__bindgen_ty_1),
            "::",
            stringify!(jpegInfo)
        )
    );
}
#[test]
fn bindgen_test_layout_IMPEncoderStream() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderStream>(),
        72usize,
        concat!("Size of: ", stringify!(IMPEncoderStream))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderStream>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPEncoderStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phyAddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream),
            "::",
            stringify!(phyAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).virAddr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream),
            "::",
            stringify!(virAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream),
            "::",
            stringify!(streamSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream),
            "::",
            stringify!(pack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream),
            "::",
            stringify!(packCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isVI) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderStream),
            "::",
            stringify!(isVI)
        )
    );
}
pub const IMPEncoderEncType_IMP_ENC_TYPE_AVC: IMPEncoderEncType = 0;
pub const IMPEncoderEncType_IMP_ENC_TYPE_HEVC: IMPEncoderEncType = 1;
pub const IMPEncoderEncType_IMP_ENC_TYPE_JPEG: IMPEncoderEncType = 4;
pub type IMPEncoderEncType = ::std::os::raw::c_uint;
pub const IMPEncoderProfile_IMP_ENC_PROFILE_AVC_BASELINE: IMPEncoderProfile = 66;
pub const IMPEncoderProfile_IMP_ENC_PROFILE_AVC_MAIN: IMPEncoderProfile = 77;
pub const IMPEncoderProfile_IMP_ENC_PROFILE_AVC_HIGH: IMPEncoderProfile = 100;
pub const IMPEncoderProfile_IMP_ENC_PROFILE_HEVC_MAIN: IMPEncoderProfile = 16777217;
pub const IMPEncoderProfile_IMP_ENC_PROFILE_JPEG: IMPEncoderProfile = 67108864;
pub type IMPEncoderProfile = ::std::os::raw::c_uint;
pub const IMPEncoderPicFormat_IMP_ENC_PIC_FORMAT_400_8BITS: IMPEncoderPicFormat = 136;
pub const IMPEncoderPicFormat_IMP_ENC_PIC_FORMAT_420_8BITS: IMPEncoderPicFormat = 392;
pub const IMPEncoderPicFormat_IMP_ENC_PIC_FORMAT_422_8BITS: IMPEncoderPicFormat = 648;
pub type IMPEncoderPicFormat = ::std::os::raw::c_uint;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_QP_TAB_RELATIVE: IMPEncoderEncOptions = 1;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_FIX_PREDICTOR: IMPEncoderEncOptions = 2;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_CUSTOM_LDA: IMPEncoderEncOptions = 4;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_ENABLE_AUTO_QP: IMPEncoderEncOptions = 8;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_ADAPT_AUTO_QP: IMPEncoderEncOptions = 16;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_COMPRESS: IMPEncoderEncOptions = 32;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_FORCE_REC: IMPEncoderEncOptions = 64;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_FORCE_MV_OUT: IMPEncoderEncOptions = 128;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_HIGH_FREQ: IMPEncoderEncOptions = 8192;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_SRD: IMPEncoderEncOptions = 32768;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_FORCE_MV_CLIP: IMPEncoderEncOptions = 131072;
pub const IMPEncoderEncOptions_IMP_ENC_OPT_RDO_COST_MODE: IMPEncoderEncOptions = 262144;
pub type IMPEncoderEncOptions = ::std::os::raw::c_uint;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_WPP: IMPEncoderEncTools = 1;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_TILE: IMPEncoderEncTools = 2;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_LF: IMPEncoderEncTools = 4;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_LF_X_SLICE: IMPEncoderEncTools = 8;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_LF_X_TILE: IMPEncoderEncTools = 16;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_SCL_LST: IMPEncoderEncTools = 32;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_CONST_INTRA_PRED: IMPEncoderEncTools = 64;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_TRANSFO_SKIP: IMPEncoderEncTools = 128;
pub const IMPEncoderEncTools_IMP_ENC_TOOL_PCM: IMPEncoderEncTools = 2048;
pub type IMPEncoderEncTools = ::std::os::raw::c_uint;
#[doc = " Define encoder croping attributes, image of the input encoder is cropped first, then compared with the size of the encoding channel, and then scaled"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderCropCfg {
    #[doc = "< Crop or not, range: [FALSE, TRUE], TRUE: crop, FALSE: not crop"]
    pub enable: bool,
    #[doc = "< The x-coordinate of the upper left corner of the crop region"]
    pub x: u32,
    #[doc = "< The y-coordinate of the upper left corner of the crop region"]
    pub y: u32,
    #[doc = "< Width of Crop Region"]
    pub w: u32,
    #[doc = "< Height of Crop Region"]
    pub h: u32,
}
#[test]
fn bindgen_test_layout_IMPEncoderCropCfg() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderCropCfg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderCropCfg>(),
        20usize,
        concat!("Size of: ", stringify!(IMPEncoderCropCfg))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderCropCfg>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderCropCfg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderCropCfg),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderCropCfg),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderCropCfg),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderCropCfg),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderCropCfg),
            "::",
            stringify!(h)
        )
    );
}
pub const IMPEncoderEntropyMode_IMP_ENC_ENTROPY_MODE_CAVLC: IMPEncoderEntropyMode = 1;
pub const IMPEncoderEntropyMode_IMP_ENC_ENTROPY_MODE_CABAC: IMPEncoderEntropyMode = 2;
#[doc = " Define encoder entropy mode"]
pub type IMPEncoderEntropyMode = ::std::os::raw::c_uint;
#[doc = " Define encoder attribute structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderEncAttr {
    pub eProfile: IMPEncoderProfile,
    pub uLevel: u8,
    pub uTier: u8,
    pub uWidth: u16,
    pub uHeight: u16,
    pub ePicFormat: IMPEncoderPicFormat,
    pub eEncOptions: u32,
    pub eEncTools: u32,
    #[doc = "< Encoder croping properties"]
    pub crop: IMPEncoderCropCfg,
}
#[test]
fn bindgen_test_layout_IMPEncoderEncAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderEncAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderEncAttr>(),
        44usize,
        concat!("Size of: ", stringify!(IMPEncoderEncAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderEncAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderEncAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eProfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(eProfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uLevel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(uLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uTier) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(uTier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uWidth) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(uWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uHeight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(uHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ePicFormat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(ePicFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eEncOptions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(eEncOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eEncTools) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(eEncTools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderEncAttr),
            "::",
            stringify!(crop)
        )
    );
}
pub const IMPEncoderGopCtrlMode_IMP_ENC_GOP_CTRL_MODE_DEFAULT: IMPEncoderGopCtrlMode = 2;
pub const IMPEncoderGopCtrlMode_IMP_ENC_GOP_CTRL_MODE_PYRAMIDAL: IMPEncoderGopCtrlMode = 4;
pub const IMPEncoderGopCtrlMode_IMP_ENC_GOP_CTRL_MODE_SMARTP: IMPEncoderGopCtrlMode = 254;
pub const IMPEncoderGopCtrlMode_IMP_ENC_GOP_CTRL_MAX_ENUM: IMPEncoderGopCtrlMode = 255;
pub type IMPEncoderGopCtrlMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderGopAttr {
    pub uGopCtrlMode: IMPEncoderGopCtrlMode,
    pub uGopLength: u16,
    pub uNotifyUserLTInter: u16,
    pub uMaxSameSenceCnt: u32,
    pub bEnableLT: bool,
    pub uFreqLT: u32,
    pub bLTRC: bool,
}
#[test]
fn bindgen_test_layout_IMPEncoderGopAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderGopAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderGopAttr>(),
        24usize,
        concat!("Size of: ", stringify!(IMPEncoderGopAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderGopAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderGopAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uGopCtrlMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderGopAttr),
            "::",
            stringify!(uGopCtrlMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uGopLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderGopAttr),
            "::",
            stringify!(uGopLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uNotifyUserLTInter) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderGopAttr),
            "::",
            stringify!(uNotifyUserLTInter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMaxSameSenceCnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderGopAttr),
            "::",
            stringify!(uMaxSameSenceCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bEnableLT) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderGopAttr),
            "::",
            stringify!(bEnableLT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uFreqLT) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderGopAttr),
            "::",
            stringify!(uFreqLT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bLTRC) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderGopAttr),
            "::",
            stringify!(bLTRC)
        )
    );
}
pub const IMPEncoderRcMode_IMP_ENC_RC_MODE_FIXQP: IMPEncoderRcMode = 0;
pub const IMPEncoderRcMode_IMP_ENC_RC_MODE_CBR: IMPEncoderRcMode = 1;
pub const IMPEncoderRcMode_IMP_ENC_RC_MODE_VBR: IMPEncoderRcMode = 2;
pub const IMPEncoderRcMode_IMP_ENC_RC_MODE_CAPPED_VBR: IMPEncoderRcMode = 4;
pub const IMPEncoderRcMode_IMP_ENC_RC_MODE_CAPPED_QUALITY: IMPEncoderRcMode = 8;
pub const IMPEncoderRcMode_IMP_ENC_RC_MODE_INVALID: IMPEncoderRcMode = 255;
pub type IMPEncoderRcMode = ::std::os::raw::c_uint;
pub const IMPEncoderRcOptions_IMP_ENC_RC_OPT_NONE: IMPEncoderRcOptions = 0;
pub const IMPEncoderRcOptions_IMP_ENC_RC_SCN_CHG_RES: IMPEncoderRcOptions = 1;
pub const IMPEncoderRcOptions_IMP_ENC_RC_DELAYED: IMPEncoderRcOptions = 2;
pub const IMPEncoderRcOptions_IMP_ENC_RC_STATIC_SCENE: IMPEncoderRcOptions = 4;
pub const IMPEncoderRcOptions_IMP_ENC_RC_ENABLE_SKIP: IMPEncoderRcOptions = 8;
pub const IMPEncoderRcOptions_IMP_ENC_RC_OPT_SC_PREVENTION: IMPEncoderRcOptions = 16;
pub const IMPEncoderRcOptions_IMP_ENC_RC_MAX_ENUM: IMPEncoderRcOptions = 17;
pub type IMPEncoderRcOptions = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrFixQP {
    pub iInitialQP: i16,
}
#[test]
fn bindgen_test_layout_IMPEncoderAttrFixQP() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderAttrFixQP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderAttrFixQP>(),
        2usize,
        concat!("Size of: ", stringify!(IMPEncoderAttrFixQP))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderAttrFixQP>(),
        2usize,
        concat!("Alignment of ", stringify!(IMPEncoderAttrFixQP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iInitialQP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrFixQP),
            "::",
            stringify!(iInitialQP)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrCbr {
    pub uTargetBitRate: u32,
    pub iInitialQP: i16,
    pub iMinQP: i16,
    pub iMaxQP: i16,
    pub iIPDelta: i16,
    pub iPBDelta: i16,
    pub eRcOptions: u32,
    pub uMaxPictureSize: u32,
}
#[test]
fn bindgen_test_layout_IMPEncoderAttrCbr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderAttrCbr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderAttrCbr>(),
        24usize,
        concat!("Size of: ", stringify!(IMPEncoderAttrCbr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderAttrCbr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderAttrCbr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uTargetBitRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCbr),
            "::",
            stringify!(uTargetBitRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iInitialQP) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCbr),
            "::",
            stringify!(iInitialQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iMinQP) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCbr),
            "::",
            stringify!(iMinQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iMaxQP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCbr),
            "::",
            stringify!(iMaxQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iIPDelta) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCbr),
            "::",
            stringify!(iIPDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iPBDelta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCbr),
            "::",
            stringify!(iPBDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eRcOptions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCbr),
            "::",
            stringify!(eRcOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMaxPictureSize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCbr),
            "::",
            stringify!(uMaxPictureSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrVbr {
    pub uTargetBitRate: u32,
    pub uMaxBitRate: u32,
    pub iInitialQP: i16,
    pub iMinQP: i16,
    pub iMaxQP: i16,
    pub iIPDelta: i16,
    pub iPBDelta: i16,
    pub eRcOptions: u32,
    pub uMaxPictureSize: u32,
}
#[test]
fn bindgen_test_layout_IMPEncoderAttrVbr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderAttrVbr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderAttrVbr>(),
        28usize,
        concat!("Size of: ", stringify!(IMPEncoderAttrVbr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderAttrVbr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderAttrVbr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uTargetBitRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(uTargetBitRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMaxBitRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(uMaxBitRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iInitialQP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(iInitialQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iMinQP) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(iMinQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iMaxQP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(iMaxQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iIPDelta) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(iIPDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iPBDelta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(iPBDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eRcOptions) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(eRcOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMaxPictureSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrVbr),
            "::",
            stringify!(uMaxPictureSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderAttrCappedVbr {
    pub uTargetBitRate: u32,
    pub uMaxBitRate: u32,
    pub iInitialQP: i16,
    pub iMinQP: i16,
    pub iMaxQP: i16,
    pub iIPDelta: i16,
    pub iPBDelta: i16,
    pub eRcOptions: u32,
    pub uMaxPictureSize: u32,
    pub uMaxPSNR: u16,
}
#[test]
fn bindgen_test_layout_IMPEncoderAttrCappedVbr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderAttrCappedVbr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderAttrCappedVbr>(),
        32usize,
        concat!("Size of: ", stringify!(IMPEncoderAttrCappedVbr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderAttrCappedVbr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderAttrCappedVbr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uTargetBitRate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(uTargetBitRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMaxBitRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(uMaxBitRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iInitialQP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(iInitialQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iMinQP) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(iMinQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iMaxQP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(iMaxQP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iIPDelta) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(iIPDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iPBDelta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(iPBDelta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eRcOptions) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(eRcOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMaxPictureSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(uMaxPictureSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uMaxPSNR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrCappedVbr),
            "::",
            stringify!(uMaxPSNR)
        )
    );
}
pub type IMPEncoderAttrCappedQuality = IMPEncoderAttrCappedVbr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderAttrRcMode {
    pub rcMode: IMPEncoderRcMode,
    pub __bindgen_anon_1: IMPEncoderAttrRcMode__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPEncoderAttrRcMode__bindgen_ty_1 {
    pub attrFixQp: IMPEncoderAttrFixQP,
    pub attrCbr: IMPEncoderAttrCbr,
    pub attrVbr: IMPEncoderAttrVbr,
    pub attrCappedVbr: IMPEncoderAttrCappedVbr,
    pub attrCappedQuality: IMPEncoderAttrCappedQuality,
}
#[test]
fn bindgen_test_layout_IMPEncoderAttrRcMode__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderAttrRcMode__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderAttrRcMode__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(IMPEncoderAttrRcMode__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderAttrRcMode__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(IMPEncoderAttrRcMode__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrFixQp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrRcMode__bindgen_ty_1),
            "::",
            stringify!(attrFixQp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrCbr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrRcMode__bindgen_ty_1),
            "::",
            stringify!(attrCbr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrVbr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrRcMode__bindgen_ty_1),
            "::",
            stringify!(attrVbr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrCappedVbr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrRcMode__bindgen_ty_1),
            "::",
            stringify!(attrCappedVbr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrCappedQuality) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrRcMode__bindgen_ty_1),
            "::",
            stringify!(attrCappedQuality)
        )
    );
}
#[test]
fn bindgen_test_layout_IMPEncoderAttrRcMode() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderAttrRcMode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderAttrRcMode>(),
        36usize,
        concat!("Size of: ", stringify!(IMPEncoderAttrRcMode))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderAttrRcMode>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderAttrRcMode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderAttrRcMode),
            "::",
            stringify!(rcMode)
        )
    );
}
#[doc = " Define the frame rate structure of the encoded channel\n The minimum common multiple between frmratenum and frmrateden after the maximum common divisor division cannot exceed 64, preferably by the maximum common divisor before setting"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderFrmRate {
    #[doc = "< The number of time units in a second, in units of time. Frame rate molecules"]
    pub frmRateNum: u32,
    #[doc = "< The number of time units in a second, in units of time. Frame rate denominator"]
    pub frmRateDen: u32,
}
#[test]
fn bindgen_test_layout_IMPEncoderFrmRate() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderFrmRate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderFrmRate>(),
        8usize,
        concat!("Size of: ", stringify!(IMPEncoderFrmRate))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderFrmRate>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderFrmRate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frmRateNum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderFrmRate),
            "::",
            stringify!(frmRateNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frmRateDen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderFrmRate),
            "::",
            stringify!(frmRateDen)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderRcAttr {
    pub attrRcMode: IMPEncoderAttrRcMode,
    pub outFrmRate: IMPEncoderFrmRate,
}
#[test]
fn bindgen_test_layout_IMPEncoderRcAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderRcAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderRcAttr>(),
        44usize,
        concat!("Size of: ", stringify!(IMPEncoderRcAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderRcAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderRcAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrRcMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderRcAttr),
            "::",
            stringify!(attrRcMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outFrmRate) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderRcAttr),
            "::",
            stringify!(outFrmRate)
        )
    );
}
#[doc = " Define encoded channel attribute structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPEncoderChnAttr {
    #[doc = "< Encoder attribute structure"]
    pub encAttr: IMPEncoderEncAttr,
    #[doc = "< Rate controller attribute structure, only for H264 and H265"]
    pub rcAttr: IMPEncoderRcAttr,
    #[doc = "< Encoder attribute structure"]
    pub gopAttr: IMPEncoderGopAttr,
}
#[test]
fn bindgen_test_layout_IMPEncoderChnAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderChnAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderChnAttr>(),
        112usize,
        concat!("Size of: ", stringify!(IMPEncoderChnAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderChnAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderChnAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encAttr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnAttr),
            "::",
            stringify!(encAttr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcAttr) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnAttr),
            "::",
            stringify!(rcAttr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gopAttr) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnAttr),
            "::",
            stringify!(gopAttr)
        )
    );
}
#[doc = " Define the state structure of encoded channel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPEncoderChnStat {
    #[doc = "< Flag registered to the group, range: [TRUE, FALSE], TRUE: registered, FALSE: no registered"]
    pub registered: bool,
    #[doc = "< Number of images to be encoded"]
    pub leftPics: u32,
    #[doc = "< The number of bytes remaining in the bitstream buffer"]
    pub leftStreamBytes: u32,
    #[doc = "< The number of frames remaining in the bitstream buffer"]
    pub leftStreamFrames: u32,
    #[doc = "< The number of stream packets in the current frame"]
    pub curPacks: u32,
    #[doc = "< Channel program running status, 0: running, 1: no running"]
    pub work_done: u32,
}
#[test]
fn bindgen_test_layout_IMPEncoderChnStat() {
    const UNINIT: ::std::mem::MaybeUninit<IMPEncoderChnStat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPEncoderChnStat>(),
        24usize,
        concat!("Size of: ", stringify!(IMPEncoderChnStat))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPEncoderChnStat>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPEncoderChnStat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).registered) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnStat),
            "::",
            stringify!(registered)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leftPics) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnStat),
            "::",
            stringify!(leftPics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leftStreamBytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnStat),
            "::",
            stringify!(leftStreamBytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leftStreamFrames) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnStat),
            "::",
            stringify!(leftStreamFrames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curPacks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnStat),
            "::",
            stringify!(curPacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).work_done) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPEncoderChnStat),
            "::",
            stringify!(work_done)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_CreateGroup(int encGroup)\n\n Create Encoding Group.\n\n @param[in] encGroup: Group ID, range: [0, @ref NR_MAX_ENC_GROUPS - 1]\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks One way group only supports one way resolution, and a new group needs to be started for different resolutions\n One way group allows up to 2 coding channels to be registered.\n\n @attention If the group already exists, then return fails."]
    pub fn IMP_Encoder_CreateGroup(encGroup: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_DestroyGroup(int encGroup)\n\n Destroy Encoding Group.\n\n @param[in] encGroup: Group ID, range: [0, @ref NR_MAX_ENC_GROUPS - 1]\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks When destroying a group, it must be ensured that the group is empty, that is, no channel is registered in the group.\n\n @attention If destroy a nonexistent group, then return fails."]
    pub fn IMP_Encoder_DestroyGroup(encGroup: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetDefaultParam(IMPEncoderChnAttr *chnAttr, IMPEncoderProfile profile, IMPEncoderRcMode rcMode, uint16_t uWidth, uint16_t uHeight, uint32_t frmRateNum, uint32_t frmRat\n\n Set encoding default properties.\n\n @param[out] chnAttr: Struct for encoding.\n @param[in]  profile: Encoding profile.\n @param[in]  rcMode:  Rate control mode.\n @param[in]  uWidth:  Encoding width.\n @param[in]  uHeight: Encoding height.\n @param[in]  frmRateNum: Encoding fps num.\n @param[in]  frmRateDen: Encoding fps den.\n @param[in]  uGopLength: GOP length.\n @param[in]  uMaxSameSenceCnt: GOPLength = uGopLength * uMaxSameSenceCnt, Default is 2.\n @param[in]  iInitialQP: Initialize QP, Default is -1.\n @param[in]  uTargetBitRate: Target bitrate.\n\n @retval 0\t\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks If you are not familiar with coding related parameters, please use the default values.\n\n @attention none."]
    pub fn IMP_Encoder_SetDefaultParam(
        chnAttr: *mut IMPEncoderChnAttr,
        profile: IMPEncoderProfile,
        rcMode: IMPEncoderRcMode,
        uWidth: u16,
        uHeight: u16,
        frmRateNum: u32,
        frmRateDen: u32,
        uGopLength: u32,
        uMaxSameSenceCnt: ::std::os::raw::c_int,
        iInitialQP: ::std::os::raw::c_int,
        uTargetBitRate: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_CreateChn(int encChn, const IMPEncoderChnAttr *attr)\n\n Create Encoder Channel.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] attr:   Encode channel property pointer.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks The coding channel attribute consists of two parts: encoder attribute and rate control attribute.\n @remarks Encoder attributes need to select the coding protocol first, and then assign the corresponding attributes to each protocol."]
    pub fn IMP_Encoder_CreateChn(
        encChn: ::std::os::raw::c_int,
        attr: *const IMPEncoderChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_DestroyChn(int encChn)\n\n Destroy Encoder Channel.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @attention Destroy channels that do not exist, then return fails.\n @attention Before destroying, you must ensure that the channel has been de registered from the group, otherwise it will return fails."]
    pub fn IMP_Encoder_DestroyChn(encChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnAttr(int encChn, IMPEncoderChnAttr * const attr)\n\n Gets the properties of the encoding channel.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] attr:   Encoding channel properties.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed."]
    pub fn IMP_Encoder_GetChnAttr(
        encChn: ::std::os::raw::c_int,
        attr: *mut IMPEncoderChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_RegisterChn(int encGroup, int encChn)\n\n Register encoding channel to group.\n\n @param[in] encGroup: Group ID, range: [0, @ref NR_MAX_ENC_GROUPS - 1].\n @param[in] encChn:   Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @attention If you register a channel that does not exist, then return fails.\n @attention If the channel is registered to a nonexistent group, then return fails.\n @attention The same coding channel can only be registered to one group. If the channel has been registered to a group, then return fails.\n @attention If a group has been registered, it cannot be registered by other channels."]
    pub fn IMP_Encoder_RegisterChn(
        encGroup: ::std::os::raw::c_int,
        encChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_UnRegisterChn(int encChn)\n\n Unregister encoding channel to group.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks After the channel is logged off, the encoding channel will be reset and the code stream buffers in the encoding channel will be cleared,\n If the user is still using the bitstream buffer that has not been released in time, the correctness of the buffer data cannot be guaranteed,\n Users can use IMP_Encoder_Query interface to query the status of the code channel buffer, After the register of the bitstream is completed,\n the buffer is retrieved.\n\n @attention Unregister the uncreated channel, then return fails.\n @attention Unregister the unregistered channel, then return fails.\n @attention If the encoding channel does not stop receiving image encoding, then return fails."]
    pub fn IMP_Encoder_UnRegisterChn(encChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_StartRecvPic(int encChn)\n\n Start receiving coded channel image.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval 0\t\t\tsuccess.\n @retval non-0\t\t\tfailed.\n\n @remarks The encoding can only be started after the encoding channel receives the image.\n\n @attention If the channel is not created, then return fails.\n @attention If channel is not registered with group, then return fails."]
    pub fn IMP_Encoder_StartRecvPic(encChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_StopRecvPic(int encChn)\n\n End receiving coded channel image.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks This interface does not determine whether the reception is stopped or not, it allows repeated stop reception without returning errors.\n @remarks Calling this interface only stops receiving the original data encoding, and the stream buffer will not be eliminated.\n\n @attention If the channel is not created, then return fails.\n @attention If channel is not registered with group, then return fails."]
    pub fn IMP_Encoder_StopRecvPic(encChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_Query(int encChn, IMPEncoderChnStat *stat)\n\n Query encoded channel status.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[out] stat:  Encoding channel status.\n\n @retval 0\t\t\tsuccess.\n @retval non-0\t\t\tfailed.\n\n @remarks none.\n\n @attention none."]
    pub fn IMP_Encoder_Query(
        encChn: ::std::os::raw::c_int,
        stat: *mut IMPEncoderChnStat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetStream(int encChn, IMPEncoderStream *stream, bool blockFlag)\n\n Get the encoded stream.\n\n @param[in] encChn:    Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] stream:    stream structure pointer.\n @param[in] blockFlag: Whether to use blocking method to obtain, 0: no blocking, 1: blocking.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Get the data of one frame at a time.\n @remarks If the user does not get the stream for a long time, the code stream buffer will be full. If a code stream buffer is full,\n a coded channel will lose the image received later, Only when the user obtains the code stream and has enough buffer for coding, can the coding continue.\n It is suggested that the user interface call to acquire the code stream and the interface call to release the code stream appear in pairs,\n and the code stream should be released as soon as possible to prevent the user state from acquiring the code stream,\n If the bit stream buffer is full due to untimely release, the encoding is stopped.\n @remarks For H264 and h265 code streams, call success to get a frame code stream, which may contain multiple packets.\n @remarks For JPEG type code stream, call success to get one frame code stream at a time. This frame code stream only contains one package,\n and this frame contains the complete information of JPEG image file.\n\n example:\n @code\n int ret;\n ret = IMP_Encoder_PollingStream(ENC_H264_CHANNEL, 1000);   //Polling Stream Buffer.\n if (ret < 0) {\n     printf(\"Polling stream timeout\\n\");\n     return -1;\n }\n\n IMPEncoderStream stream;\n ret = IMP_Encoder_GetStream(ENC_H264_CHANNEL, &stream, 1); //Get a frame stream by blocking.\n if (ret < 0) {\n     printf(\"Get Stream failed\\n\");\n     return -1;\n }\n\n int i, nr_pack = stream.packCount;\n for (i = 0; i < nr_pack; i++) {                            //Save each packet of this frame stream.\n     ret = write(stream_fd, (void *)stream.pack[i].virAddr,\n                stream.pack[i].length);\n     if (ret != stream.pack[i].length) {\n         printf(\"stream write error:%s\\n\", strerror(errno));\n         return -1;\n     }\n }\n @endcode\n\n @attention If pststream is null, then return fails.\n @attention If the channel is not created, then return fails."]
    pub fn IMP_Encoder_GetStream(
        encChn: ::std::os::raw::c_int,
        stream: *mut IMPEncoderStream,
        blockFlag: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_ReleaseStream(int encChn, IMPEncoderStream *stream)\n\n Release the encoded stream.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] stream: stream structure pointer.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks This interface should be with imp_ Encoder_ Getstream pairs to use,user must release the obtained bit stream buffer in time after acquiring the bit stream,\n otherwise the bit stream buffer may be full and the encoder coding will be affected.\n And the user must release the obtained bitstream cache in the order of acquire first and release first.\n @remarks After the de registration of the coding channel, all the unreleased stream packets are invalid and can no longer be used or released.\n\n @attention If pststream is null, then return fails.\n @attention If the channel is not created, then return fails.\n @attention If the invalid stream is released, then return fails."]
    pub fn IMP_Encoder_ReleaseStream(
        encChn: ::std::os::raw::c_int,
        stream: *mut IMPEncoderStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_PollingStream(int encChn, uint32_t timeoutMsec)\n\n Polling encoded stream.\n\n @param[in] encChn:      Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] timeoutMsec: overtimes, unit: ms.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Before obtaining the code stream, you can use this API to poll. When the code stream cache is not empty or the time is over, the function returns.\n\n @attention none."]
    pub fn IMP_Encoder_PollingStream(
        encChn: ::std::os::raw::c_int,
        timeoutMsec: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_PollingModuleStream(uint32_t *encChnBitmap, uint32_t timeoutMsec)\n\n Poling the encoded stream of each channel of the whole encoding module.\n\n @param[out] encChnBitmap: Each bits represents the corresponding channel number, If there is a coded stream, the corresponding position 1, otherwise set to 0.\n @param[in] timeoutMsec:   overtimes, unit: ms.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Before obtaining the code stream, you can use this API to poll. When the code stream cache is not empty or the time is over, the function returns.\n @remarks *encChnBitmap The bit corresponding to 1 is only used after calling IMP_Encoder_ReleaseStream,\n if it is detected that the channel stream cache corresponding to this bit is not empty, it will be set to zero.\n\n @attention none."]
    pub fn IMP_Encoder_PollingModuleStream(
        encChnBitmap: *mut u32,
        timeoutMsec: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetFd(int encChn)\n\n Get the device file handle corresponding to the encoding channel.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval >=0\t\t\tsuccess, return the device file descriptor.\n @retval < 0\t\t\tfailed.\n\n @remarks If using IMP_Encoder_PollingStream is not suitable, For example, When the coding of multiple coding channels is completed in the same place,\n you can use this file handle to call select, poll and other similar functions to block waiting for encoding to complete.\n @remarks If the channel is not created, then return fails.\n\n @attention none."]
    pub fn IMP_Encoder_GetFd(encChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetbufshareChn(int encChn, int shareChn)\n\n Set JPEG channel to share H265/H264 encoding channel.\n\n @param[in] encChn:   Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] sharechn: Shared H264/H265 channel number, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Shared encoding channel created before calling this API.\n @remarks This API needs to be called before the channel is created.\n\n @attention none."]
    pub fn IMP_Encoder_SetbufshareChn(
        encChn: ::std::os::raw::c_int,
        shareChn: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnResizeMode(int encChn, int en);\n\n Set whether additional rmem memory is required for encoding scaling.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] en:     alloc rmem or not, 1: no alloc rmem, 0: alloc rmem.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks This API is only called when the resolution of encoding scaling is less than the original resolution,\n there is no need to call when the resolution of encoding scaling is greater than the original resolution.\n\n @attention none."]
    pub fn IMP_Encoder_SetChnResizeMode(
        encChn: ::std::os::raw::c_int,
        en: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetMaxStreamCnt(int encChn, int nrMaxStream)\n\n Set the number of stream buffers.\n\n @param[in] encChn:      Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] nrMaxStream: number of stream buffers, range: [1, @ref NR_MAX_ENC_CHN_STREAM].\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Because the number of Buffer buffers is fixed at the time the channel is created, the secondary API needs to be called before the channel is created.\n @remarks If this API is not called to set the number of buffers in the bitstream cache before the channel is created, the default number of buffers in the SDK is used.\n\n @attention none."]
    pub fn IMP_Encoder_SetMaxStreamCnt(
        encChn: ::std::os::raw::c_int,
        nrMaxStream: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetMaxStreamCnt(int encChn, int *nrMaxStream)\n\n Get the number of stream buffers.\n\n @param[in] encChn:       Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[out] nrMaxStream: stream buffer number variable pointer.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks none.\n\n @attention none."]
    pub fn IMP_Encoder_GetMaxStreamCnt(
        encChn: ::std::os::raw::c_int,
        nrMaxStream: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_RequestIDR(int encChn)\n\n Request IDR frame.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks After calling this API, IDR frame coding will be applied in the latest coding frame.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_RequestIDR(encChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_FlushStream(int encChn)\n\n Wipe out old stream in the encoder, and the encoding starts with the IDR frame.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks After calling this API, IDR frame coding will be applied in the latest coding frame.\n\n @attention none."]
    pub fn IMP_Encoder_FlushStream(encChn: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnFrmRate(int encChn, IMPEncoderFrmRate *pstFps)\n\n Get frame rate control properties.\n\n @param[in] encChn:     Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[out] pstFpsCfg: Frame rate control attribute parameters.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Calling this API will get the frame rate control property of the channel. Calling this API requires that the channel already exists.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_GetChnFrmRate(
        encChn: ::std::os::raw::c_int,
        pstFps: *mut IMPEncoderFrmRate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnFrmRate(int encChn, const IMPEncoderFrmRate *pstFps)\n\n Set frame rate control properties dynamically.\n\n @param[in] encChn:     Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[out] pstFpsCfg: Frame rate control attribute parameters.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Calling this API will reset the encoder frame rate attribute. The frame rate attribute takes effect in the next GOP with a maximum delay of 1 second.\n Calling this API requires that the channel already exists.\n @remarks If IMP_FRAMESOURCE_SETCHNFPS is called to change frame rate of the system dynamically, then the function is needed to modify the frame rate of the encoder\n and complete the correct parameter configuration.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_SetChnFrmRate(
        encChn: ::std::os::raw::c_int,
        pstFps: *const IMPEncoderFrmRate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnBitRate(int encChn, int iTargetBitRate, int iMaxBitRate)\n\n Set bitrate attribute dynamically.\n\n @param[in] encChn:         Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] iTargetBitRate: Target bitrate, iMaxBitRate Max bitrate unit: \"bit/s\".\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Calling this API will reset the code rate attribute of the encoder. The code rate attribute takes effect in the next GOP with a maximum delay of 1 second.\n Calling this API requires that the channel already exists.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_SetChnBitRate(
        encChn: ::std::os::raw::c_int,
        iTargetBitRate: ::std::os::raw::c_int,
        iMaxBitRate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnGopLength(int encChn, int iGopLength);\n\n Set the gopplength property of the encoding channel.\n\n @param[in] encChn Channel ID,range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] iGopLength GopLength attr.\n\n @retval 0\t\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks none.\n\n @attention none."]
    pub fn IMP_Encoder_SetChnGopLength(
        encChn: ::std::os::raw::c_int,
        iGopLength: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnAttrRcMode(int encChn, IMPEncoderAttrRcMode *pstRcModeCfg).\n\n Get the rate control mode attribute.\n\n @param[in] encChn:    Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[out] pstRcCfg: Rate control mode attribute parameters.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Calling this API will get the bit rate control mode property of the channel. Calling this API requires that the channel already exists.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_GetChnAttrRcMode(
        encChn: ::std::os::raw::c_int,
        pstRcModeCfg: *mut IMPEncoderAttrRcMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnAttrRcMode(int encChn, const IMPEncoderAttrRcMode *pstRcModeCfg).\n\n Set rate control mode properties.\n\n @param[in] encChn:   Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] pstRcCfg: Rate control mode attribute parameters.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Calling this API will set the bit rate control mode property of the channel, and the next IDR will take effect.\n Calling this API requires that the channel already exists.\n\n @attention Currently, the code rate control mode supports ENC_RC_MODE_FIXQP, ENC_RC_MODE_CBR, ENC_RC_MODE_VBR, ENC_RC_MODE_CAPPED_QUALITY.\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_SetChnAttrRcMode(
        encChn: ::std::os::raw::c_int,
        pstRcModeCfg: *const IMPEncoderAttrRcMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnGopAttr(int encChn, IMPEncoderGopAttr *pGopAttr);\n\n Obtain encoding channel GOP properties.\n\n @param[in] encChn: Channel ID,range: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[out] pGopAttr: GOP attr\n\n @retval 0\t\t\t\tsuccess\n @retval ~0\t\t\tfailed\n\n @remarks none.\n\n @attention none"]
    pub fn IMP_Encoder_GetChnGopAttr(
        encChn: ::std::os::raw::c_int,
        pGopAttr: *mut IMPEncoderGopAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnGopAttr(int encChn, const IMPEncoderGopAttr *pGopAttr);\n\n Set encoding channel GOP properties.\n\n @param[in] encChn: Channel ID,range: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] pGopAttr: GOP attr\n\n @retval 0\t\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks none.\n\n @attention none"]
    pub fn IMP_Encoder_SetChnGopAttr(
        encChn: ::std::os::raw::c_int,
        pGopAttr: *const IMPEncoderGopAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnQp(int encChn, int iQP)\n\n Setting the rate control property QP dynamically.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] iQP:    QP, range: [iMinQP, iMaxQP]\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Calling this API will reset the QP of the next frame, and the set QP will take effect in the next frame.\n\t\t\tCalling this API requires that the channel already exists.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_SetChnQp(
        encChn: ::std::os::raw::c_int,
        iQP: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnQpBounds(int encChn, int iMinQP, int iMaxQP);\n\n Dynamically set the bit rate control attributes maxqp and minqp.\n\n @param[in] encChn: Channel ID,range: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] iMinQP: iMinQP value,range: [0, 51]\n @param[in] iMaxQP: iMaxQP value,range: [0, 51]\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Calling this API will reset the QP range of the next frame.\n\t\t\tCalling this API requires that the channel already exists.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_SetChnQpBounds(
        encChn: ::std::os::raw::c_int,
        iMinQP: ::std::os::raw::c_int,
        iMaxQP: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnQpIPDelta(int encChn, int uIPDelta)\n\n Setting the rate control property IPDelta dynamically.\n\n @param[in] encChn:   Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] IPDelta   QP difference between I frame and the first P frame after it\n\n @retval 0\t\t\tsuccess\n @retval ~0\t\t\tfailed\n\n @remarks\tCalling this API requires that the channel already exists.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_SetChnQpIPDelta(
        encChn: ::std::os::raw::c_int,
        uIPDelta: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetFisheyeEnableStatus(int encChn, int enable)\n\n Set the enabling state of the fish eye correction algorithm provided by ingenic.\n\n @param[in] encChn: Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[in] enable: 0: unable(default), 1: enable.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @remarks Because the enabling state of the fisheye correction algorithm is fixed at the time of the creation of the channel,\n the secondary API needs to be called before the channel is created.\n @remarks If this API is not called to set the enable state of the fish eye correction algorithm provided by ingenic before the channel is created,\n it is not enabled by default, the fish eye correction algorithm provided by Junzheng cannot be used.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_SetFisheyeEnableStatus(
        encChn: ::std::os::raw::c_int,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetFisheyeEnableStatus(int encChn, int *enable)\n\n Get the enabling state of the fish eye correction algorithm provided by ingenic.\n\n @param[in] encChn:  Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[out] enable: return Enable state, 0: unable, 1: enable.\n\n @retval 0\t\t\tsuccess.\n @retval ~0\t\t\tfailed.\n\n @attention This API is only applicable to H264 and H265 encoding channels."]
    pub fn IMP_Encoder_GetFisheyeEnableStatus(
        encChn: ::std::os::raw::c_int,
        enable: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_GetChnEncType(int encChn, IMPEncoderEncType *encType)\n\n Get image encoding protocol type.\n\n @param[in] encChn:   Channel ID, range: [0, @ref NR_MAX_ENC_CHN - 1].\n @param[out] encType: return encoding protocol type.\n\n @retval 0\t\t\t\tsuccess.\n @retval ~0\t\t\t\tfailed.\n\n @remarks If the channel is not created, then return fails.\n\n @attention none."]
    pub fn IMP_Encoder_GetChnEncType(
        encChn: ::std::os::raw::c_int,
        encType: *mut IMPEncoderEncType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_SetPool(int chnNum, int poolID);\n\n bind channel to mempool, let chnNum malloc from pool.\n\n @param[in] chnNum\t\tChannel ID.\n @param[in] poolID\t\tPool ID.\n\n @retval 0\t\t\t\tsuccess.\n @retval other values\t\tfailed.\n\n @remarks In order to solve the fragmentation of rmem, the channel encoder is bound to\n the corresponding MemPool. The encoder applies for MEM in the MemPool. If it is not\n called, the encoder will apply in rmem. At this time, there is the possibility of\n fragmentation for rmem.\n\n @attention: chnNum is greater than or equal to 0 and less than 32."]
    pub fn IMP_Encoder_SetPool(
        chnNum: ::std::os::raw::c_int,
        poolID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_GetPool(int chnNum);\n\n Get Pool ID by chnannel ID.\n\n @param[in] chnNum\t\tChannel ID.\n\n @retval  >=0 && < 32     success.\n @retval other values\t\tfailed.\n\n @remarks obtains poolid through channelid, which cannot be used by customers temporarily.\n\n @attention\tnone."]
    pub fn IMP_Encoder_GetPool(chnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_SetStreamBufSize(int encChn, uint32_t nrStreamSize);\n\n Set size of Stream buffer.\n\n @param[in] encChn:       Channel ID.\n @param[in] nrStreamSize: size of Stream buffer.\n\n @retval  >=0 && < 32     success.\n @retval  <0\t\t\t    failed.\n\n @remarks This API must be called before the channel is created.\n\n @attention none."]
    pub fn IMP_Encoder_SetStreamBufSize(
        encChn: ::std::os::raw::c_int,
        nrStreamSize: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_GetStreamBufSize(int encChn, uint32_t *nrStreamSize);\n\n Get size of Stream buffer.\n\n @param[in] encChn:        Channel ID.\n @param[out] nrStreamSize: size of Stream buffer.\n\n @retval  >=0 && < 32    success.\n @retval  <0\t\t\t   failed.\n\n @remarks This API must be called after the channel is created.\n\n @attention none."]
    pub fn IMP_Encoder_GetStreamBufSize(
        encChn: ::std::os::raw::c_int,
        nrStreamSize: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_GetChnAveBitrate(int encChn, IMPEncoderStream *stream, int frames, double *br);\n\n Gets the average bit rate of the specified number of frames.\n\n @param[in] encChn       Channel ID.\n @param[in] stream       Stream.\n @param[in] frame        Count the number of frames(Integral multiple of GOP length).\n @param[out] br          Average bitrate.\n\n @retval  >=0 && < 32    success.\n @retval  <0\t\t\t   failed.\n\n @remarks   This API must be called after using IMP_Encoder_GetStream.\n\n @attention none."]
    pub fn IMP_Encoder_GetChnAveBitrate(
        encChn: ::std::os::raw::c_int,
        stream: *mut IMPEncoderStream,
        frames: ::std::os::raw::c_int,
        br: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_GetChnEvalInfo(int encChn, void *info);\n\n Obtain the evaluation parameters of each frame in the channel.\n\n @param[in] encChn       Channel ID.\n @param[out] info        Eval info.\n\n @retval  >=0 && < 32    success.\n @retval  <0\t\t\t   failed.\n\n @remarks   This API must be called after using IMP_Encoder_GetStream.\n\n @attention none."]
    pub fn IMP_Encoder_GetChnEvalInfo(
        encChn: ::std::os::raw::c_int,
        info: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_Encoder_SetChnEntropyMode(int encChn,IMPEncoderEntropyMode eEntropyMode)\n\n Set entropy mode in the channel\n\n @param[in] encChn          Channel ID.\n @param[in] eEntropyMode    Entropy mode.\n\n @retval 0                  success.\n @retval <0                 failed.\n\n @remarks This API is only applicable to IMP_ENC_PROFILE_AVC_MAIN or IMP_ENC_PROFILE_AVC_HIGH\n @remarks This API needs to be called before the channel is created.\n\n @attention This API is only applicable to H264 encoding channels."]
    pub fn IMP_Encoder_SetChnEntropyMode(
        encChn: ::std::os::raw::c_int,
        eEntropyMode: IMPEncoderEntropyMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_Encoder_SetFrameRelease(int encChn, int num, int den);\n\n Set release frame num and den.\n\n @param[in] encChn:        Channnel ID.\n @param[in] num:           release num.\n @param[in] den:           release den.\n\n @retval  >=0            success.\n @retval  <0\t\t\t   failed.\n\n @remarks This API must be called after the channel is created.\n\n @attention none."]
    pub fn IMP_Encoder_SetFrameRelease(
        encChn: ::std::os::raw::c_int,
        num: ::std::os::raw::c_int,
        den: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The structure of cropping operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFSChnCrop {
    #[doc = "< Set the parameter to enable/disable cropping"]
    pub enable: ::std::os::raw::c_int,
    #[doc = "< the X offset of starting pixel"]
    pub left: ::std::os::raw::c_int,
    #[doc = "< the Y offset of starting pixel"]
    pub top: ::std::os::raw::c_int,
    #[doc = "< the cropped horizontal window size (width)"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< the cropped vertical window size (height)"]
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPFSChnCrop() {
    const UNINIT: ::std::mem::MaybeUninit<IMPFSChnCrop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPFSChnCrop>(),
        20usize,
        concat!("Size of: ", stringify!(IMPFSChnCrop))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPFSChnCrop>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPFSChnCrop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnCrop),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnCrop),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnCrop),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnCrop),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnCrop),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " The structure of scaling operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFSChnScaler {
    #[doc = "< Set to the parameter to enable/disable scaling"]
    pub enable: ::std::os::raw::c_int,
    #[doc = "< the horizontal window size after scaling"]
    pub outwidth: ::std::os::raw::c_int,
    #[doc = "< the vertical window size after scaling"]
    pub outheight: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPFSChnScaler() {
    const UNINIT: ::std::mem::MaybeUninit<IMPFSChnScaler> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPFSChnScaler>(),
        12usize,
        concat!("Size of: ", stringify!(IMPFSChnScaler))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPFSChnScaler>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPFSChnScaler))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnScaler),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outwidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnScaler),
            "::",
            stringify!(outwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outheight) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnScaler),
            "::",
            stringify!(outheight)
        )
    );
}
#[doc = "< physics frame channel"]
pub const IMPFSChnType_FS_PHY_CHANNEL: IMPFSChnType = 0;
#[doc = "< virtual frame channel"]
pub const IMPFSChnType_FS_EXT_CHANNEL: IMPFSChnType = 1;
pub type IMPFSChnType = ::std::os::raw::c_uint;
#[doc = "< FIFO caches first，then output data"]
pub const IMPFSChnFifoType_FIFO_CACHE_PRIORITY: IMPFSChnFifoType = 0;
#[doc = "< FIFO output data first, then caches"]
pub const IMPFSChnFifoType_FIFO_DATA_PRIORITY: IMPFSChnFifoType = 1;
#[doc = " Channel FIFO Type"]
pub type IMPFSChnFifoType = ::std::os::raw::c_uint;
#[doc = "< fs channel not created or destroied"]
pub const IMPFSChannelState_IMP_FSCHANNEL_STATE_CLOSE: IMPFSChannelState = 0;
#[doc = "< fs channel create but not enable"]
pub const IMPFSChannelState_IMP_FSCHANNEL_STATE_OPEN: IMPFSChannelState = 1;
#[doc = "<fs channel created and enabled"]
pub const IMPFSChannelState_IMP_FSCHANNEL_STATE_RUN: IMPFSChannelState = 2;
pub type IMPFSChannelState = ::std::os::raw::c_uint;
#[doc = " The structure of FIFO Channel's attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFSChnFifoAttr {
    #[doc = "< FIFO maximum depth"]
    pub maxdepth: ::std::os::raw::c_int,
    #[doc = "< Channel FIFO Type"]
    pub type_: IMPFSChnFifoType,
}
#[test]
fn bindgen_test_layout_IMPFSChnFifoAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPFSChnFifoAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPFSChnFifoAttr>(),
        8usize,
        concat!("Size of: ", stringify!(IMPFSChnFifoAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPFSChnFifoAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPFSChnFifoAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxdepth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnFifoAttr),
            "::",
            stringify!(maxdepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnFifoAttr),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " The structure of frame channel's attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPFSChnAttr {
    #[doc = "< output image width"]
    pub picWidth: ::std::os::raw::c_int,
    #[doc = "< output image height"]
    pub picHeight: ::std::os::raw::c_int,
    #[doc = "< output image format"]
    pub pixFmt: IMPPixelFormat,
    #[doc = "< the attribute of image cropping"]
    pub crop: IMPFSChnCrop,
    #[doc = "< the attribute of image scaling"]
    pub scaler: IMPFSChnScaler,
    #[doc = "< the molecular of output fps"]
    pub outFrmRateNum: ::std::os::raw::c_int,
    #[doc = "< the denominator of output fps"]
    pub outFrmRateDen: ::std::os::raw::c_int,
    #[doc = "< the number of Video buffers"]
    pub nrVBs: ::std::os::raw::c_int,
    #[doc = "< the type of the frame channel"]
    pub type_: IMPFSChnType,
    #[doc = "< the attribute of the frame channel"]
    pub fcrop: IMPFSChnCrop,
}
#[test]
fn bindgen_test_layout_IMPFSChnAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPFSChnAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPFSChnAttr>(),
        80usize,
        concat!("Size of: ", stringify!(IMPFSChnAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPFSChnAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPFSChnAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picWidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(picWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picHeight) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(picHeight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixFmt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(pixFmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(crop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaler) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(scaler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outFrmRateNum) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(outFrmRateNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outFrmRateDen) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(outFrmRateDen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrVBs) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(nrVBs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcrop) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPFSChnAttr),
            "::",
            stringify!(fcrop)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_CreateChn(int chnNum, IMPFSChnAttr *chnAttr)\n\n Create a frame channel\n\n @param[in] chnNum Id of frame channel\n @param[in] chnAttr  the pointer of the frame channel's attribute\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark Create a channel to provide a data source to the back-end module; \\n\n you can set the channel related attributes, including: the width of the picture, the height of the picture, the picture format, channel output frame rate, number of cache buf, cropping and scaling properties.\n  On the chip of T10, frame channel 0 and 1 are physics channel, channel 2 and 3 are vritual.\n @attention none."]
    pub fn IMP_FrameSource_CreateChn(
        chnNum: ::std::os::raw::c_int,
        chn_attr: *mut IMPFSChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_DestroyChn(int chnNum)\n\n Destroy the selected frame channel.\n\n @param[in] chnNum Id of frame channel\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark the function will free some resources of the frame channel.\n\n @attention If the channel has been enabled (IMP_FrameSource_EnableChn), please disable it (IMP_FrameSource_DisableChn) before calling the current function."]
    pub fn IMP_FrameSource_DestroyChn(chnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_EnableChn(int chnNum)\n\n Enable the selected frame channel.\n\n @param[in] chnNum Id of frame channel\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark none\n\n @attention Before calling the function, the frame channel has to been created."]
    pub fn IMP_FrameSource_EnableChn(chnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_DisableChn(int chnNum)\n\n Disable the selected frame channel.\n\n @param[in] chnNum Id of frame channel\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark none\n\n @attention none"]
    pub fn IMP_FrameSource_DisableChn(chnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_SetSource(int extchnNum, int sourcechnNum)\n\n Set sourcechnNum of extchnNum\n\n @param[in] extchnNum extchnNum\n\n @param[in] sourcechnNum sourcechnNum\n\n @retval 0 means success\n @retval Other values means failure, its value is an error code\n\n @remark NONE\n\n @attention After IMP_FrameSource_CreateChn and Before IMP_FrameSource_EnableChn to use"]
    pub fn IMP_FrameSource_SetSource(
        extchnNum: ::std::os::raw::c_int,
        sourcechnNum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_GetChnAttr(int chnNum, IMPFSChnAttr *chnAttr)\n\n Obtains the frame channel attribute.\n\n @param[in] chnNum Id of frame channel\n\n @param[out] chnAttr Pointer of the channel's attribute.\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark The attribute contains elements such as: the width ,height and format of the image; the output video FPS, the number of buffers, cropping and scaling properties.\n\n @attention none"]
    pub fn IMP_FrameSource_GetChnAttr(
        chnNum: ::std::os::raw::c_int,
        chnAttr: *mut IMPFSChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_SetChnAttr(int chnNum, const IMPFSChnAttr *chnAttr)\n\n Sets the frame channel attribute.\n\n @param[in] chnNum Id of frame channel\n\n @param[out] chnAttr Pointer of the channel's attribute.\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark The attribute contains elements such as: the width ,height and format of the image; the output video FPS, the number of buffers, cropping and scaling properties.\n\n @attention none"]
    pub fn IMP_FrameSource_SetChnAttr(
        chnNum: ::std::os::raw::c_int,
        chnAttr: *const IMPFSChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetFrameDepth(int chnNum, int depth)\n\n Sets the maximum space(depth) for the images\n\n @param[in] chnNum  Id of frame channel\n @param[in] depth  the maximum space(depth) for the images of the Frame channel.\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark\n\n 1.This interface is used to set the video frames of a channel cache. When the user sets caches for multi frame video image, he can access a certain number of consecutive image datas.\n\n 2.If the specified depth is 0, that does not require the system to cache the image of the channel, so users can not get the channel image data. The system default is not the channel cache image, so, depth is 0.\n\n 3.System will automatically update the most old image data, to ensure that once the user begins to get new image data, you can get the latest image.\n\n 4.If the system can not get the image then it automatically stops the cache of the new image, so the user can not get a new image. Therefore it is recommended that the user makes sure to access and release the interface for use.\n\n 5.System will automatically update the user that it has not yet acquired the old image data, to ensure that the cache image queue is for the most recent image. If the user can not guarantee acquisition speed, the whole process might end up receiving non-consecutive images.\n\n 6 this function can call the location, there is no requirement, but it can be done only once.\n\n @attention none."]
    pub fn IMP_FrameSource_SetFrameDepth(
        chnNum: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetFrameDepth(int chnNum, int *depth);\n\n Obtains the depth of Frame FIFO.\n\n @param[in] chnNum  Id of frame channel\n @param[out] depth  Pointer of the depth value.\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark none.\n\n @attention none."]
    pub fn IMP_FrameSource_GetFrameDepth(
        chnNum: ::std::os::raw::c_int,
        depth: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetFrame(int chnNum, IMPFrameInfo **frame);\n\n Obtained image.\n\n @param[in] chnNum  Id of frame channel\n @param[out] frame  Pointer of the frame information.\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark\n\n 1.This interface can obtain the video image information of the specified channel. The image information mainly includes: the width of the image, the height, the pixel format and the image data starting address.\n\n 2.This interface will be valid only after the channel has been enabled.\n\n 3.It supports multiple access after release, but it is recommended to access and release the right interface for use.\n\n 4.The default timeout for this interface is 2S, that means after 2S without receiving any images the will be a timeout.\n\n @attention none."]
    pub fn IMP_FrameSource_GetFrame(
        chnNum: ::std::os::raw::c_int,
        frame: *mut *mut IMPFrameInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetTimedFrame(int chnNum, IMPFrameTimestamp *framets, int block, void *framedata, IMPFrameInfo *frame);\n\n Obtained image with specified time.\n\n @param[in] chnNum  Id of frame channel\n @param[in] framets Time info\n @param[in] block block info\n @param[in] framedata Mem porinter used to store image\n @param[in] frame Image info\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark\n\n 1.This interface can obtain the video image with certain time information of the specified channel. The image information mainly includes: the width of the image, the height, the pixel format and the image data starting address.\n\n 2.This interface will be valid only after the channel has been enabled.\n\n 3.Before this interface, IMP_FrameSource_SetMaxDelay and IMP_FrameSource_SetDelay should be used。\n\n @attention none."]
    pub fn IMP_FrameSource_GetTimedFrame(
        chnNum: ::std::os::raw::c_int,
        framets: *mut IMPFrameTimestamp,
        block: ::std::os::raw::c_int,
        framedata: *mut ::std::os::raw::c_void,
        frame: *mut IMPFrameInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_ReleaseFrame(int chnNum, IMPFrameInfo *frame);\n\n Release the frame\n\n @param[in] chnNum  ID of frame channel\n @param[in] frame   Pointer of frame information.\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark none.\n\n @attention none."]
    pub fn IMP_FrameSource_ReleaseFrame(
        chnNum: ::std::os::raw::c_int,
        frame: *mut IMPFrameInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SnapFrame(int chnNum, IMPPixelFormat fmt, int width, int height, void *framedata, IMPFrameInfo *frame);\n\n Get frames\n\n @param[in] chnNum  ID of frame channel\n @param[in] fmt     format of image\n @param[in] width   width of image\n @param[in] height  height of image\n @param[in] framedata memory of image, provided by user\n @param[in] frame     pointer of frame information.\n\n @retval 0          means success\n @retval others     means failure, its value is an error code\n\n @remark\n\n 1.This interface can snap a video image, format now only support NV12 and YUYV422, resolution support the same size of framesource resolution.\n\n 2.This interface does not need to be used with IMP_FrameSource_SetFrameDepth.\n\n 3.This interface will be valid only after the channel has been enabled.\n\n\n @attention none."]
    pub fn IMP_FrameSource_SnapFrame(
        chnNum: ::std::os::raw::c_int,
        fmt: IMPPixelFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        framedata: *mut ::std::os::raw::c_void,
        frame: *mut IMPFrameInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetMaxDelay(int chnNum, int maxcnt);\n\n Set max frame delay\n\n @param[in] chnNum ID of frame channel\n @param[in] maxcnt max frame delay\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark none.\n\n @attention If need, this function should be called between IMP_FrameSource_CreateChn and IMP_FrameSource_EnableChn."]
    pub fn IMP_FrameSource_SetMaxDelay(
        chnNum: ::std::os::raw::c_int,
        maxcnt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetMaxDelay(int chnNum, int *maxcnt);\n\n Get max frame delay\n\n @param[in] chnNum ID of frame channel\n @param[out] maxcnt max frame delay\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark none.\n\n @attention Before calling the function, the frame channel has to been created."]
    pub fn IMP_FrameSource_GetMaxDelay(
        chnNum: ::std::os::raw::c_int,
        maxcnt: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetDelay(int chnNum, int cnt);\n\n Set frame delay\n\n @param[in] chnNum ID of frame channel\n @param[in] cnt frame delay\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark none.\n\n @attention If need, this function should be called after IMP_FrameSource_SetMaxDelay."]
    pub fn IMP_FrameSource_SetDelay(
        chnNum: ::std::os::raw::c_int,
        cnt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetDelay(int chnNum, int *cnt);\n\n Get frame delay\n\n @param[in] chnNum ID of frame channel\n @param[out] cnt frame delay\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @remark none.\n\n @attention Before calling the function, the frame channel has to been created."]
    pub fn IMP_FrameSource_GetDelay(
        chnNum: ::std::os::raw::c_int,
        cnt: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_SetChnFifoAttr(int chnNum, IMPFSChnFifoAttr *attr);\n\n set channel's largest cache FIFO attribute\n\n @param[in] chnNum  \t  ID of the frame channel\n @param[in] attr\t  \t  FIFO attribute，includes FIFO maximum depth，unit(frame)；FIFO type.\n\n @retval 0              means success\n @retval other values   means failure，its value is an error code\n\n @remark none.\n\n @attention use it in between of these two interfaces IMP_FrameSource_CreateChn, IMP_FrameSource_EnableChn."]
    pub fn IMP_FrameSource_SetChnFifoAttr(
        chnNum: ::std::os::raw::c_int,
        attr: *mut IMPFSChnFifoAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_FrameSource_GetChnFifoAttr(int chnNum, IMPFSChnFifoAttr *attr);\n\n Get channel maximum caches FIFO attribute\n\n @param[in] chnNum \t  Channel ID\n @param[out] attr\t      FIFO attribute.\n\n @retval 0 \t\t\t  means success\n @retval other values   means failure，its value is an error code\n\n @remark none.\n\n @attention Use it after calling IMP_FrameSource_CreateChn."]
    pub fn IMP_FrameSource_GetChnFifoAttr(
        chnNum: ::std::os::raw::c_int,
        attr: *mut IMPFSChnFifoAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_SetPool(int chnNum, int poolID);\n\n bind channel to mempool, let chnNum malloc from pool.\n\n @param[in] chnNum\t\tChannnel ID.\n @param[in] poolID\t\tPool ID.\n\n @retval 0\t\t\t\tmeans success.\n @retval other values\t\tmean failure.\n\n @remarks In order to solve the fragmentation of rmem, the channel FrameSource is bound to\n the corresponding MemPool. The FrameSource applies for MEM in the MemPool. If it is not\n called, the FrameSource will apply in rmem. At this time, there is the possibility of\n fragmentation for rmem\n\n @attention: chnNum is greater than or equal to 0 and less than 32."]
    pub fn IMP_FrameSource_SetPool(
        chnNum: ::std::os::raw::c_int,
        poolID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_GetPool(int chnNum);\n\n Get Pool ID by chnannel ID.\n\n @param[in] chnNum\t\tChannel ID.\n\n @retval  >=0 && < 32     means success.\n @retval other values\t\tmean failure.\n\n @remarks obtains poolid through channelid, which cannot be used by customers temporarily\n\n @attention\tnone."]
    pub fn IMP_FrameSource_GetPool(chnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_FrameSource_ChnStatQuery(int chnNum, FSChannelState *pstate);\n\n Get framesource by channel ID；0：close，1：open，2：run.\n\n @param[in] chnNum       Channel ID.\n\n @retval  >=0            means success.\n @retval  <0\t\t\t   mean failure.\n\n @remarks\n\n @attention none."]
    pub fn IMP_FrameSource_ChnStatQuery(
        chnNum: ::std::os::raw::c_int,
        pstate: *mut IMPFSChannelState,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_FrameSource_SetChnRotate(int chnNum, uint8_t rotTo90, int width, int height);\n\n Enable FS channel rotation and configure rotation attributes\n\n @param[in] encChn \tEncoder channel number, value range: [0, @ref NR_MAX_ENC_CHN - 1]\n @param[in] rotTo90 \t0: disable, 1: rotate 90 ° counterclockwise, 2: rotate 90 ° clockwise\n @param[in] width  \twidth Image width before rotation\n @param[in] height \theight Image height before rotation\n\n @retval  >=0            means success.\n @retval  <0\t\t\t   mean failure.\n\n @remarks This API needs to be called before channel creation\n @remarks To use this interface, the resolution must be 64 bit aligned\n @remarks After using the modified interface, the width and height of the code should be set to the rotated width and height during the initialization of the coding channel\n @remarks The FS channel rotation function cannot be used together with the encoding soft zoom function\n @remarks Use this function to request an rmem memory to save the rotated frame data\n @remarks The image rotation function is implemented by software, which will occupy computing resources. It is recommended that the resolution be set below 1280 * 704, and the frame rate should not exceed 15 frames"]
    pub fn IMP_FrameSource_SetChnRotate(
        chnNum: ::std::os::raw::c_int,
        rotTo90: u8,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IMP_EmuFrameSource_GetChnAttr(
        chn_num: u32,
        chn_attr: *mut IMPFSChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IMP_EmuFrameSource_EnableChn(chn_num: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IMP_EmuFrameSource_DisableChn(chn_num: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IMP_EmuFrameSource_CreateChn(
        chn_num: u32,
        chn_attr: *mut IMPFSChnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IMP_EmuFrameSource_DestroyChn(chn_num: u32) -> ::std::os::raw::c_int;
}
#[doc = "< I2C control bus"]
pub const IMPSensorControlBusType_TX_SENSOR_CONTROL_INTERFACE_I2C: IMPSensorControlBusType = 1;
#[doc = "< SPI control bus"]
pub const IMPSensorControlBusType_TX_SENSOR_CONTROL_INTERFACE_SPI: IMPSensorControlBusType = 2;
#[doc = " The enum is types of sensor control bus."]
pub type IMPSensorControlBusType = ::std::os::raw::c_uint;
#[doc = " Defines I2C bus information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPI2CInfo {
    #[doc = "< Set the name, the value must be match with sensor name in 'struct i2c_device_id'"]
    pub type_: [::std::os::raw::c_char; 20usize],
    #[doc = "< the I2C address"]
    pub addr: ::std::os::raw::c_int,
    #[doc = "< I2C adapter ID"]
    pub i2c_adapter_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPI2CInfo() {
    const UNINIT: ::std::mem::MaybeUninit<IMPI2CInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPI2CInfo>(),
        28usize,
        concat!("Size of: ", stringify!(IMPI2CInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPI2CInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPI2CInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPI2CInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPI2CInfo),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2c_adapter_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPI2CInfo),
            "::",
            stringify!(i2c_adapter_id)
        )
    );
}
#[doc = " Defines SPI bus information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPSPIInfo {
    #[doc = "< Set the name, the value must be match with sensor name in 'struct i2c_device_id'"]
    pub modalias: [::std::os::raw::c_char; 32usize],
    #[doc = "< Address of SPI bus"]
    pub bus_num: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPSPIInfo() {
    const UNINIT: ::std::mem::MaybeUninit<IMPSPIInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPSPIInfo>(),
        36usize,
        concat!("Size of: ", stringify!(IMPSPIInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPSPIInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPSPIInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modalias) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSPIInfo),
            "::",
            stringify!(modalias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus_num) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSPIInfo),
            "::",
            stringify!(bus_num)
        )
    );
}
#[doc = " Defines the information of sensor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPSensorInfo {
    #[doc = "< the sensor name"]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< the sensor control bus type"]
    pub cbus_type: IMPSensorControlBusType,
    pub __bindgen_anon_1: IMPSensorInfo__bindgen_ty_1,
    #[doc = "< The reset pin of sensor, but it is invalid now."]
    pub rst_gpio: ::std::os::raw::c_ushort,
    #[doc = "< The power down pin of sensor, but it is invalid now."]
    pub pwdn_gpio: ::std::os::raw::c_ushort,
    #[doc = "< The power pin of sensor, but it is invalid now."]
    pub power_gpio: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPSensorInfo__bindgen_ty_1 {
    #[doc = "< I2C bus information"]
    pub i2c: IMPI2CInfo,
    #[doc = "< SPI bus information"]
    pub spi: IMPSPIInfo,
}
#[test]
fn bindgen_test_layout_IMPSensorInfo__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<IMPSensorInfo__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPSensorInfo__bindgen_ty_1>(),
        36usize,
        concat!("Size of: ", stringify!(IMPSensorInfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPSensorInfo__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPSensorInfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSensorInfo__bindgen_ty_1),
            "::",
            stringify!(i2c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSensorInfo__bindgen_ty_1),
            "::",
            stringify!(spi)
        )
    );
}
#[test]
fn bindgen_test_layout_IMPSensorInfo() {
    const UNINIT: ::std::mem::MaybeUninit<IMPSensorInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPSensorInfo>(),
        80usize,
        concat!("Size of: ", stringify!(IMPSensorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPSensorInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPSensorInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSensorInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbus_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSensorInfo),
            "::",
            stringify!(cbus_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rst_gpio) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSensorInfo),
            "::",
            stringify!(rst_gpio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pwdn_gpio) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSensorInfo),
            "::",
            stringify!(pwdn_gpio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).power_gpio) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPSensorInfo),
            "::",
            stringify!(power_gpio)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Open(void)\n\n Open the ISP module\n\n @param none\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark After calling the function,it first creates the ISP module, then prepares to add sensor to ISP, and starts the ISP effect debugging function.\n\n @attention Before adding sensor image, this function must be called firstly."]
    pub fn IMP_ISP_Open() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Close(void)\n\n Close the ISP module\n\n @param none\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark After calling the function, ISP will stop working.\n\n @attention Before calling this function, make sure that all FrameSources and effect debugging functions are off(disabled), and all sensors are deleted."]
    pub fn IMP_ISP_Close() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetDefaultBinPath(char *path)\n\n Sets the default path to the ISP bin file.\n\n @param[in] path  The bin file path property to set.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Sets the absolute path to the Bin file when the user-defined ISP is started.\n\n @attention This function must be called before adding the sensor and after opening the ISP."]
    pub fn IMP_ISP_SetDefaultBinPath(path: *mut ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetDefaultBinPath(char *path)\n\n Gets the default path to the ISP bin file.\n\n @param[out] path  The bin file path property to get.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Get the absolute path to the Bin file when the user-defined ISP is started.\n\n @attention This function must be called after the sensor is added.\n @attention Only bin file path attributes for a single ISP can be retrieved at a time."]
    pub fn IMP_ISP_GetDefaultBinPath(path: *mut ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_AddSensor(IMPSensorInfo *pinfo)\n\n Add a sensor into ISP module.\n\n @param[in] pinfo The pointer for the sensor information.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark The sensor will be used to capture image.\n\n @attention Before using this function, you must ensure that the camera driver has been registered into the kernel."]
    pub fn IMP_ISP_AddSensor(pinfo: *mut IMPSensorInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DelSensor(IMPSensorInfo *pinfo)\n\n Delete a sensor from ISP module.\n\n @param[in] pinfo The pointer for the sensor information\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Delete a sensor(image sensor which would be a camera)\n\n @attention Before using this function, you must ensure that the sensor has been stopped working, use IMP_ISP_DisableSensor function to do so."]
    pub fn IMP_ISP_DelSensor(pinfo: *mut IMPSensorInfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_EnableSensor(void)\n\n Enable the registered sensor.\n\n @param none\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Enable the registered sensor, then FrameSource can ouput image and ISP tuns on the image effects.\n\n @attention Before using this function, you must ensure that the sensor is already registered into ISP module."]
    pub fn IMP_ISP_EnableSensor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DisableSensor(void)\n\n Disable the running sensor.\n\n @param none\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark  if a sensor is not used, FrameSource and ISP won't be working either.\n\n @attention Before using this function, you must ensure that the Framesource and ISP have stopped working."]
    pub fn IMP_ISP_DisableSensor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_SetSensorRegister(uint32_t reg, uint32_t value)\n\n Set the value of a register of a sensor.\n\n @param[in] reg \tThe address of the register.\n\n @param[in] value \tThe value of the register.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Value of a register can be directly set.\n\n @attention Before using this function, you must ensure that the sensor is working, so it will be able to be configured or set."]
    pub fn IMP_ISP_SetSensorRegister(reg: u32, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_GetSensorRegister(uint32_t reg, uint32_t *value)\n\n Obtain a value of the register of sensor.\n\n @param[in] reg \tThe address of the register.\n\n @param[in] value \tThe pointer of register value.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark You can directly obtain the value of the sensor's register.\n\n @attention Before using this function, you must ensure that the sensor is working."]
    pub fn IMP_ISP_GetSensorRegister(reg: u32, value: *mut u32) -> ::std::os::raw::c_int;
}
#[doc = "< DISABLE mode of the current module"]
pub const IMPISPTuningOpsMode_IMPISP_TUNING_OPS_MODE_DISABLE: IMPISPTuningOpsMode = 0;
#[doc = "< ENABLE mode of the current module"]
pub const IMPISPTuningOpsMode_IMPISP_TUNING_OPS_MODE_ENABLE: IMPISPTuningOpsMode = 1;
#[doc = "< effect paramater, parameters have to be less than this value"]
pub const IMPISPTuningOpsMode_IMPISP_TUNING_OPS_MODE_BUTT: IMPISPTuningOpsMode = 2;
#[doc = " ISP OPTION MODE parameter structure."]
pub type IMPISPTuningOpsMode = ::std::os::raw::c_uint;
#[doc = "< AUTO mode of the current module"]
pub const IMPISPTuningOpsType_IMPISP_TUNING_OPS_TYPE_AUTO: IMPISPTuningOpsType = 0;
#[doc = "< MANUAL mode of the current module"]
pub const IMPISPTuningOpsType_IMPISP_TUNING_OPS_TYPE_MANUAL: IMPISPTuningOpsType = 1;
#[doc = "< effect paramater, parameters have to be less than this value"]
pub const IMPISPTuningOpsType_IMPISP_TUNING_OPS_TYPE_BUTT: IMPISPTuningOpsType = 2;
#[doc = " ISP MODE property parameter structure."]
pub type IMPISPTuningOpsType = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPZone {
    #[doc = "< zone info"]
    pub zone: [[::std::os::raw::c_uint; 15usize]; 15usize],
}
#[test]
fn bindgen_test_layout_IMPISPZone() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPZone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPZone>(),
        900usize,
        concat!("Size of: ", stringify!(IMPISPZone))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPZone>(),
        1usize,
        concat!("Alignment of ", stringify!(IMPISPZone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zone) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPZone),
            "::",
            stringify!(zone)
        )
    );
}
#[doc = " ISP AutoZoom Attribution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAutoZoom {
    pub chan: ::std::os::raw::c_int,
    #[doc = " <channel num>"]
    pub scaler_enable: ::std::os::raw::c_int,
    #[doc = " <scaler function enable>"]
    pub scaler_outwidth: ::std::os::raw::c_int,
    #[doc = " <output picture width after scaler>"]
    pub scaler_outheight: ::std::os::raw::c_int,
    #[doc = " <output picture height after scaler>"]
    pub crop_enable: ::std::os::raw::c_int,
    #[doc = " <crop function enable>"]
    pub crop_left: ::std::os::raw::c_int,
    #[doc = " <crop starting abscissa>"]
    pub crop_top: ::std::os::raw::c_int,
    #[doc = " <crop starting ordinate>"]
    pub crop_width: ::std::os::raw::c_int,
    #[doc = " <output width after crop>"]
    pub crop_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPISPAutoZoom() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAutoZoom> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAutoZoom>(),
        36usize,
        concat!("Size of: ", stringify!(IMPISPAutoZoom))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAutoZoom>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAutoZoom))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chan) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(chan)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaler_enable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(scaler_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaler_outwidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(scaler_outwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaler_outheight) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(scaler_outheight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_enable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(crop_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_left) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(crop_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_top) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(crop_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_width) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(crop_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).crop_height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAutoZoom),
            "::",
            stringify!(crop_height)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAutoZoom(IMPISPAutoZoom *ispautozoom)\n\n setting Auto zoom parameters\n\n @param[in] Setting parameters for changing resolution\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using this function, you must ensure that 'IMP_ISP_EnableSensor' is working."]
    pub fn IMP_ISP_Tuning_SetAutoZoom(ispautozoom: *mut IMPISPAutoZoom) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_EnableTuning(void)\n\n Enable effect debugging of ISP\n\n @param none\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using this function, you must ensure that 'IMP_ISP_EnableSensor' is working."]
    pub fn IMP_ISP_EnableTuning() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_DisableTuning(void)\n\n Disable effect debugging of ISP\n\n @param none\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention First you must ensure that ISP is no longer working, then stop the sensor, after that you can use this function."]
    pub fn IMP_ISP_DisableTuning() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSensorFPS(uint32_t fps_num, uint32_t fps_den)\n\n Set the FPS of enabled sensor.\n\n @param[in] fps_num \tThe numerator value of FPS.\n @param[in] fps_den \tThe denominator value of FPS.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using this function, make sure that 'IMP_ISP_EnableSensor' and 'IMP_ISP_EnableTuning' are working properly."]
    pub fn IMP_ISP_Tuning_SetSensorFPS(fps_num: u32, fps_den: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorFPS(uint32_t *fps_num, uint32_t *fps_den)\n\n Get the FPS of enabled sensor.\n\n @param[in] fps_num The pointer for numerator value of FPS.\n @param[in] fps_den The pointer for denominator value of FPS.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using this function, make sure that 'IMP_ISP_EnableSensor' and 'IMP_ISP_EnableTuning' are working properly.\n @attention Before starting data transmission in a Channel, you must first call this function in order to obtain the sensor's default FPS."]
    pub fn IMP_ISP_Tuning_GetSensorFPS(
        fps_num: *mut u32,
        fps_den: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Disable antiflicker module"]
pub const IMPISPAntiflickerAttr_IMPISP_ANTIFLICKER_DISABLE: IMPISPAntiflickerAttr = 0;
#[doc = "< Enable antiflicker module and set the frequency to 50HZ"]
pub const IMPISPAntiflickerAttr_IMPISP_ANTIFLICKER_50HZ: IMPISPAntiflickerAttr = 1;
#[doc = "< Enable antiflicker module and set the frequencye to 60HZ"]
pub const IMPISPAntiflickerAttr_IMPISP_ANTIFLICKER_60HZ: IMPISPAntiflickerAttr = 2;
#[doc = "< effect parameter, parameters have to be less than this value"]
pub const IMPISPAntiflickerAttr_IMPISP_ANTIFLICKER_BUTT: IMPISPAntiflickerAttr = 3;
#[doc = " ISP Anti-flicker property parameter structure."]
pub type IMPISPAntiflickerAttr = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAntiFlickerAttr(IMPISPAntiflickerAttr attr)\n\n Set the antiflicker parameter.\n\n @param[in] attr \tThe value for antiflicker mode\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before calling this function, make sure that ISP debugging function is working."]
    pub fn IMP_ISP_Tuning_SetAntiFlickerAttr(attr: IMPISPAntiflickerAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAntiFlickerAttr(IMPISPAntiflickerAttr *pattr)\n\n Get the mode of antiflicker\n\n @param[in] pattr The pointer for antiflicker mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before calling this function, make sure that ISP debugging function is working."]
    pub fn IMP_ISP_Tuning_GetAntiFlickerAttr(
        pattr: *mut IMPISPAntiflickerAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBrightness(unsigned char bright)\n\n Set the brightness of image effect.\n\n @param[in] bright The value for brightness.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark The default value is 128, more than 128 that means increase brightness, and less than 128 that means decrease brightness.\\n\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetBrightness(bright: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBrightness(unsigned char *pbright)\n\n Get the brightness of image effect.\n\n @param[in] pbright The pointer for brightness value.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark The default value is 128, more than 128 (increase brightness), and less than 128 (decrease brightness).\\n\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetBrightness(
        pbright: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetContrast(unsigned char contrast)\n\n Set the contrast of image effect.\n\n @param[in] contrast \t\tThe value for contrast.\n\n @retval 0 means success.\n @retval Other value means failure, its value is an error code.\n\n @remark The default value is 128, more than 128 (increase contrast), and less than 128 (decrease contrast).\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetContrast(contrast: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetContrast(unsigned char *pcontrast)\n\n Get the contrast of image effect.\n\n @param[in] pcontrast \tThe pointer for contrast.\n\n @retval 0 means success.\n @retval Other value means failure, its value is an error code.\n\n @remark The default value is 128, more than 128 (increase contrast), and less than 128 (decrease contrast).\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetContrast(
        pcontrast: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSharpness(unsigned char sharpness)\n\n Set the sharpness of image effect.\n\n @param[in] sharpness \tThe value for sharpening strength.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark The default value is 128, more than 128 (increase sharpening), and less than 128 (decrease sharpening).\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetSharpness(sharpness: ::std::os::raw::c_uchar)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSharpness(unsigned char *psharpness)\n\n Get the sharpness of image effect.\n\n @param[in] psharpness \tThe pointer for sharpness strength.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark The default value is 128, more than 128 (increase sharpening), and less than 128 (decrease sharpening).\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetSharpness(
        psharpness: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBcshHue(unsigned char hue)\n\n Set the hue of image color.\n\n @param[in] hue The value of hue, range from 0 to 255, default 128.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark The default value is 128, more than 128 that means increase hue, and less than 128 that means decrease hue.\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetBcshHue(hue: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBcshHue(unsigned char *hue)\n\n Get the hue of image color.\n\n @param[in] hue The pointer for hue value.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark The default value is 128, more than 128 (increase hue), and less than 128 (decrease hue).\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetBcshHue(hue: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSaturation(unsigned char sat)\n\n Set the saturation of image effect.\n\n @param[in] sat \tThe value for saturation strength.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark  The default value is 128, more than 128 (increase saturation), and less than 128 (decrease saturation).\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetSaturation(sat: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSaturation(unsigned char *psat)\n\n Get the saturation of image effect.\n\n @param[in] psat\t The pointer for saturation strength.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark  The default value is 128, more than 128 (increase saturation), and less than 128 (decrease saturation).\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetSaturation(
        psat: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPBypass(IMPISPTuningOpsMode enable)\n\n Control ISP modules.\n\n @param[in] enable \tbypass output mode (yes / no)\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark none\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetISPBypass(enable: IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetTotalGain(uint32_t *gain)\n\n Get the overall gain value of the ISP output image\n\n @param[in] gain \tThe pointer of total gain value, its format is [24.8], 24 (integer), 8(decimal)\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using this function, make sure that 'IMP_ISP_EnableSensor' and 'IMP_ISP_EnableTuning' are working properly."]
    pub fn IMP_ISP_Tuning_GetTotalGain(gain: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPHflip(IMPISPTuningOpsMode mode)\n\n Set ISP image mirror(horizontal) effect function (enable/disable)\n\n @param[in] mode \tThe hflip (enable/disable).\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Left and Right flip.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetISPHflip(mode: IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPHflip(IMPISPTuningOpsMode *pmode)\n\n Get ISP image mirror(horizontal) effect function (enable/disable)\n\n @param[in] pmode The pointer for the hflip mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Left and Right flip.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetISPHflip(pmode: *mut IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPVflip(IMPISPTuningOpsMode mode)\n\n Set ISP image mirror(vertical) effect function (enable/disable)\n\n @param[in] mode \tThe vflip enable.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark UP and DOWN flip.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetISPVflip(mode: IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPVflip(IMPISPTuningOpsMode *pmode)\n\n Get ISP image mirror(vertical) effect function (enable/disable)\n\n @param[in] pmode The pointer for the vflip mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark UP and DOWN flip.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetISPVflip(pmode: *mut IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
#[doc = "< ISP day mode"]
pub const IMPISPRunningMode_IMPISP_RUNNING_MODE_DAY: IMPISPRunningMode = 0;
#[doc = "< ISP night mode"]
pub const IMPISPRunningMode_IMPISP_RUNNING_MODE_NIGHT: IMPISPRunningMode = 1;
#[doc = "< maximum value"]
pub const IMPISPRunningMode_IMPISP_RUNNING_MODE_BUTT: IMPISPRunningMode = 2;
#[doc = " Defines the enumeration of ISP working mode."]
pub type IMPISPRunningMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPRunningMode(IMPISPRunningMode mode)\n\n Set ISP running mode, normal mode or night vision mode; default mode: normal mode.\n\n @param[in] mode  running mode parameter\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n Example:\n @code\n IMPISPRunningMode mode;\n\n\tif( it is during a night now){\nmode = IMPISP_RUNNING_MODE_NIGHT\n}else{\nmode = IMPISP_RUNNING_MODE_DAY;\n}\nret = IMP_ISP_Tuning_SetISPRunningMode(mode);\nif(ret){\nIMP_LOG_ERR(TAG, \"IMP_ISP_Tuning_SetISPRunningMode error !\\n\");\nreturn -1;\n}\n\n @endcode\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetISPRunningMode(mode: IMPISPRunningMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPRunningMode(IMPISPRunningMode *pmode)\n\n Get ISP running mode, normal mode or night vision mode;\n\n @param[in] pmode The pointer of the running mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetISPRunningMode(pmode: *mut IMPISPRunningMode)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetISPCustomMode(IMPISPTuningOpsMode mode)\n\n Enable ISP custom mode, load another set of parameters.\n\n @param[in] mode Custom mode, enable or disable.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetISPCustomMode(mode: IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetISPCustomMode(IMPISPTuningOpsMode mode)\n\n get ISP custom mode\n\n @param[out] mode Custom mode, enable or disable.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetISPCustomMode(
        pmode: *mut IMPISPTuningOpsMode,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Defines the attribute of gamma."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPGamma {
    #[doc = "< The array of gamma attribute has 129 elements"]
    pub gamma: [u16; 129usize],
}
#[test]
fn bindgen_test_layout_IMPISPGamma() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPGamma> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPGamma>(),
        258usize,
        concat!("Size of: ", stringify!(IMPISPGamma))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPGamma>(),
        2usize,
        concat!("Alignment of ", stringify!(IMPISPGamma))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gamma) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPGamma),
            "::",
            stringify!(gamma)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetGamma(IMPISPGamma *gamma)\n\n Sets the attributes of ISP gamma.\n\n @param[in] gamma \tThe pointer of the attributes.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetGamma(gamma: *mut IMPISPGamma) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetGamma(IMPISPGamma *gamma)\n\n Obtains the attributes of gamma.\n\n @param[out] gamma \tThe address of the attributes.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetGamma(gamma: *mut IMPISPGamma) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeComp(int comp)\n\n Setting AE compensation.AE compensation parameters can adjust the target of the image AE.\n the recommended value range is from 0 to 255.\n\n @param[in] comp \tcompensation parameter.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetAeComp(comp: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeComp(int *comp)\n\n Obtains the compensation of AE.\n\n @param[out] comp \tThe pointer of the compensation.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetAeComp(comp: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeLuma(int *luma)\n\n Obtains the AE luma of current frame.\n\n @param[out] luma AE luma parameter.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetAeLuma(luma: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeFreeze(IMPISPTuningOpsMode mode)\n\n AE Freeze.\n\n @param[in] mode AE Freeze mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeFreeze(mode: IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
#[doc = "< Auto exposure mode"]
pub const isp_core_expr_mode_ISP_CORE_EXPR_MODE_AUTO: isp_core_expr_mode = 0;
#[doc = "< Manual exposure mode"]
pub const isp_core_expr_mode_ISP_CORE_EXPR_MODE_MANUAL: isp_core_expr_mode = 1;
#[doc = " exposure mode."]
pub type isp_core_expr_mode = ::std::os::raw::c_uint;
#[doc = "< The unit is integration line"]
pub const isp_core_expr_unit_ISP_CORE_EXPR_UNIT_LINE: isp_core_expr_unit = 0;
#[doc = "< The unit is millisecond"]
pub const isp_core_expr_unit_ISP_CORE_EXPR_UNIT_US: isp_core_expr_unit = 1;
#[doc = " exposure unit."]
pub type isp_core_expr_unit = ::std::os::raw::c_uint;
#[doc = " exposure parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union isp_core_expr_attr {
    pub s_attr: isp_core_expr_attr__bindgen_ty_1,
    pub g_attr: isp_core_expr_attr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_expr_attr__bindgen_ty_1 {
    #[doc = "< set the exposure mode"]
    pub mode: isp_core_expr_mode,
    #[doc = "< set the exposure unit"]
    pub unit: isp_core_expr_unit,
    pub time: u16,
}
#[test]
fn bindgen_test_layout_isp_core_expr_attr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<isp_core_expr_attr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_core_expr_attr__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(isp_core_expr_attr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_expr_attr__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(isp_core_expr_attr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr__bindgen_ty_1),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr__bindgen_ty_1),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr__bindgen_ty_1),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_expr_attr__bindgen_ty_2 {
    #[doc = "< exposure mode obtained"]
    pub mode: isp_core_expr_mode,
    #[doc = "< The integration time, the unit is line."]
    pub integration_time: u16,
    #[doc = "< The min value of integration time, the unit is line."]
    pub integration_time_min: u16,
    #[doc = "< The max value of integration time, the unit is line."]
    pub integration_time_max: u16,
    #[doc = "< A integration line correspond to the time (ms)"]
    pub one_line_expr_in_us: u16,
}
#[test]
fn bindgen_test_layout_isp_core_expr_attr__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<isp_core_expr_attr__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_core_expr_attr__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(isp_core_expr_attr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_expr_attr__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(isp_core_expr_attr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr__bindgen_ty_2),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integration_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr__bindgen_ty_2),
            "::",
            stringify!(integration_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integration_time_min) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr__bindgen_ty_2),
            "::",
            stringify!(integration_time_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integration_time_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr__bindgen_ty_2),
            "::",
            stringify!(integration_time_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).one_line_expr_in_us) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr__bindgen_ty_2),
            "::",
            stringify!(one_line_expr_in_us)
        )
    );
}
#[test]
fn bindgen_test_layout_isp_core_expr_attr() {
    const UNINIT: ::std::mem::MaybeUninit<isp_core_expr_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_core_expr_attr>(),
        12usize,
        concat!("Size of: ", stringify!(isp_core_expr_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_expr_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(isp_core_expr_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr),
            "::",
            stringify!(s_attr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_attr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_expr_attr),
            "::",
            stringify!(g_attr)
        )
    );
}
#[doc = " exposure parameters."]
pub type IMPISPExpr = isp_core_expr_attr;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetExpr(IMPISPExpr *expr)\n\n Set AE attributes.\n\n @param[in] expr \tThe pointer for exposure attributes.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetExpr(expr: *mut IMPISPExpr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetExpr(IMPISPExpr *expr)\n\n Get AE attributes.\n\n @param[in] expr The pointer for exposure attributes.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetExpr(expr: *mut IMPISPExpr) -> ::std::os::raw::c_int;
}
#[doc = " exposure region of interest."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union isp_core_ae_roi_select {
    pub __bindgen_anon_1: isp_core_ae_roi_select__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_ae_roi_select__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_isp_core_ae_roi_select__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<isp_core_ae_roi_select__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(isp_core_ae_roi_select__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_ae_roi_select__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(isp_core_ae_roi_select__bindgen_ty_1)
        )
    );
}
impl isp_core_ae_roi_select__bindgen_ty_1 {
    #[inline]
    pub fn endy(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_endy(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn endx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_endx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn starty(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_starty(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn startx(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_startx(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        endy: ::std::os::raw::c_uint,
        endx: ::std::os::raw::c_uint,
        starty: ::std::os::raw::c_uint,
        startx: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let endy: u32 = unsafe { ::std::mem::transmute(endy) };
            endy as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let endx: u32 = unsafe { ::std::mem::transmute(endx) };
            endx as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let starty: u32 = unsafe { ::std::mem::transmute(starty) };
            starty as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let startx: u32 = unsafe { ::std::mem::transmute(startx) };
            startx as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_isp_core_ae_roi_select() {
    const UNINIT: ::std::mem::MaybeUninit<isp_core_ae_roi_select> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_core_ae_roi_select>(),
        4usize,
        concat!("Size of: ", stringify!(isp_core_ae_roi_select))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_ae_roi_select>(),
        4usize,
        concat!("Alignment of ", stringify!(isp_core_ae_roi_select))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_ae_roi_select),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " exposure region of interest."]
pub type IMPISPAERoi = isp_core_ae_roi_select;
#[doc = "< Auto WB mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_AUTO: isp_core_wb_mode = 0;
#[doc = "< Manual WB mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_MANUAL: isp_core_wb_mode = 1;
#[doc = "< Day-light mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_DAY_LIGHT: isp_core_wb_mode = 2;
#[doc = "< Cloudy day mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_CLOUDY: isp_core_wb_mode = 3;
#[doc = "< Incandescent mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_INCANDESCENT: isp_core_wb_mode = 4;
#[doc = "< Fluorescent mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_FLOURESCENT: isp_core_wb_mode = 5;
#[doc = "< Twilight mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_TWILIGHT: isp_core_wb_mode = 6;
#[doc = "< Shade mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_SHADE: isp_core_wb_mode = 7;
#[doc = "< Warm color fluorescent mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_WARM_FLOURESCENT: isp_core_wb_mode = 8;
#[doc = "< Custom mode"]
pub const isp_core_wb_mode_ISP_CORE_WB_MODE_CUSTOM: isp_core_wb_mode = 9;
#[doc = " White balance mode."]
pub type isp_core_wb_mode = ::std::os::raw::c_uint;
#[doc = " White balance attributes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_wb_attr {
    #[doc = "< The mode for WB; auto and manual mode"]
    pub mode: isp_core_wb_mode,
    #[doc = "< red gain attribute, manual mode is effective"]
    pub rgain: u16,
    #[doc = "< blue gain attribute, manual mode is effective"]
    pub bgain: u16,
}
#[test]
fn bindgen_test_layout_isp_core_wb_attr() {
    const UNINIT: ::std::mem::MaybeUninit<isp_core_wb_attr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_core_wb_attr>(),
        8usize,
        concat!("Size of: ", stringify!(isp_core_wb_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_wb_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(isp_core_wb_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_wb_attr),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgain) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_wb_attr),
            "::",
            stringify!(rgain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bgain) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_wb_attr),
            "::",
            stringify!(bgain)
        )
    );
}
#[doc = " White balance attributes."]
pub type IMPISPWB = isp_core_wb_attr;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB(IMPISPWB *wb)\n\n Set the white balance function settings. You can set the automatic and manual mode, manual mode is achieved mainly through setting of bgain, rgain.\n\n @param[in] wb \tThe pointer for WB attribute.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetWB(wb: *mut IMPISPWB) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetWB(IMPISPWB *wb)\n\n Get the white balance function settings\n\n @param[in] wb \tThe pointer for WB attribute.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetWB(wb: *mut IMPISPWB) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_Statis(IMPISPWB *wb)\n\n Get the white balance statistic value.\n\n @param[out] wb \tThe pointer for the statistic.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetWB_Statis(wb: *mut IMPISPWB) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_GetWB_GOL_Statis(IMPISPWB *wb)\n\n Get the white balance global statistic value.\n\n @param[out] wb \tThe pointer for the statistic.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetWB_GOL_Statis(wb: *mut IMPISPWB) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBCluster {
    pub ClusterEn: IMPISPTuningOpsMode,
    pub ToleranceEn: IMPISPTuningOpsMode,
    pub tolerance_th: ::std::os::raw::c_uint,
    pub awb_cluster: [::std::os::raw::c_uint; 7usize],
}
#[test]
fn bindgen_test_layout_IMPISPAWBCluster() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAWBCluster> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAWBCluster>(),
        40usize,
        concat!("Size of: ", stringify!(IMPISPAWBCluster))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAWBCluster>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAWBCluster))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ClusterEn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBCluster),
            "::",
            stringify!(ClusterEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ToleranceEn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBCluster),
            "::",
            stringify!(ToleranceEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tolerance_th) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBCluster),
            "::",
            stringify!(tolerance_th)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_cluster) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBCluster),
            "::",
            stringify!(awb_cluster)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbClust(IMPISPAWBCluster *awb_cluster);\n\n Set Cluster AWB mode Parameters.\n\n @param[in] awb_cluster  contains cluster awb mode parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetAwbClust(awb_cluster: *mut IMPISPAWBCluster) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbClust(IMPISPAWBCluster *awb_cluster);\n\n Get Cluster AWB mode Parameters.\n\n @param[out] awb_cluster  contains cluster awb mode parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetAwbClust(awb_cluster: *mut IMPISPAWBCluster) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBCtTrend {
    pub trend_array: [::std::os::raw::c_uint; 6usize],
}
#[test]
fn bindgen_test_layout_IMPISPAWBCtTrend() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAWBCtTrend> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAWBCtTrend>(),
        24usize,
        concat!("Size of: ", stringify!(IMPISPAWBCtTrend))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAWBCtTrend>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAWBCtTrend))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trend_array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBCtTrend),
            "::",
            stringify!(trend_array)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbCtTrend(IMPISPAWBCtTrend *ct_trend);\n\n\n Set rg bg offset under different ct.\n\n @param[in] ct_trend  contains ct offset parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetAwbCtTrend(ct_trend: *mut IMPISPAWBCtTrend) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbCtTrend(IMPISPAWBCtTrend *ct_trend);\n\n\n Get rg bg offset under different ct.\n\n @param[out] ct_trend  contains current ct offset parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetAwbCtTrend(ct_trend: *mut IMPISPAWBCtTrend) -> ::std::os::raw::c_int;
}
#[doc = " ISP WB COEFFT parameter structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_rgb_coefft_wb_attr {
    #[doc = "< rgain offset"]
    pub rgb_coefft_wb_r: ::std::os::raw::c_ushort,
    #[doc = "< ggain offset"]
    pub rgb_coefft_wb_g: ::std::os::raw::c_ushort,
    #[doc = "< bgain offset"]
    pub rgb_coefft_wb_b: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_isp_core_rgb_coefft_wb_attr() {
    const UNINIT: ::std::mem::MaybeUninit<isp_core_rgb_coefft_wb_attr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_core_rgb_coefft_wb_attr>(),
        6usize,
        concat!("Size of: ", stringify!(isp_core_rgb_coefft_wb_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_rgb_coefft_wb_attr>(),
        2usize,
        concat!("Alignment of ", stringify!(isp_core_rgb_coefft_wb_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgb_coefft_wb_r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_rgb_coefft_wb_attr),
            "::",
            stringify!(rgb_coefft_wb_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgb_coefft_wb_g) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_rgb_coefft_wb_attr),
            "::",
            stringify!(rgb_coefft_wb_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rgb_coefft_wb_b) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_rgb_coefft_wb_attr),
            "::",
            stringify!(rgb_coefft_wb_b)
        )
    );
}
#[doc = " ISP WB COEFFT parameter structure."]
pub type IMPISPCOEFFTWB = isp_core_rgb_coefft_wb_attr;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_Awb_GetRgbCoefft(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr);\n\n Set the AWB r g b channel offset source in ISP.\n\n @param[out] isp_wb_attr  The pointer for the attributes\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_Awb_GetRgbCoefft(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_Awb_SetRgbCoefft(IMPISPCOEFFTWB *isp_core_rgb_coefft_wb_attr)\n\n Sets the Max value of sensor color r g b.\n\n @param[in] gain  The value for sensor sensor color r g b..\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_Awb_SetRgbCoefft(
        isp_core_rgb_coefft_wb_attr: *mut IMPISPCOEFFTWB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxAgain(uint32_t gain)\n\n Sets the Max value of sensor analog gain.\n\n @param[in] gain  The value for sensor analog gain.\n The value of 0 corresponds to 1x gain, 32 corresponds to 2x gain and so on.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetMaxAgain(gain: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxAgain(uint32_t *gain)\n\n Get the Max value of sensor analog gain.\n\n @param[in] gain  The pointer for sensor analog gain.\n The value of 0 corresponds to 1x gain, 32 corresponds to 2x gain and so on.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetMaxAgain(gain: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMaxDgain(uint32_t gain)\n\n Set the Max value of sensor Digital gain.\n\n @param[in] gain \tThe pointer for sensor digital gain.\n The value of 0 corresponds to 1x gain, 32 corresponds to 2x gain and so on.\n\n @retval 0 success\n @retval others failure\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly.\n Sets the Max value of isp digital gain.。\n\n @param[in] gain The value for isp digital gain. The value of 0 corresponds to 1x gain, 32 corresponds to 2x gain and so on.\n\n @retval 0 means success.\n @retval Other values means failure, its value is an error code.\n\n @attention When the interface is called, 'IMP_ISP_EnableTuning' has returned successfully."]
    pub fn IMP_ISP_Tuning_SetMaxDgain(gain: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMaxDgain(uint32_t *gain)\n\n Get the Max value of sensor Digital gain.\n\n @param[out] gain \tThe pointer for sensor digital gain.\n The value of 0 corresponds to 1x gain, 32 corresponds to 2x gain and so on.\n\n @retval 0 success\n @retval others failure\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetMaxDgain(gain: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetVideoDrop(void (*cb)(void))\n\n Set the video loss function. When there is a problem with the connection line of the sensor board, the callback function will be executed.\n\n @param[in] cb \tThe pointer for callback function.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetVideoDrop(
        cb: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHiLightDepress(uint32_t strength)\n\n Set highlight intensity controls.\n\n @param[in] strength \tHighlight control parameter, the value range is [0-10], set to 0 means disable the current function.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetHiLightDepress(strength: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHiLightDepress(uint32_t *strength)\n\n Get the strength of high light depress.\n\n @param[out] strength \tThe pointer for hilight depress strength.\n The value of 0 corresponds to disable.\n\n @retval 0 success\n @retval others failure\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetHiLightDepress(strength: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetBacklightComp(uint32_t strength)\n\n Set backlight intensity controls.\n\n @param[in] strength \tBacklight control parameter, the value range is [0-10], set to 0 means disable the current function.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetBacklightComp(strength: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBacklightComp(uint32_t *strength)\n\n Get the strength of backlight compensation.\n\n @param[out] strength \tThe pointer for backlight compensation strength.\n The value of 0 corresponds to disable.\n\n @retval 0 success\n @retval others failure\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetBacklightComp(strength: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetTemperStrength(uint32_t ratio)\n\n Set 3D noise reduction intensity\n\n @param[in] ratio   Intensity modulation ratio. Default value is 128.If it is greater than 128, that means increaseing the temper value. If it is less than 128, that means decreaing the temper value. The value range is [0-255].\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetTemperStrength(ratio: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetSinterStrength(uint32_t ratio)\n\n Set 2D noise reduction intensity\n\n @param[in] ratio   Intensity modulation ratio. Default value is 128.If it is greater than 128, that means increaseing the sinter value. If it is less than 128, that means decreaing the sinter value. The value range is [0-255].\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetSinterStrength(ratio: u32) -> ::std::os::raw::c_int;
}
#[doc = " attributes of ISP exposure value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPEVAttr {
    #[doc = "< exposure value"]
    pub ev: u32,
    #[doc = "< exposure time in millisecond"]
    pub expr_us: u32,
    #[doc = "< exposure time in log2 format"]
    pub ev_log2: u32,
    #[doc = "< Analog gain"]
    pub again: u32,
    #[doc = "< Digital gain"]
    pub dgain: u32,
    #[doc = "< Gain in log2 format"]
    pub gain_log2: u32,
}
#[test]
fn bindgen_test_layout_IMPISPEVAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPEVAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPEVAttr>(),
        24usize,
        concat!("Size of: ", stringify!(IMPISPEVAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPEVAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPEVAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPEVAttr),
            "::",
            stringify!(ev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expr_us) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPEVAttr),
            "::",
            stringify!(expr_us)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_log2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPEVAttr),
            "::",
            stringify!(ev_log2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).again) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPEVAttr),
            "::",
            stringify!(again)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dgain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPEVAttr),
            "::",
            stringify!(dgain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gain_log2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPEVAttr),
            "::",
            stringify!(gain_log2)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetEVAttr(IMPISPEVAttr *attr)\n\n Obtains the attributes of exposure value.\n @param[out] attr \tThe pointer for attributes.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetEVAttr(attr: *mut IMPISPEVAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableMovestate(void)\n\n When the sensor will motion, it should be called.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_EnableMovestate() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_Tuning_DisableMovestate(void)\n\n When the sensor is from motion to still, it should be called.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_Tuning_EnableMovestate' is working properly."]
    pub fn IMP_ISP_Tuning_DisableMovestate() -> ::std::os::raw::c_int;
}
#[doc = "< AUTO mode of the current module"]
pub const IMPISPTuningMode_IMPISP_TUNING_MODE_AUTO: IMPISPTuningMode = 0;
#[doc = "< MANUAL mode of the current module"]
pub const IMPISPTuningMode_IMPISP_TUNING_MODE_MANUAL: IMPISPTuningMode = 1;
#[doc = "< Set the range of current module"]
pub const IMPISPTuningMode_IMPISP_TUNING_MODE_RANGE: IMPISPTuningMode = 2;
#[doc = "< effect paramater, parameters have to be less than this value"]
pub const IMPISPTuningMode_IMPISP_TUNING_MODE_BUTT: IMPISPTuningMode = 3;
#[doc = " Mode selection"]
pub type IMPISPTuningMode = ::std::os::raw::c_uint;
#[doc = " Weight information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPWeight {
    #[doc = "< The weight info of each zone [0 ~ 8]"]
    pub weight: [[::std::os::raw::c_uchar; 15usize]; 15usize],
}
#[test]
fn bindgen_test_layout_IMPISPWeight() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPWeight> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPWeight>(),
        225usize,
        concat!("Size of: ", stringify!(IMPISPWeight))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPWeight>(),
        1usize,
        concat!("Alignment of ", stringify!(IMPISPWeight))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weight) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPWeight),
            "::",
            stringify!(weight)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeWeight(IMPISPWeight *ae_weight)\n\n Set zone weighting for AE target\n\n @param[in] ae_weight aexp weight.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeWeight(ae_weight: *mut IMPISPWeight) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeWeight(IMPISPWeight *ae_weight)\n\n Get zone weighting for AE target\n\n @param[out] ae_weight aexp weight.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeWeight(ae_weight: *mut IMPISPWeight) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_GetROI(IMPISPWeight *roi_weight)\n\n Set roi weighting for AE SCENE judgement\n\n @param[out] roi_weight aexp weight.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_AE_GetROI(roi_weight: *mut IMPISPWeight) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_AE_SetROI(IMPISPWeight *roi_weight)\n\n Set roi weighting for AE SCENE judgement\n\n @param[in] roi_weight aexp weight.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_AE_SetROI(roi_weight: *mut IMPISPWeight) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbWeight(IMPISPWeight *awb_weight)\n\n Set zone weighting for AWB\n\n @param[in] awb_weight awb weight.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAwbWeight(awb_weight: *mut IMPISPWeight) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbWeight(IMPISPWeight *awb_weight)\n\n Get zone weighting for AWB\n\n @param[out] awb_weight awb weight。\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAwbWeight(awb_weight: *mut IMPISPWeight) -> ::std::os::raw::c_int;
}
#[doc = " AWB statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBZone {
    #[doc = "< 15*15 statistical average of each zone in R channel"]
    pub zone_r: [::std::os::raw::c_uchar; 225usize],
    #[doc = "< 15*15 statistical average of each zone in G channel"]
    pub zone_g: [::std::os::raw::c_uchar; 225usize],
    #[doc = "< 15*15 statistical average of each zone in B channel"]
    pub zone_b: [::std::os::raw::c_uchar; 225usize],
}
#[test]
fn bindgen_test_layout_IMPISPAWBZone() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAWBZone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAWBZone>(),
        675usize,
        concat!("Size of: ", stringify!(IMPISPAWBZone))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAWBZone>(),
        1usize,
        concat!("Alignment of ", stringify!(IMPISPAWBZone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zone_r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBZone),
            "::",
            stringify!(zone_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zone_g) as usize - ptr as usize },
        225usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBZone),
            "::",
            stringify!(zone_g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zone_b) as usize - ptr as usize },
        450usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBZone),
            "::",
            stringify!(zone_b)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbZone(IMPISPAWBZONE *awb_zone)\n\n Get WB zone statistical average in R G B channel\n\n @param[out] awb_zone wb statistics。\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAwbZone(awb_zone: *mut IMPISPAWBZone) -> ::std::os::raw::c_int;
}
pub const IMPISPAWBAlgo_IMPISP_AWB_ALGO_NORMAL: IMPISPAWBAlgo = 0;
pub const IMPISPAWBAlgo_IMPISP_AWB_ALGO_GRAYWORLD: IMPISPAWBAlgo = 1;
pub const IMPISPAWBAlgo_IMPISP_AWB_ALGO_REWEIGHT: IMPISPAWBAlgo = 2;
#[doc = " AWB algorithm"]
pub type IMPISPAWBAlgo = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetWB_ALGO(IMPISPAWBALGO wb_algo)\n\n Set AWB algorithm for different application situation\n\n @param[in] awb algorithm\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetWB_ALGO(wb_algo: IMPISPAWBAlgo) -> ::std::os::raw::c_int;
}
#[doc = " AE statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEHist {
    #[doc = "< AE Histogram threshold for bin boundary.[0 ~ 255]"]
    pub ae_histhresh: [::std::os::raw::c_uchar; 4usize],
    #[doc = "< Normalized histogram results for bin.[0 ~ 65535]"]
    pub ae_hist: [::std::os::raw::c_ushort; 5usize],
    #[doc = "< Number of active zones horizontally for AE stats collection.[0 ~ 15]"]
    pub ae_stat_nodeh: ::std::os::raw::c_uchar,
    #[doc = "< Number of active zones vertically for AE stats collection.[0 ~ 15]"]
    pub ae_stat_nodev: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_IMPISPAEHist() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAEHist> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAEHist>(),
        16usize,
        concat!("Size of: ", stringify!(IMPISPAEHist))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAEHist>(),
        2usize,
        concat!("Alignment of ", stringify!(IMPISPAEHist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_histhresh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEHist),
            "::",
            stringify!(ae_histhresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_hist) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEHist),
            "::",
            stringify!(ae_hist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_stat_nodeh) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEHist),
            "::",
            stringify!(ae_stat_nodeh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_stat_nodev) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEHist),
            "::",
            stringify!(ae_stat_nodev)
        )
    );
}
#[doc = " AE statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEHistOrigin {
    #[doc = "< AE histogram results for 256 bin"]
    pub ae_hist: [::std::os::raw::c_uint; 256usize],
}
#[test]
fn bindgen_test_layout_IMPISPAEHistOrigin() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAEHistOrigin> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAEHistOrigin>(),
        1024usize,
        concat!("Size of: ", stringify!(IMPISPAEHistOrigin))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAEHistOrigin>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAEHistOrigin))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_hist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEHistOrigin),
            "::",
            stringify!(ae_hist)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeHist(IMPISPAEHist *ae_hist)\n\n Set AE statistics parameters\n\n @param[in] ae_hist AE statictics parameters.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeHist(ae_hist: *mut IMPISPAEHist) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist(IMPISPAEHist *ae_hist)\n\n Get AE statistics information.\n\n @param[out] ae_hist AE statistics\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeHist(ae_hist: *mut IMPISPAEHist) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeHist_Origin(IMPISPAEHistOrigin *ae_hist)\n\n Get AE 256 bin statistics information.\n\n @param[out] ae_hist AE statistics\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeHist_Origin(
        ae_hist: *mut IMPISPAEHistOrigin,
    ) -> ::std::os::raw::c_int;
}
#[doc = " AWB statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_awb_sta_info {
    #[doc = "< AWB statistics R/G color ratio output [0 ~ 4095] 4.8bit fixed-point"]
    pub r_gain: ::std::os::raw::c_ushort,
    #[doc = "< AWB statistics B/G color ratio output [0 ~ 4095] 4.8bit fixed-point"]
    pub b_gain: ::std::os::raw::c_ushort,
    #[doc = "< Number of pixels used for AWB statistics [0 ~ 4294967295]"]
    pub awb_sum: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_isp_core_awb_sta_info() {
    const UNINIT: ::std::mem::MaybeUninit<isp_core_awb_sta_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_core_awb_sta_info>(),
        8usize,
        concat!("Size of: ", stringify!(isp_core_awb_sta_info))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_awb_sta_info>(),
        4usize,
        concat!("Alignment of ", stringify!(isp_core_awb_sta_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_gain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_awb_sta_info),
            "::",
            stringify!(r_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_gain) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_awb_sta_info),
            "::",
            stringify!(b_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_sum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_awb_sta_info),
            "::",
            stringify!(awb_sum)
        )
    );
}
#[doc = "< Legacy mode"]
pub const isp_core_awb_stats_mode_IMPISP_AWB_STATS_LEGACY_MODE: isp_core_awb_stats_mode = 0;
#[doc = "< Current mode"]
pub const isp_core_awb_stats_mode_IMPISP_AWB_STATS_CURRENT_MODE: isp_core_awb_stats_mode = 1;
pub const isp_core_awb_stats_mode_IMPISP_AWB_STATS_MODE_BUTT: isp_core_awb_stats_mode = 2;
#[doc = " AWB statictis mode"]
pub type isp_core_awb_stats_mode = ::std::os::raw::c_uint;
#[doc = " AWB statictis parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAWBHist {
    #[doc = "< AWB statistics"]
    pub awb_stat: isp_core_awb_sta_info,
    #[doc = "< AWB statistic mode"]
    pub awb_stats_mode: isp_core_awb_stats_mode,
    #[doc = "< Upper limit of valid data for AWB [0 ~ 1023]"]
    pub awb_whitelevel: ::std::os::raw::c_ushort,
    #[doc = "< lower limit of valid data for AWB [0 ~ 1023]"]
    pub awb_blacklevel: ::std::os::raw::c_ushort,
    #[doc = "< Maximum value of R/G for white region [0 ~ 4095] 4.8bit fixed-point"]
    pub cr_ref_max: ::std::os::raw::c_ushort,
    #[doc = "< Minimum value of R/G for white region [0 ~ 4095] 4.8bit fixed-point"]
    pub cr_ref_min: ::std::os::raw::c_ushort,
    #[doc = "< Maximum value of B/G for white region [0 ~ 4095] 4.8bit fixed-point"]
    pub cb_ref_max: ::std::os::raw::c_ushort,
    #[doc = "< Minimum value of B/G for white region [0 ~ 4095] 4.8bit fixed-point"]
    pub cb_ref_min: ::std::os::raw::c_ushort,
    #[doc = "< Number of active zones horizontally for AWB stats collection.[0 ~ 15]"]
    pub awb_stat_nodeh: ::std::os::raw::c_uchar,
    #[doc = "< Number of active zones vertically for AWB stats collection.[0 ~ 15]"]
    pub awb_stat_nodev: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_IMPISPAWBHist() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAWBHist> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAWBHist>(),
        28usize,
        concat!("Size of: ", stringify!(IMPISPAWBHist))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAWBHist>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAWBHist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_stat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(awb_stat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_stats_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(awb_stats_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_whitelevel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(awb_whitelevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_blacklevel) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(awb_blacklevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_ref_max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(cr_ref_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr_ref_min) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(cr_ref_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_ref_max) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(cb_ref_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb_ref_min) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(cb_ref_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_stat_nodeh) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(awb_stat_nodeh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_stat_nodev) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAWBHist),
            "::",
            stringify!(awb_stat_nodev)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAwbHist(IMPISPAWBHist *awb_hist)\n\n Set AWB statistic parameters\n\n @param[out] awb_hist AWB statistic parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using this function, IMP_ISP_EnableTuning is called."]
    pub fn IMP_ISP_Tuning_GetAwbHist(awb_hist: *mut IMPISPAWBHist) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbHist(IMPISPAWBHist *awb_hist)\n\n Get AWB Statistics\n\n @param[out] awb_hist AWB statistic\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAwbHist(awb_hist: *mut IMPISPAWBHist) -> ::std::os::raw::c_int;
}
#[doc = " AF statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct isp_core_af_sta_info {
    #[doc = "< The integrated and normalized measure of contrast"]
    pub af_metrics: ::std::os::raw::c_uint,
    #[doc = "< The integrated and normalized measure of contrast - with alternative threshold"]
    pub af_metrics_alt: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_isp_core_af_sta_info() {
    const UNINIT: ::std::mem::MaybeUninit<isp_core_af_sta_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_core_af_sta_info>(),
        8usize,
        concat!("Size of: ", stringify!(isp_core_af_sta_info))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_core_af_sta_info>(),
        4usize,
        concat!("Alignment of ", stringify!(isp_core_af_sta_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_metrics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_af_sta_info),
            "::",
            stringify!(af_metrics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_metrics_alt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_core_af_sta_info),
            "::",
            stringify!(af_metrics_alt)
        )
    );
}
#[doc = " AF statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAFHist {
    #[doc = "< AF statistics"]
    pub af_stat: isp_core_af_sta_info,
    #[doc = "< AF enable"]
    pub af_enable: ::std::os::raw::c_uchar,
    #[doc = "< Metrics scaling factor 0x0 is default"]
    pub af_metrics_shift: ::std::os::raw::c_uchar,
    #[doc = "< AF statistics low pass fliter weight [0 ~ 64]"]
    pub af_delta: ::std::os::raw::c_ushort,
    #[doc = "< AF statistics high pass fliter weight [0 ~ 64]"]
    pub af_theta: ::std::os::raw::c_ushort,
    #[doc = "< AF high light threshold [0 ~ 255]"]
    pub af_hilight_th: ::std::os::raw::c_ushort,
    #[doc = "< AF statistics H and V direction weight [0 ~ 64]"]
    pub af_alpha_alt: ::std::os::raw::c_ushort,
    #[doc = "< AF statistic pixel start by horizontal:[1 ~ width], must be odd number"]
    pub af_hstart: ::std::os::raw::c_uchar,
    #[doc = "< AF statistic pixel start by vertical:[3 ~ height], must be odd number"]
    pub af_vstart: ::std::os::raw::c_uchar,
    #[doc = "< Number of zones horizontally for AF stats [1 ~ 15]"]
    pub af_stat_nodeh: ::std::os::raw::c_uchar,
    #[doc = "< Number of zones vertically for AF stats [1 ~ 15]"]
    pub af_stat_nodev: ::std::os::raw::c_uchar,
    pub af_frame_num: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_IMPISPAFHist() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAFHist> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAFHist>(),
        24usize,
        concat!("Size of: ", stringify!(IMPISPAFHist))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAFHist>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAFHist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_stat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_stat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_metrics_shift) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_metrics_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_delta) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_theta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_theta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_hilight_th) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_hilight_th)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_alpha_alt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_alpha_alt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_hstart) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_hstart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_vstart) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_vstart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_stat_nodeh) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_stat_nodeh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_stat_nodev) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_stat_nodev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).af_frame_num) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAFHist),
            "::",
            stringify!(af_frame_num)
        )
    );
}
extern "C" {
    #[doc = " @fn int int IMP_ISP_Tuning_GetAFMetrices(unsigned int *metric);\n\n Get AF statistic metric\n\n @param[in] metric AF statistic metric\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAFMetrices(
        metric: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfHist(IMPISPAFHist *af_hist);\n\n Set AF statistic parameters\n\n @param[out] af_hist AF statistic parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAfHist(af_hist: *mut IMPISPAFHist) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfHist(IMPISPAFHist *af_hist)\n\n Get AF statistics\n\n @param[in] af_hist AF statistics parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAfHist(af_hist: *mut IMPISPAFHist) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAfWeight(IMPISPWeight *af_weight)\n\n Set zone weighting for AF\n\n @param[in] af_weight af weight.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAfWeight(af_weight: *mut IMPISPWeight) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfWeight(IMPISPWeight *af_weight)\n\n Get zone weighting for AF\n\n @param[in] af_weight af weight.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAfWeight(af_weight: *mut IMPISPWeight) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAfZone(IMPISPZone *af_zone)\n\n Get AF zone metric information.\n\n @param[out] af_zone AF metric info per zone\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAfZone(af_zone: *mut IMPISPZone) -> ::std::os::raw::c_int;
}
#[doc = " ISP Wait Frame Params。"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPWaitFrameAttr {
    #[doc = "< timeout，unit ms"]
    pub timeout: u32,
    #[doc = "< Frame num"]
    pub cnt: u64,
}
#[test]
fn bindgen_test_layout_IMPISPWaitFrameAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPWaitFrameAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPWaitFrameAttr>(),
        16usize,
        concat!("Size of: ", stringify!(IMPISPWaitFrameAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPWaitFrameAttr>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPISPWaitFrameAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPWaitFrameAttr),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPWaitFrameAttr),
            "::",
            stringify!(cnt)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_WaitFrame(IMPISPWaitFrameAttr *attr)\n Wait frame done\n\n @param[out] attr frame done parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_WaitFrame(attr: *mut IMPISPWaitFrameAttr) -> ::std::os::raw::c_int;
}
#[doc = " AE Min"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEMin {
    #[doc = "< AE min integration time"]
    pub min_it: ::std::os::raw::c_uint,
    #[doc = "< AE min analog gain"]
    pub min_again: ::std::os::raw::c_uint,
    #[doc = "< AE min integration time on short frame"]
    pub min_it_short: ::std::os::raw::c_uint,
    #[doc = "< AE min analog gain on short frame"]
    pub min_again_short: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_IMPISPAEMin() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAEMin> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAEMin>(),
        16usize,
        concat!("Size of: ", stringify!(IMPISPAEMin))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAEMin>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAEMin))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_it) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEMin),
            "::",
            stringify!(min_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_again) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEMin),
            "::",
            stringify!(min_again)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_it_short) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEMin),
            "::",
            stringify!(min_it_short)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_again_short) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEMin),
            "::",
            stringify!(min_again_short)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeMin(IMPISPAEMin *ae_min)\n\n Set AE Min parameters\n\n @param[in] ae_min AE min parameters.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeMin(ae_min: *mut IMPISPAEMin) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeMin(IMPISPAEMin *ae_min)\n\n Get AE min information.\n\n @param[out] ae_min AE min parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeMin(ae_min: *mut IMPISPAEMin) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAe_IT_MAX(unsigned int it_max)\n\n Set AE Max parameters\n\n @param[in] it_max AE max it parameters.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAe_IT_MAX(it_max: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAE_IT_MAX(unsigned int *it_max)\n\n Get AE max information.\n\n @param[out] ae_max AE max it parameters\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAE_IT_MAX(
        it_max: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeZone(IMPISPZone *ae_zone)\n\n Get AE zone y information.\n\n @param[out] ae_zone AE y info per zone\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeZone(ae_zone: *mut IMPISPZone) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAETargetList {
    pub at_list: [::std::os::raw::c_uint; 10usize],
}
#[test]
fn bindgen_test_layout_IMPISPAETargetList() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAETargetList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAETargetList>(),
        40usize,
        concat!("Size of: ", stringify!(IMPISPAETargetList))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAETargetList>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAETargetList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).at_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAETargetList),
            "::",
            stringify!(at_list)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList(IMPISPAETargetList *at_list)\n\n Set  AE target List\n\n @param[in] at_list  ae target list.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAeTargetList(
        at_list: *mut IMPISPAETargetList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeTargetList(IMPISPAETargetList *at_list)\n\n Get  AE target List\n\n @param[out] at_list  ae target list.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeTargetList(
        at_list: *mut IMPISPAETargetList,
    ) -> ::std::os::raw::c_int;
}
#[doc = " ISP Module Control"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPISPModuleCtl {
    pub key: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: IMPISPModuleCtl__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPModuleCtl__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_IMPISPModuleCtl__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IMPISPModuleCtl__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IMPISPModuleCtl__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPModuleCtl__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPModuleCtl__bindgen_ty_1))
    );
}
impl IMPISPModuleCtl__bindgen_ty_1 {
    #[inline]
    pub fn bitBypassBLC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassBLC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassGIB(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassGIB(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassAG(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassAG(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassWDR(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassWDR(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDPC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDPC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassRDNS(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassRDNS(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassLSC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassLSC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassADR(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassADR(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDMSC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDMSC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCCM(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCCM(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassGAMMA(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassGAMMA(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassDEFOG(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassDEFOG(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCSC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCSC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassCLM(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassCLM(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassSP(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassSP(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassYDNS(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassYDNS(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassBCSH(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassBCSH(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassSDNS(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassSDNS(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassHLDC(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassHLDC(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitRsv(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_bitRsv(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn bitBypassMDNS(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitBypassMDNS(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bitBypassBLC: ::std::os::raw::c_uint,
        bitBypassGIB: ::std::os::raw::c_uint,
        bitBypassAG: ::std::os::raw::c_uint,
        bitBypassWDR: ::std::os::raw::c_uint,
        bitBypassDPC: ::std::os::raw::c_uint,
        bitBypassRDNS: ::std::os::raw::c_uint,
        bitBypassLSC: ::std::os::raw::c_uint,
        bitBypassADR: ::std::os::raw::c_uint,
        bitBypassDMSC: ::std::os::raw::c_uint,
        bitBypassCCM: ::std::os::raw::c_uint,
        bitBypassGAMMA: ::std::os::raw::c_uint,
        bitBypassDEFOG: ::std::os::raw::c_uint,
        bitBypassCSC: ::std::os::raw::c_uint,
        bitBypassCLM: ::std::os::raw::c_uint,
        bitBypassSP: ::std::os::raw::c_uint,
        bitBypassYDNS: ::std::os::raw::c_uint,
        bitBypassBCSH: ::std::os::raw::c_uint,
        bitBypassSDNS: ::std::os::raw::c_uint,
        bitBypassHLDC: ::std::os::raw::c_uint,
        bitRsv: ::std::os::raw::c_uint,
        bitBypassMDNS: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bitBypassBLC: u32 = unsafe { ::std::mem::transmute(bitBypassBLC) };
            bitBypassBLC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bitBypassGIB: u32 = unsafe { ::std::mem::transmute(bitBypassGIB) };
            bitBypassGIB as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bitBypassAG: u32 = unsafe { ::std::mem::transmute(bitBypassAG) };
            bitBypassAG as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bitBypassWDR: u32 = unsafe { ::std::mem::transmute(bitBypassWDR) };
            bitBypassWDR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bitBypassDPC: u32 = unsafe { ::std::mem::transmute(bitBypassDPC) };
            bitBypassDPC as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bitBypassRDNS: u32 = unsafe { ::std::mem::transmute(bitBypassRDNS) };
            bitBypassRDNS as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bitBypassLSC: u32 = unsafe { ::std::mem::transmute(bitBypassLSC) };
            bitBypassLSC as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bitBypassADR: u32 = unsafe { ::std::mem::transmute(bitBypassADR) };
            bitBypassADR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bitBypassDMSC: u32 = unsafe { ::std::mem::transmute(bitBypassDMSC) };
            bitBypassDMSC as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let bitBypassCCM: u32 = unsafe { ::std::mem::transmute(bitBypassCCM) };
            bitBypassCCM as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bitBypassGAMMA: u32 = unsafe { ::std::mem::transmute(bitBypassGAMMA) };
            bitBypassGAMMA as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let bitBypassDEFOG: u32 = unsafe { ::std::mem::transmute(bitBypassDEFOG) };
            bitBypassDEFOG as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let bitBypassCSC: u32 = unsafe { ::std::mem::transmute(bitBypassCSC) };
            bitBypassCSC as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let bitBypassCLM: u32 = unsafe { ::std::mem::transmute(bitBypassCLM) };
            bitBypassCLM as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let bitBypassSP: u32 = unsafe { ::std::mem::transmute(bitBypassSP) };
            bitBypassSP as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let bitBypassYDNS: u32 = unsafe { ::std::mem::transmute(bitBypassYDNS) };
            bitBypassYDNS as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let bitBypassBCSH: u32 = unsafe { ::std::mem::transmute(bitBypassBCSH) };
            bitBypassBCSH as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let bitBypassSDNS: u32 = unsafe { ::std::mem::transmute(bitBypassSDNS) };
            bitBypassSDNS as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let bitBypassHLDC: u32 = unsafe { ::std::mem::transmute(bitBypassHLDC) };
            bitBypassHLDC as u64
        });
        __bindgen_bitfield_unit.set(19usize, 12u8, {
            let bitRsv: u32 = unsafe { ::std::mem::transmute(bitRsv) };
            bitRsv as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bitBypassMDNS: u32 = unsafe { ::std::mem::transmute(bitBypassMDNS) };
            bitBypassMDNS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IMPISPModuleCtl() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPModuleCtl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPModuleCtl>(),
        4usize,
        concat!("Size of: ", stringify!(IMPISPModuleCtl))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPModuleCtl>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPModuleCtl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPModuleCtl),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetModuleControl(IMPISPModuleCtl *ispmodule)\n\n Set ISP Module control\n\n @param[in] ispmodule ISP Module control.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetModuleControl(
        ispmodule: *mut IMPISPModuleCtl,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetModuleControl(IMPISPModuleCtl *ispmodule)\n\n Get ISP Module control.\n\n @param[out] ispmodule ISP Module control\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetModuleControl(
        ispmodule: *mut IMPISPModuleCtl,
    ) -> ::std::os::raw::c_int;
}
#[doc = " ISP Front Crop Attribution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPFrontCrop {
    pub fcrop_enable: bool,
    pub fcrop_top: ::std::os::raw::c_uint,
    pub fcrop_left: ::std::os::raw::c_uint,
    pub fcrop_width: ::std::os::raw::c_uint,
    pub fcrop_height: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_IMPISPFrontCrop() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPFrontCrop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPFrontCrop>(),
        20usize,
        concat!("Size of: ", stringify!(IMPISPFrontCrop))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPFrontCrop>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPFrontCrop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcrop_enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrontCrop),
            "::",
            stringify!(fcrop_enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcrop_top) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrontCrop),
            "::",
            stringify!(fcrop_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcrop_left) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrontCrop),
            "::",
            stringify!(fcrop_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcrop_width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrontCrop),
            "::",
            stringify!(fcrop_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fcrop_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrontCrop),
            "::",
            stringify!(fcrop_height)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetFrontCrop(IMPISPFrontCrop *ispfrontcrop)\n\n Set Front Crop attribution\n\n @param[in] ispfrontcrop IFront Crop attribution.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetFrontCrop(ispfrontcrop: *mut IMPISPFrontCrop)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetFrontCrop(IMPISPFrontCrop *ispfrontcrop)\n\n Get Front Crop Attribution.\n\n @param[out] ispfrontcrop IFront Crop attribution.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetFrontCrop(ispfrontcrop: *mut IMPISPFrontCrop)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_WDR_ENABLE(IMPISPTuningOpsMode mode)\n\n Enable ISP WDR.\n\n @paramin[in] mode ISP WDR mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_WDR_ENABLE(mode: IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMP_ISP_WDR_ENABLE_Get(IMPISPTuningOpsMode* mode)\n\n Get ISP WDR Mode.\n\n @param[in] mode ISP WDR mode\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_WDR_ENABLE_Get(mode: *mut IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDPC_Strength(unsigned int ratio)\n\n Set DPC Strength.\n\n @param[in] ratio   Intensity modulation ratio. Default value is 128.If it is greater than 128, that means increaseing the dpc value. If it is less than 128, that means decreaing the dpc value. The value range is [0-255].\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetDPC_Strength(ratio: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDPC_Strength(unsigned int *strength)\n\n Get DPC Strength.\n\n @param[out] ratio   Intensity modulation ratio. Default value is 128.If it is greater than 128, that means increaseing the dpc value. If it is less than 128, that means decreaing the dpc value. The value range is [0-255].\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetDPC_Strength(
        ratio: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetDRC_Strength(unsigned int ratio)\n\n Set DRC Strength.\n\n @param[in] ratio   Intensity modulation ratio. Default value is 128.If it is greater than 128, that means increaseing the drc value. If it is less than 128, that means decreaing the drc value. The value range is [0-255].\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetDRC_Strength(ratio: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetDRC_Strength(unsigned int *ratio)\n\n Get DRC Strength.\n\n @param[out] ratio   Intensity modulation ratio. Default value is 128.If it is greater than 128, that means increaseing the drc value. If it is less than 128, that means decreaing the drc value. The value range is [0-255].\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetDRC_Strength(
        ratio: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< normal mode"]
pub const IMPISPHVFLIP_IMPISP_FLIP_NORMAL_MODE: IMPISPHVFLIP = 0;
#[doc = "< only mirror mode"]
pub const IMPISPHVFLIP_IMPISP_FLIP_H_MODE: IMPISPHVFLIP = 1;
#[doc = "< only flip mode"]
pub const IMPISPHVFLIP_IMPISP_FLIP_V_MODE: IMPISPHVFLIP = 2;
#[doc = "< mirror & flip mode"]
pub const IMPISPHVFLIP_IMPISP_FLIP_HV_MODE: IMPISPHVFLIP = 3;
pub const IMPISPHVFLIP_IMPISP_FLIP_MODE_BUTT: IMPISPHVFLIP = 4;
#[doc = " HFlip and VFlip parameters"]
pub type IMPISPHVFLIP = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetHVFLIP(IMPISPHVFLIP hvflip)\n\n Set HV Flip mode.\n\n @param[in] hvflip HV Flip mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetHVFLIP(hvflip: IMPISPHVFLIP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetHVFlip(IMPISPHVFLIP *hvflip)\n\n Get HV Flip mode.\n\n @param[out] hvflip hvflip mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetHVFlip(hvflip: *mut IMPISPHVFLIP) -> ::std::os::raw::c_int;
}
#[doc = "< RGB type"]
pub const IMPISP_MASK_TYPE_IMPISP_MASK_TYPE_RGB: IMPISP_MASK_TYPE = 0;
#[doc = "< YUV type"]
pub const IMPISP_MASK_TYPE_IMPISP_MASK_TYPE_YUV: IMPISP_MASK_TYPE = 1;
#[doc = " fill data type of Mask parameters"]
pub type IMPISP_MASK_TYPE = ::std::os::raw::c_uint;
#[doc = " fill data value of Mask parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union mask_value {
    #[doc = "< RGB type"]
    pub mask_rgb: mask_value__bindgen_ty_1,
    #[doc = "< YUV type"]
    pub mask_ayuv: mask_value__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mask_value__bindgen_ty_1 {
    #[doc = "< R offset of RGB type"]
    pub Red: ::std::os::raw::c_uchar,
    #[doc = "< G offset of RGB type"]
    pub Green: ::std::os::raw::c_uchar,
    #[doc = "< B offset of RGB type"]
    pub Blue: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mask_value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<mask_value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mask_value__bindgen_ty_1>(),
        3usize,
        concat!("Size of: ", stringify!(mask_value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mask_value__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(mask_value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_value__bindgen_ty_1),
            "::",
            stringify!(Red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Green) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_value__bindgen_ty_1),
            "::",
            stringify!(Green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Blue) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_value__bindgen_ty_1),
            "::",
            stringify!(Blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mask_value__bindgen_ty_2 {
    #[doc = "< Y offset of YUV type"]
    pub y_value: ::std::os::raw::c_uchar,
    #[doc = "< U offset of YUV type"]
    pub u_value: ::std::os::raw::c_uchar,
    #[doc = "< V offset of YUV type"]
    pub v_value: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mask_value__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<mask_value__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mask_value__bindgen_ty_2>(),
        3usize,
        concat!("Size of: ", stringify!(mask_value__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<mask_value__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(mask_value__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_value__bindgen_ty_2),
            "::",
            stringify!(y_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u_value) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_value__bindgen_ty_2),
            "::",
            stringify!(u_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_value) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_value__bindgen_ty_2),
            "::",
            stringify!(v_value)
        )
    );
}
#[test]
fn bindgen_test_layout_mask_value() {
    const UNINIT: ::std::mem::MaybeUninit<mask_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mask_value>(),
        3usize,
        concat!("Size of: ", stringify!(mask_value))
    );
    assert_eq!(
        ::std::mem::align_of::<mask_value>(),
        1usize,
        concat!("Alignment of ", stringify!(mask_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_rgb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_value),
            "::",
            stringify!(mask_rgb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_ayuv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_value),
            "::",
            stringify!(mask_ayuv)
        )
    );
}
#[doc = " fill data value of Mask parameters"]
pub type IMP_ISP_MASK_VALUE = mask_value;
#[doc = " Mask parameters of each channel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct isp_mask_block_par {
    #[doc = "< mask enable"]
    pub mask_en: ::std::os::raw::c_uchar,
    #[doc = "< y of mask position"]
    pub mask_pos_top: ::std::os::raw::c_ushort,
    #[doc = "< x of mask position"]
    pub mask_pos_left: ::std::os::raw::c_ushort,
    #[doc = "< mask block width"]
    pub mask_width: ::std::os::raw::c_ushort,
    #[doc = "< mask block height"]
    pub mask_height: ::std::os::raw::c_ushort,
    #[doc = "< mask value"]
    pub mask_value: IMP_ISP_MASK_VALUE,
}
#[test]
fn bindgen_test_layout_isp_mask_block_par() {
    const UNINIT: ::std::mem::MaybeUninit<isp_mask_block_par> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<isp_mask_block_par>(),
        14usize,
        concat!("Size of: ", stringify!(isp_mask_block_par))
    );
    assert_eq!(
        ::std::mem::align_of::<isp_mask_block_par>(),
        2usize,
        concat!("Alignment of ", stringify!(isp_mask_block_par))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_en) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_mask_block_par),
            "::",
            stringify!(mask_en)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_pos_top) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_mask_block_par),
            "::",
            stringify!(mask_pos_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_pos_left) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_mask_block_par),
            "::",
            stringify!(mask_pos_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_width) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_mask_block_par),
            "::",
            stringify!(mask_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_mask_block_par),
            "::",
            stringify!(mask_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_value) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(isp_mask_block_par),
            "::",
            stringify!(mask_value)
        )
    );
}
#[doc = " Mask parameters of each channel"]
pub type IMPISP_MASK_BLOCK_PAR = isp_mask_block_par;
#[doc = " Mask parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPISPMASKAttr {
    #[doc = "< chan0 mask attr"]
    pub chn0: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< chan1 mask attr"]
    pub chn1: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< chan2 mask attr"]
    pub chn2: [IMPISP_MASK_BLOCK_PAR; 4usize],
    #[doc = "< mask type"]
    pub mask_type: IMPISP_MASK_TYPE,
}
#[test]
fn bindgen_test_layout_IMPISPMASKAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPMASKAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPMASKAttr>(),
        172usize,
        concat!("Size of: ", stringify!(IMPISPMASKAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPMASKAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPMASKAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chn0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPMASKAttr),
            "::",
            stringify!(chn0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chn1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPMASKAttr),
            "::",
            stringify!(chn1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chn2) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPMASKAttr),
            "::",
            stringify!(chn2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask_type) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPMASKAttr),
            "::",
            stringify!(mask_type)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetMask(IMPISPMASKAttr *mask)\n\n Set Mask Attr.\n\n @param[in] mask Mask attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetMask(mask: *mut IMPISPMASKAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetMask(IMPISPMASKAttr *mask)\n\n Get Mask Attr.\n\n @param[out] mask Mask attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetMask(mask: *mut IMPISPMASKAttr) -> ::std::os::raw::c_int;
}
#[doc = " Sensor attr parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPSENSORAttr {
    #[doc = "< sensor hts"]
    pub hts: ::std::os::raw::c_uint,
    #[doc = "< sensor vts"]
    pub vts: ::std::os::raw::c_uint,
    #[doc = "< sensor fps:"]
    pub fps: ::std::os::raw::c_uint,
    #[doc = "< sensor width"]
    pub width: ::std::os::raw::c_uint,
    #[doc = "< sensor height"]
    pub height: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_IMPISPSENSORAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPSENSORAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPSENSORAttr>(),
        20usize,
        concat!("Size of: ", stringify!(IMPISPSENSORAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPSENSORAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPSENSORAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPSENSORAttr),
            "::",
            stringify!(hts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPSENSORAttr),
            "::",
            stringify!(vts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPSENSORAttr),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPSENSORAttr),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPSENSORAttr),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetSensorAttr(IMPISPSENSORAttr *attr)\n\n Get Sensor Attr.\n\n @param[out] attr Sensor attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetSensorAttr(attr: *mut IMPISPSENSORAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDRC(IMPISPTuningOpsMode mode)\n\n Enable DRC.\n\n @param[out] mode DRC ENABLE mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_EnableDRC(mode: IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_EnableDefog(IMPISPTuningOpsMode mode)\n\n Enable Defog.\n\n @param[out] mode Defog ENABLE mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_EnableDefog(mode: IMPISPTuningOpsMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAwbCt(unsigned int *ct)\n\n set awb color temp.\n\n @param[out] ct AWB color temp value.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetAwbCt(ct: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAWBCt(unsigned int *ct)\n\n Get AWB color temp.\n\n @param[out] ct AWB color temp value.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAWBCt(ct: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[doc = " ISP CCM Attr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPCCMAttr {
    pub ManualEn: IMPISPTuningOpsMode,
    pub SatEn: IMPISPTuningOpsMode,
    pub ColorMatrix: [f32; 9usize],
}
#[test]
fn bindgen_test_layout_IMPISPCCMAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPCCMAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPCCMAttr>(),
        44usize,
        concat!("Size of: ", stringify!(IMPISPCCMAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPCCMAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPCCMAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ManualEn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCCMAttr),
            "::",
            stringify!(ManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SatEn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCCMAttr),
            "::",
            stringify!(SatEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ColorMatrix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCCMAttr),
            "::",
            stringify!(ColorMatrix)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetCCMAttr(IMPISPCCMAttr *ccm)\n\n set ccm attr\n\n @param[out] ccm ccm attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetCCMAttr(ccm: *mut IMPISPCCMAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetCCMAttr(IMPISPCCMAttr *ccm)\n\n Get CCM Attr.\n\n @param[out] ccm ccm attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetCCMAttr(ccm: *mut IMPISPCCMAttr) -> ::std::os::raw::c_int;
}
#[doc = " ISP AE Attr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEAttr {
    pub AeFreezenEn: IMPISPTuningOpsMode,
    pub AeItManualEn: IMPISPTuningOpsMode,
    pub AeIt: ::std::os::raw::c_uint,
    pub AeAGainManualEn: IMPISPTuningOpsMode,
    pub AeAGain: ::std::os::raw::c_uint,
    pub AeDGainManualEn: IMPISPTuningOpsMode,
    pub AeDGain: ::std::os::raw::c_uint,
    pub AeIspDGainManualEn: IMPISPTuningOpsMode,
    pub AeIspDGain: ::std::os::raw::c_uint,
    pub AeWdrShortFreezenEn: IMPISPTuningOpsMode,
    pub AeWdrShortItManualEn: IMPISPTuningOpsMode,
    pub AeWdrShortIt: ::std::os::raw::c_uint,
    pub AeWdrShortAGainManualEn: IMPISPTuningOpsMode,
    pub AeWdrShortAGain: ::std::os::raw::c_uint,
    pub AeWdrShortDGainManualEn: IMPISPTuningOpsMode,
    pub AeWdrShortDGain: ::std::os::raw::c_uint,
    pub AeWdrShortIspDGainManualEn: IMPISPTuningOpsMode,
    pub AeWdrShortIspDGain: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_IMPISPAEAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAEAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAEAttr>(),
        72usize,
        concat!("Size of: ", stringify!(IMPISPAEAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAEAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAEAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeFreezenEn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeFreezenEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeItManualEn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeItManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeIt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeAGainManualEn) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeAGainManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeAGain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeDGainManualEn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeDGainManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeDGain) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIspDGainManualEn) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeIspDGainManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIspDGain) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortFreezenEn) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortFreezenEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortItManualEn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortItManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortIt) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortIt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortAGainManualEn) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortAGainManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortAGain) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortDGainManualEn) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortDGainManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortDGain) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortIspDGainManualEn) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortIspDGainManualEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeWdrShortIspDGain) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEAttr),
            "::",
            stringify!(AeWdrShortIspDGain)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetAeAttr(IMPISPAEAttr *ae)\n\n set Ae attr\n\n @param[out] ae ae manual attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly.\n @attention Before set the attr, you must memset the IMPISPAEAttr structure to 0, and then set the corresponding attr."]
    pub fn IMP_ISP_Tuning_SetAeAttr(ae: *mut IMPISPAEAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeAttr(IMPISPAEAttr *ae)\n\n Get Ae Attr.\n\n @param[out] ae ae manual attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeAttr(ae: *mut IMPISPAEAttr) -> ::std::os::raw::c_int;
}
#[doc = " AE state info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAEState {
    pub stable: bool,
    pub target: ::std::os::raw::c_uint,
    pub ae_mean: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_IMPISPAEState() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAEState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAEState>(),
        12usize,
        concat!("Size of: ", stringify!(IMPISPAEState))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAEState>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAEState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEState),
            "::",
            stringify!(stable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEState),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_mean) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAEState),
            "::",
            stringify!(ae_mean)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetAeState(IMPISPAEState *ae_state)\n\n Get Ae State info.\n\n @param[out] ae ae state info.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetAeState(ae_state: *mut IMPISPAEState) -> ::std::os::raw::c_int;
}
pub const IMPISPScalerMethod_IMP_ISP_SCALER_METHOD_FITTING_CURVE: IMPISPScalerMethod = 0;
pub const IMPISPScalerMethod_IMP_ISP_SCALER_METHOD_FIXED_WEIGHT: IMPISPScalerMethod = 1;
pub const IMPISPScalerMethod_IMP_ISP_SCALER_METHOD_BUTT: IMPISPScalerMethod = 2;
#[doc = " Scaler method"]
pub type IMPISPScalerMethod = ::std::os::raw::c_uint;
#[doc = " Scaler effect params"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPScalerLv {
    pub channel: ::std::os::raw::c_uchar,
    pub method: IMPISPScalerMethod,
    pub level: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_IMPISPScalerLv() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPScalerLv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPScalerLv>(),
        12usize,
        concat!("Size of: ", stringify!(IMPISPScalerLv))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPScalerLv>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPScalerLv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPScalerLv),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPScalerLv),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPScalerLv),
            "::",
            stringify!(level)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_SetScalerLv(IMPISPScalerLv *scaler_level)\n\n Set Scaler method and level.\n\n @param[in] mscaler opt.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetScalerLv(scaler_level: *mut IMPISPScalerLv) -> ::std::os::raw::c_int;
}
#[doc = " 3th custom AE library init Attribution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeInitAttr {
    #[doc = "< AE integration time unit"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE integration time value"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE sensor analog gain value"]
    pub AeAGain: u32,
    #[doc = "< AE sensor analog gain value"]
    pub AeDGain: u32,
    #[doc = "< AE ISP digital gain value"]
    pub AeIspDGain: u32,
    #[doc = "< AE min integration time"]
    pub AeMinIntegrationTime: u32,
    #[doc = "< AE min sensor analog gain"]
    pub AeMinAGain: u32,
    #[doc = "< AE min sensor digital gain"]
    pub AeMinDgain: u32,
    #[doc = "< AE min isp digital gain"]
    pub AeMinIspDGain: u32,
    #[doc = "< AE max integration time"]
    pub AeMaxIntegrationTime: u32,
    #[doc = "< AE max sensor analog gain"]
    pub AeMaxAGain: u32,
    #[doc = "< AE max sensor digital gain"]
    pub AeMaxDgain: u32,
    #[doc = "< AE max isp digital gain"]
    pub AeMaxIspDGain: u32,
    #[doc = "< AE integration time value"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE sensor analog gain value"]
    pub AeShortAGain: u32,
    #[doc = "< AE sensor digital gain value"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP digital gain value"]
    pub AeShortIspDGain: u32,
    #[doc = "< AE min integration time"]
    pub AeShortMinIntegrationTime: u32,
    #[doc = "< AE min sensor analog gain"]
    pub AeShortMinAGain: u32,
    #[doc = "< AE min sensor digital gain"]
    pub AeShortMinDgain: u32,
    #[doc = "< AE min isp digital gain"]
    pub AeShortMinIspDGain: u32,
    #[doc = "< AE max integration time"]
    pub AeShortMaxIntegrationTime: u32,
    #[doc = "< AE max sensor analog gain"]
    pub AeShortMaxAGain: u32,
    #[doc = "< AE max sensor digital gain"]
    pub AeShortMaxDgain: u32,
    #[doc = "< AE max isp digital gain"]
    pub AeShortMaxIspDGain: u32,
    #[doc = "< sensor fps 16/16"]
    pub fps: u32,
    #[doc = "< Ae statis attrbution"]
    pub AeStatis: IMPISPAEHist,
}
#[test]
fn bindgen_test_layout_IMPISPAeInitAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAeInitAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAeInitAttr>(),
        120usize,
        concat!("Size of: ", stringify!(IMPISPAeInitAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAeInitAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAeInitAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIntegrationTimeUnit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeIntegrationTimeUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIntegrationTime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeAGain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeDGain) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIspDGain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeMinIntegrationTime) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeMinIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeMinAGain) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeMinAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeMinDgain) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeMinDgain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeMinIspDGain) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeMinIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeMaxIntegrationTime) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeMaxIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeMaxAGain) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeMaxAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeMaxDgain) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeMaxDgain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeMaxIspDGain) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeMaxIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortIntegrationTime) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortAGain) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortDGain) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortIspDGain) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortMinIntegrationTime) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortMinIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortMinAGain) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortMinAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortMinDgain) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortMinDgain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortMinIspDGain) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortMinIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortMaxIntegrationTime) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortMaxIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortMaxAGain) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortMaxAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortMaxDgain) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortMaxDgain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortMaxIspDGain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeShortMaxIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(fps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeStatis) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInitAttr),
            "::",
            stringify!(AeStatis)
        )
    );
}
#[doc = " 3th custom AE library AE information"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeInfo {
    #[doc = "< AE statis each zone"]
    pub ae_zone: IMPISPZone,
    #[doc = "< AE 256 bin hist"]
    pub ae_hist_256bin: IMPISPAEHistOrigin,
    #[doc = "< AE 5 bin hist and attribution"]
    pub ae_hist: IMPISPAEHist,
    #[doc = "< AE integration time unit"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE integration time value"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE sensor analog gain value"]
    pub AeAGain: u32,
    #[doc = "< AE sensor digital gain value"]
    pub AeDGain: u32,
    #[doc = "< AE ISP digital gain value"]
    pub AeIspDGain: u32,
    #[doc = "< AE integration time value"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE sensor analog gain value"]
    pub AeShortAGain: u32,
    #[doc = "< AE sensor digital gain value"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP digital gain value"]
    pub AeShortIspDGain: u32,
    #[doc = "< WDR mode or not"]
    pub Wdr_mode: u32,
    #[doc = "< sensor attribution"]
    pub sensor_attr: IMPISPSENSORAttr,
}
#[test]
fn bindgen_test_layout_IMPISPAeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAeInfo>(),
        2000usize,
        concat!("Size of: ", stringify!(IMPISPAeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAeInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(IMPISPAeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_zone) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(ae_zone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_hist_256bin) as usize - ptr as usize },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(ae_hist_256bin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ae_hist) as usize - ptr as usize },
        1924usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(ae_hist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIntegrationTimeUnit) as usize - ptr as usize },
        1940usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeIntegrationTimeUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIntegrationTime) as usize - ptr as usize },
        1944usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeAGain) as usize - ptr as usize },
        1948usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeDGain) as usize - ptr as usize },
        1952usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIspDGain) as usize - ptr as usize },
        1956usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortIntegrationTime) as usize - ptr as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeShortIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortAGain) as usize - ptr as usize },
        1964usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeShortAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortDGain) as usize - ptr as usize },
        1968usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeShortDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortIspDGain) as usize - ptr as usize },
        1972usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(AeShortIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Wdr_mode) as usize - ptr as usize },
        1976usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(Wdr_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor_attr) as usize - ptr as usize },
        1980usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeInfo),
            "::",
            stringify!(sensor_attr)
        )
    );
}
#[doc = " 3th custom AE library AE attribution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeAttr {
    #[doc = "< change AE attr or not"]
    pub change: u32,
    #[doc = "< AE integration time unit"]
    pub AeIntegrationTimeUnit: isp_core_expr_unit,
    #[doc = "< AE integration time value"]
    pub AeIntegrationTime: u32,
    #[doc = "< AE sensor analog gain value"]
    pub AeAGain: u32,
    #[doc = "< AE sensor digital gain value"]
    pub AeDGain: u32,
    #[doc = "< AE ISP digital gain value"]
    pub AeIspDGain: u32,
    #[doc = "< AE integration time value"]
    pub AeShortIntegrationTime: u32,
    #[doc = "< AE sensor analog gain value"]
    pub AeShortAGain: u32,
    #[doc = "< AE sensor digital gain value"]
    pub AeShortDGain: u32,
    #[doc = "< AE ISP digital gain value"]
    pub AeShortIspDGain: u32,
    #[doc = "< AE Luma value"]
    pub luma: u32,
    #[doc = "< AE scence Luma value"]
    pub luma_scence: u32,
}
#[test]
fn bindgen_test_layout_IMPISPAeAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAeAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAeAttr>(),
        48usize,
        concat!("Size of: ", stringify!(IMPISPAeAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAeAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAeAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIntegrationTimeUnit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeIntegrationTimeUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIntegrationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeAGain) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeDGain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeIspDGain) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortIntegrationTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeShortIntegrationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortAGain) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeShortAGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortDGain) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeShortDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AeShortIspDGain) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(AeShortIspDGain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luma) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(luma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).luma_scence) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAttr),
            "::",
            stringify!(luma_scence)
        )
    );
}
pub const IMPISPAeNotify_IMPISP_AE_NOTIFY_FPS_CHANGE: IMPISPAeNotify = 0;
#[doc = " 3th custom AE library AE notify attribution"]
pub type IMPISPAeNotify = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAeAlgoFunc {
    pub priv_data: *mut ::std::os::raw::c_void,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut ::std::os::raw::c_void,
            AeInitAttr: *mut IMPISPAeInitAttr,
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(priv_data: *mut ::std::os::raw::c_void)>,
    pub handle: ::std::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut ::std::os::raw::c_void,
            AeInfo: *const IMPISPAeInfo,
            AeAttr: *mut IMPISPAeAttr,
        ),
    >,
    pub notify: ::std::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut ::std::os::raw::c_void,
            notify: IMPISPAeNotify,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_IMPISPAeAlgoFunc() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAeAlgoFunc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAeAlgoFunc>(),
        40usize,
        concat!("Size of: ", stringify!(IMPISPAeAlgoFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAeAlgoFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPISPAeAlgoFunc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAlgoFunc),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAlgoFunc),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAlgoFunc),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAlgoFunc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAeAlgoFunc),
            "::",
            stringify!(notify)
        )
    );
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetAeAlgoFunc(IMPISPAeAlgoFunc *ae_func)\n\n the callback functions interface for 3th custom AE library.\n\n @param[in]  ae_func     the callback functions.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that IMP_ISP_AddSensor have be called."]
    pub fn IMP_ISP_SetAeAlgoFunc(ae_func: *mut IMPISPAeAlgoFunc) -> i32;
}
#[doc = " 3th custom AWB library AWB init information"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAwbInfo {
    pub cur_r_gain: u32,
    pub cur_b_gain: u32,
    pub r_gain_statis: u32,
    pub b_gain_statis: u32,
    pub r_gain_wei_statis: u32,
    pub b_gain_wei_statis: u32,
    pub awb_statis: IMPISPAWBZone,
}
#[test]
fn bindgen_test_layout_IMPISPAwbInfo() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAwbInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAwbInfo>(),
        699usize,
        concat!("Size of: ", stringify!(IMPISPAwbInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAwbInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(IMPISPAwbInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_r_gain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbInfo),
            "::",
            stringify!(cur_r_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur_b_gain) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbInfo),
            "::",
            stringify!(cur_b_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_gain_statis) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbInfo),
            "::",
            stringify!(r_gain_statis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_gain_statis) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbInfo),
            "::",
            stringify!(b_gain_statis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_gain_wei_statis) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbInfo),
            "::",
            stringify!(r_gain_wei_statis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_gain_wei_statis) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbInfo),
            "::",
            stringify!(b_gain_wei_statis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).awb_statis) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbInfo),
            "::",
            stringify!(awb_statis)
        )
    );
}
#[doc = " 3th custom AWB library AWB attribution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAwbAttr {
    pub change: u32,
    pub r_gain: u32,
    pub b_gain: u32,
    pub ct: u32,
}
#[test]
fn bindgen_test_layout_IMPISPAwbAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAwbAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAwbAttr>(),
        16usize,
        concat!("Size of: ", stringify!(IMPISPAwbAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAwbAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPAwbAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAttr),
            "::",
            stringify!(change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_gain) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAttr),
            "::",
            stringify!(r_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_gain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAttr),
            "::",
            stringify!(b_gain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ct) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAttr),
            "::",
            stringify!(ct)
        )
    );
}
pub const IMPISPAwbNotify_IMPISP_AWB_NOTIFY_MODE_CHANGE: IMPISPAwbNotify = 0;
#[doc = " 3th custom AWB library AWB notify attribution"]
pub type IMPISPAwbNotify = ::std::os::raw::c_uint;
#[doc = " 3th custom AWB library callback functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPAwbAlgoFunc {
    pub priv_data: *mut ::std::os::raw::c_void,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(priv_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(priv_data: *mut ::std::os::raw::c_void)>,
    pub handle: ::std::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut ::std::os::raw::c_void,
            AwbInfo: *const IMPISPAwbInfo,
            AwbAttr: *mut IMPISPAwbAttr,
        ),
    >,
    pub notify: ::std::option::Option<
        unsafe extern "C" fn(
            priv_data: *mut ::std::os::raw::c_void,
            notify: IMPISPAwbNotify,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_IMPISPAwbAlgoFunc() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPAwbAlgoFunc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPAwbAlgoFunc>(),
        40usize,
        concat!("Size of: ", stringify!(IMPISPAwbAlgoFunc))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPAwbAlgoFunc>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPISPAwbAlgoFunc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAlgoFunc),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAlgoFunc),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAlgoFunc),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAlgoFunc),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPAwbAlgoFunc),
            "::",
            stringify!(notify)
        )
    );
}
extern "C" {
    pub fn IMP_ISP_SetAwbAlgoFunc(awb_func: *mut IMPISPAwbAlgoFunc) -> i32;
}
#[doc = " black level attr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPBlcAttr {
    #[doc = "< R channel"]
    pub black_level_r: ::std::os::raw::c_uint,
    #[doc = "< GR channel"]
    pub black_level_gr: ::std::os::raw::c_uint,
    #[doc = "< GB channel"]
    pub black_level_gb: ::std::os::raw::c_uint,
    #[doc = "< B channel"]
    pub black_level_b: ::std::os::raw::c_uint,
    #[doc = "< IR channel"]
    pub black_level_ir: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_IMPISPBlcAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPBlcAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPBlcAttr>(),
        20usize,
        concat!("Size of: ", stringify!(IMPISPBlcAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPBlcAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPBlcAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_level_r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPBlcAttr),
            "::",
            stringify!(black_level_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_level_gr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPBlcAttr),
            "::",
            stringify!(black_level_gr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_level_gb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPBlcAttr),
            "::",
            stringify!(black_level_gb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_level_b) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPBlcAttr),
            "::",
            stringify!(black_level_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).black_level_ir) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPBlcAttr),
            "::",
            stringify!(black_level_ir)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_ISP_Tuning_GetBlcAttr(IMPISPBlcAttr *blc)\n\n Gets the associated properties of the BLC.\n\n @param[out] blc blc attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using that function, make sure that ISP is working properly.\n @attention Before set the attr, you must memset the IMPISPAEAttr structure to 0."]
    pub fn IMP_ISP_Tuning_GetBlcAttr(blc: *mut IMPISPBlcAttr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetDefog_Strength(uint8_t *ratio)\n\n set isp defog module ratio.\n\n @param[in] ratio defog module ratio.\n\n @retval 0 means success.\n @retval Other value means failure, its value is an error code.\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_SetDefog_Strength(ratio: *mut u8) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetDefog_Strength(uint8_t *ratio)\n\n @param[in] ratio defog module ratio.\n\n @retval 0 means success.\n @retval Other value means failure, its value is an error code.\n\n @attention Before using it, make sure that ISP is working properly."]
    pub fn IMP_ISP_Tuning_GetDefog_Strength(ratio: *mut u8) -> i32;
}
#[doc = "< BT601 full range"]
pub const IMPISPCscCgMode_ISP_CSC_CG_BT601_FULL: IMPISPCscCgMode = 0;
#[doc = "< BT601 not full range"]
pub const IMPISPCscCgMode_ISP_CSC_CG_BT601_CLIP: IMPISPCscCgMode = 1;
#[doc = "< BT709 full range"]
pub const IMPISPCscCgMode_ISP_CSC_CG_BT709_FULL: IMPISPCscCgMode = 2;
#[doc = "< BT709 not full range"]
pub const IMPISPCscCgMode_ISP_CSC_CG_BT709_CLIP: IMPISPCscCgMode = 3;
#[doc = "< CUSTOM mode. Only use this mode, the IMPISPCscMatrix parameters is valid."]
pub const IMPISPCscCgMode_ISP_CSC_CG_USER: IMPISPCscCgMode = 4;
#[doc = "< effect paramater, parameters have to be less than this value"]
pub const IMPISPCscCgMode_IMP_CSC_CG_BUTT: IMPISPCscCgMode = 5;
pub type IMPISPCscCgMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPCscParam {
    #[doc = "< 3x3 matrix"]
    pub csc_coef: [::std::os::raw::c_int; 9usize],
    #[doc = "< [0]:UV offset [1]:Y offset"]
    pub csc_offset: [::std::os::raw::c_int; 2usize],
    #[doc = "< Y max, Y min"]
    pub csc_y_clip: [::std::os::raw::c_int; 2usize],
    #[doc = "< UV max, UV min"]
    pub csc_c_clip: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_IMPISPCscParam() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPCscParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPCscParam>(),
        60usize,
        concat!("Size of: ", stringify!(IMPISPCscParam))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPCscParam>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPCscParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csc_coef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCscParam),
            "::",
            stringify!(csc_coef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csc_offset) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCscParam),
            "::",
            stringify!(csc_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csc_y_clip) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCscParam),
            "::",
            stringify!(csc_y_clip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csc_c_clip) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCscParam),
            "::",
            stringify!(csc_c_clip)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPCscAttr {
    #[doc = "< mode"]
    pub mode: IMPISPCscCgMode,
    #[doc = "< Custom Matrix"]
    pub csc_par: IMPISPCscParam,
}
#[test]
fn bindgen_test_layout_IMPISPCscAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPCscAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPCscAttr>(),
        64usize,
        concat!("Size of: ", stringify!(IMPISPCscAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPCscAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPCscAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCscAttr),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).csc_par) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPCscAttr),
            "::",
            stringify!(csc_par)
        )
    );
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetCsc_Attr(IMPISPCscAttr *attr)\n\n Set the properties of CSC module.\n\n @param[in] attr CSC module attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetCsc_Attr(attr: *mut IMPISPCscAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetCsc_Attr(IMPISPCscAttr *attr)\n\n Get the properties of CSC module.\n\n @param[out] attr CSC module attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetCsc_Attr(attr: *mut IMPISPCscAttr) -> i32;
}
#[doc = "< Mixture mode"]
pub const IMPISPWdrOutputMode_IMPISP_WDR_OUTPUT_MODE_FUS_FRAME: IMPISPWdrOutputMode = 0;
#[doc = "< Long frame mode"]
pub const IMPISPWdrOutputMode_IMPISP_WDR_OUTPUT_MODE_LONG_FRAME: IMPISPWdrOutputMode = 1;
#[doc = "< Short frame mode"]
pub const IMPISPWdrOutputMode_IMPISP_WDR_OUTPUT_MODE_SHORT_FRAME: IMPISPWdrOutputMode = 2;
#[doc = "< effect paramater, parameters have to be less than this value"]
pub const IMPISPWdrOutputMode_IMPISP_WDR_OUTPUT_MODE_BUTT: IMPISPWdrOutputMode = 3;
#[doc = " WDR output mode."]
pub type IMPISPWdrOutputMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_SetWdr_OutputMode(IMPISPWdrOutputMode *mode)\n\n Set the WDR image output mode.\n\n @param[in] mode\toutput mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_SetWdr_OutputMode(mode: *mut IMPISPWdrOutputMode) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_Tuning_GetWdr_OutputMode(IMPISPWdrOutputMode *mode)\n\n Get the WDR image output mode.\n\n @param[out] mode\toutput mode.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_Tuning_GetWdr_OutputMode(mode: *mut IMPISPWdrOutputMode) -> i32;
}
#[doc = " frame drop parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPFrameDrop {
    #[doc = "< enbale mark"]
    pub enable: IMPISPTuningOpsMode,
    #[doc = "< sum (range:0~31)"]
    pub lsize: u8,
    #[doc = "< bit mark(1 output,0 drop)"]
    pub fmark: u32,
}
#[test]
fn bindgen_test_layout_IMPISPFrameDrop() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPFrameDrop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPFrameDrop>(),
        12usize,
        concat!("Size of: ", stringify!(IMPISPFrameDrop))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPFrameDrop>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPFrameDrop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrameDrop),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lsize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrameDrop),
            "::",
            stringify!(lsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmark) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrameDrop),
            "::",
            stringify!(fmark)
        )
    );
}
#[doc = " frame drop attr."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPFrameDropAttr {
    #[doc = "< frame drop parameters for each channel"]
    pub fdrop: [IMPISPFrameDrop; 3usize],
}
#[test]
fn bindgen_test_layout_IMPISPFrameDropAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPFrameDropAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPFrameDropAttr>(),
        36usize,
        concat!("Size of: ", stringify!(IMPISPFrameDropAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPFrameDropAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPFrameDropAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdrop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFrameDropAttr),
            "::",
            stringify!(fdrop)
        )
    );
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFrameDrop(IMPISPFrameDropAttr *attr)\n\n Set frame drop attr.\n\n @param[in] attr      Frame drop attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Every time (lsize+1) is accepted, (fmark invalid figure) is lost.\n @remark Example:lsize=3,fmark=0x5(Frames 2 and 4 are lost every 4).\n\n @attention Before using it, make sure that 'IMP_ISP_Open' is working properly."]
    pub fn IMP_ISP_SetFrameDrop(attr: *mut IMPISPFrameDropAttr) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_GetFrameDrop(IMPISPFrameDropAttr *attr)\n\n Get frame drop attr.\n\n @param[out] attr     Frame drop attr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @remark Every time (lsize+1) is accepted, (fmark invalid figure) is lost.\n @remark Example:lsize=3,fmark=0x5(Frames 2 and 4 are lost every 4).\n\n @attention Before using it, make sure that 'IMP_ISP_Open' is working properly."]
    pub fn IMP_ISP_GetFrameDrop(attr: *mut IMPISPFrameDropAttr) -> i32;
}
#[doc = " mjpeg fixed contrast."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPFixedContrastAttr {
    pub mode: IMPISPTuningOpsMode,
    pub range_low: u8,
    pub range_high: u8,
}
#[test]
fn bindgen_test_layout_IMPISPFixedContrastAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPFixedContrastAttr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPFixedContrastAttr>(),
        8usize,
        concat!("Size of: ", stringify!(IMPISPFixedContrastAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPFixedContrastAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPISPFixedContrastAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFixedContrastAttr),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_low) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFixedContrastAttr),
            "::",
            stringify!(range_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range_high) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPFixedContrastAttr),
            "::",
            stringify!(range_high)
        )
    );
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SetFixedContraster(IMPISPFixedContrastAttr *attr)\n\n set mjpeg fixed contrast.\n\n @param[out] attr\tattr.\n\n @retval 0 means success.\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_SetFixedContraster(attr: *mut IMPISPFixedContrastAttr) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPISPGPIO {
    pub gpio_num: [u16; 10usize],
    #[doc = " gpio num"]
    pub gpio_sta: [u16; 10usize],
    #[doc = " gpio state"]
    pub free: u16,
}
#[test]
fn bindgen_test_layout_IMPISPGPIO() {
    const UNINIT: ::std::mem::MaybeUninit<IMPISPGPIO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPISPGPIO>(),
        42usize,
        concat!("Size of: ", stringify!(IMPISPGPIO))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPISPGPIO>(),
        2usize,
        concat!("Alignment of ", stringify!(IMPISPGPIO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpio_num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPGPIO),
            "::",
            stringify!(gpio_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gpio_sta) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPGPIO),
            "::",
            stringify!(gpio_sta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPISPGPIO),
            "::",
            stringify!(free)
        )
    );
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SET_GPIO_INIT_OR_FREE(IMPISPGPIO *gpio)\n\n application and release GPIO\n @param[in] gpio_num application and release GPIO num，end mark 0xFF\n @param[in] gpio_sta GPIO state，0:low 1:high\n @param[in] free 0:application 1:release\n\n @retval 0 means success\n @retval Other values mean failure, its value is an error code.\n\n @remark gpio_num[10]={20,21,0xff},gpio_sta[10]= {1,0} means init PA20 high PA21 low\n\n @attention Before using it, make sure that 'IMP_ISP_EnableTuning' is working properly."]
    pub fn IMP_ISP_SET_GPIO_INIT_OR_FREE(attr: *mut IMPISPGPIO) -> i32;
}
extern "C" {
    #[doc = " @fn int32_t IMP_ISP_SET_GPIO_STA(IMPISPGPIO *attr);\n\n set GPIO state in vic done.\n\n @param[in] gpio_num set GPIO num，end mark 0xFF\n @param[in] gpio_sta GPIO state，0:low 1:high\n\n @remark gpio_num[10]={20,21,0xff},gpio_sta[10]= {1,0} means PA20 high PA21 low\n\n @retval 0 means success\n @retval Other values mean failure, its value is an error code.\n\n @attention Before using it, make sure that 'IMP_ISP_SET_GPIO_INIT_OR_FREE' is working properly."]
    pub fn IMP_ISP_SET_GPIO_STA(attr: *mut IMPISPGPIO) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPIVSInterface {
    #[doc = "< algorithm input parameter"]
    pub param: *mut ::std::os::raw::c_void,
    #[doc = "< parameter size"]
    pub paramSize: ::std::os::raw::c_int,
    #[doc = "< input pixel format"]
    pub pixfmt: IMPPixelFormat,
    #[doc = "< init algorithm func"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface) -> ::std::os::raw::c_int,
    >,
    #[doc = "< exit algorithm func"]
    pub exit: ::std::option::Option<unsafe extern "C" fn(inf: *mut IMPIVSInterface)>,
    #[doc = "< algorithm preprocess func, it's parameter frame hasn't been special locked by SDK IVS module, so no need to unlock by using free date, return >=0-> ok，-1->error"]
    pub preProcessSync: ::std::option::Option<
        unsafe extern "C" fn(
            inf: *mut IMPIVSInterface,
            frame: *mut IMPFrameInfo,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< algorithm process func, should be sure unused frames must be unlocked by using free data asap, must be realized for it's a key func to generate algorithm result, return 0->nomal，1->skip check，-1->error"]
    pub processAsync: ::std::option::Option<
        unsafe extern "C" fn(
            inf: *mut IMPIVSInterface,
            frame: *mut IMPFrameInfo,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< get algorithm result"]
    pub getResult: ::std::option::Option<
        unsafe extern "C" fn(
            inf: *mut IMPIVSInterface,
            result: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< release algorithm result"]
    pub releaseResult: ::std::option::Option<
        unsafe extern "C" fn(
            inf: *mut IMPIVSInterface,
            result: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< get algorithm parameter"]
    pub getParam: ::std::option::Option<
        unsafe extern "C" fn(
            inf: *mut IMPIVSInterface,
            param: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< set algorithm parameter"]
    pub setParam: ::std::option::Option<
        unsafe extern "C" fn(
            inf: *mut IMPIVSInterface,
            param: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = "< Released all frame which got and cached by processAsync"]
    pub flushFrame: ::std::option::Option<
        unsafe extern "C" fn(inf: *mut IMPIVSInterface) -> ::std::os::raw::c_int,
    >,
    #[doc = "< private info"]
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_IMPIVSInterface() {
    const UNINIT: ::std::mem::MaybeUninit<IMPIVSInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPIVSInterface>(),
        96usize,
        concat!("Size of: ", stringify!(IMPIVSInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPIVSInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPIVSInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(paramSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixfmt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(pixfmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(exit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preProcessSync) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(preProcessSync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processAsync) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(processAsync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getResult) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(getResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).releaseResult) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(releaseResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getParam) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(getParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setParam) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(setParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flushFrame) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(flushFrame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPIVSInterface),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[doc = " Create IVS group\n\n @fn int IMP_IVS_CreateGroup(int GrpNum);\n\n @param[in] GrpNum IVS group number\n\n @retval 0 success\n @retval 1 failed"]
    pub fn IMP_IVS_CreateGroup(GrpNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy IVS group\n\n @fn int IMP_IVS_DestroyGroup(int GrpNum);\n\n @param[in] GrpNum IVS group number\n\n @retval 0 success\n @retval 1 failed"]
    pub fn IMP_IVS_DestroyGroup(GrpNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create IVS channel to one algorithm entity.\n\n @fn int IMP_IVS_CreateChn(int ChnNum, IMPIVSInterface *handler);\n\n @param[in] ChnNum \tIVS channel number, advice being equal to algorithm index\n\n @param[in] handler \tIVS algorithm handler, an entity of one algorithm interface.\n\n @retval 0 success\n @retval 1 failed"]
    pub fn IMP_IVS_CreateChn(
        ChnNum: ::std::os::raw::c_int,
        handler: *mut IMPIVSInterface,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy IVS channel.\n\n @fn int IMP_IVS_DestroyChn(int ChnNum);\n\n @param[in] ChnNum ivs channel number\n\n @retval 0 success\n @retval 1 failed"]
    pub fn IMP_IVS_DestroyChn(ChnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register one ivs channel to an ivs group\n\n @fn int IMP_IVS_RegisterChn(int GrpNum, int ChnNum);\n\n @param[in] GrpNum IVS group number\n\n @param[in] ChnNum IVS channel number\n\n @retval 0 success\n @retval 1 failed\n @remarks ChnNum is the registered Channel to the Group(GrpNum)"]
    pub fn IMP_IVS_RegisterChn(
        GrpNum: ::std::os::raw::c_int,
        ChnNum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister one ivs channel from its registered ivs group\n\n @fn int IMP_IVS_UnRegisterChn(int ChnNum);\n\n @param[in] ChnNum IVS channel number\n\n @retval 0 success\n @retval 1 failed"]
    pub fn IMP_IVS_UnRegisterChn(ChnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Channel starts receiving picture(s)\n\n @fn int IMP_IVS_StartRecvPic(int ChnNum);\n\n @param[in] ChnNum ivs channel number\n\n @retval 0 success\n @retval 1 failed\n @remarks ChnNum is the Channel which starts receiving pictures"]
    pub fn IMP_IVS_StartRecvPic(ChnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Channel stops receiving picture(s)\n\n @fn int IMP_IVS_StopRecvPic(int ChnNum);\n\n @param[in] ChnNum ivs channel number\n\n @retval 0 success\n @retval 1 failed\n @remarks ChnNum is the Channel which stops receiving pictures"]
    pub fn IMP_IVS_StopRecvPic(ChnNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether the blocking judge can or can not get the result of IVS function\n\n @fn int IMP_IVS_PollingResult(int ChnNum, int timeoutMs);\n\n @param[in] ChnNum \tivs channel number\n @param[in] timeout \tmax wait time，unit:ms;IMP_IVS_DEFAULT_TIMEOUTMS:internel wait time,0:no wait, >0: customer set wait time\n\n @retval 0 success\n @retval 1 failed\n\n @remark Only when the channel is created then the parameter IMPIVSInterface structure (in the ProcessAsync member) returns 0, that can help to say that the return function is working properly, so the PollingResult return function can be a success."]
    pub fn IMP_IVS_PollingResult(
        ChnNum: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get IVS algorithm check result\n\n @fn int IMP_IVS_GetResult(int ChnNum, void **result);\n\n @param[in] ChnNum \tIVS channel number\n @param[in] result \tthe result to one check process of the algorithm registerd to the ivs channel(ChnNum)\n\n @retval 0 success\n @retval 1 failed\n @remarks According to different functions of IVS binding channel, the output might be different (corresponding results)."]
    pub fn IMP_IVS_GetResult(
        ChnNum: ::std::os::raw::c_int,
        result: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release IVS algorithm check result\n\n @fn int IMP_IVS_ReleaseResult(int ChnNum, void *result);\n\n @param[in] GrpNum IVS group number\n @param[in] ChnNum IVS channel number\n\n @param[in] result the result to one check process of the algorithm registerd to the ivs channel which num is ChnNum\n\n @retval 0 success\n @retval 1 failed\n @remarks According to different functions of IVS binding channel, it might Release different result resource for its output."]
    pub fn IMP_IVS_ReleaseResult(
        ChnNum: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release IVS function to calculate the resources result\n\n @fn int IMP_IVS_ReleaseData(void *vaddr);\n\n @param[in] vaddr the released frame's virtual address\n\n @retval 0 success\n @retval 1 failed\n @remarks if libimp is used, it is a must to use the free_data of IVS function."]
    pub fn IMP_IVS_ReleaseData(vaddr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the algorithm parameter held by the channel indexed by ChnNum\n\n @fn int IMP_IVS_GetParam(int chnNum, void *param);\n\n @param[in] ChnNum \tIVS channel number\n @param[in] param \talgorithm parameter (virtual address pointer).\n\n @retval 0 success\n @retval 1 failed"]
    pub fn IMP_IVS_GetParam(
        chnNum: ::std::os::raw::c_int,
        param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the algorithm parameter held by the channel indexed by ChnNum\n\n @fn int IMP_IVS_SetParam(int chnNum, void *param);\n\n @param[in] ChnNum \tIVS channel number\n @param[in] param \talgorithm parameter pointer.\n\n @retval 0 success\n @retval 1 failed"]
    pub fn IMP_IVS_SetParam(
        chnNum: ::std::os::raw::c_int,
        param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = "Base Motion detection algorithm input parameter structure"]
#[repr(C)]
#[derive(Debug)]
pub struct IMP_IVS_BaseMoveParam {
    pub skipFrameCnt: ::std::os::raw::c_int,
    pub referenceNum: ::std::os::raw::c_int,
    pub sadMode: ::std::os::raw::c_int,
    pub sense: ::std::os::raw::c_int,
    #[doc = "< frame information, only need to assign width and height"]
    pub frameInfo: IMPFrameInfo,
}
#[test]
fn bindgen_test_layout_IMP_IVS_BaseMoveParam() {
    const UNINIT: ::std::mem::MaybeUninit<IMP_IVS_BaseMoveParam> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMP_IVS_BaseMoveParam>(),
        64usize,
        concat!("Size of: ", stringify!(IMP_IVS_BaseMoveParam))
    );
    assert_eq!(
        ::std::mem::align_of::<IMP_IVS_BaseMoveParam>(),
        8usize,
        concat!("Alignment of ", stringify!(IMP_IVS_BaseMoveParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skipFrameCnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_BaseMoveParam),
            "::",
            stringify!(skipFrameCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).referenceNum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_BaseMoveParam),
            "::",
            stringify!(referenceNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sadMode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_BaseMoveParam),
            "::",
            stringify!(sadMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sense) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_BaseMoveParam),
            "::",
            stringify!(sense)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_BaseMoveParam),
            "::",
            stringify!(frameInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMP_IVS_BaseMoveOutput {
    pub ret: ::std::os::raw::c_int,
    pub data: *mut u8,
    pub datalen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMP_IVS_BaseMoveOutput() {
    const UNINIT: ::std::mem::MaybeUninit<IMP_IVS_BaseMoveOutput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMP_IVS_BaseMoveOutput>(),
        24usize,
        concat!("Size of: ", stringify!(IMP_IVS_BaseMoveOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<IMP_IVS_BaseMoveOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(IMP_IVS_BaseMoveOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ret) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_BaseMoveOutput),
            "::",
            stringify!(ret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_BaseMoveOutput),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datalen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_BaseMoveOutput),
            "::",
            stringify!(datalen)
        )
    );
}
extern "C" {
    #[doc = " Create motion detection interface\n\n @fn IMPIVSInterface *IMP_IVS_CreateBaseMoveInterface(IMP_IVS_BaseMoveParam *param);\n\n @param[in] param motion detection algorithm input parameter structure\n\n @retval not NULL success, returns the motion detection interface handler pointer\n @retval NULL failed\n\n @attention null"]
    pub fn IMP_IVS_CreateBaseMoveInterface(
        param: *mut IMP_IVS_BaseMoveParam,
    ) -> *mut IMPIVSInterface;
}
extern "C" {
    #[doc = " Destroy move detection interface\n\n @fn void IMP_IVS_DestroyBaseMoveInterface(IMPIVSInterface *moveInterface);\n\n @param[in] moveInterface motion detection interface handler pointer\n\n @retval no return"]
    pub fn IMP_IVS_DestroyBaseMoveInterface(moveInterface: *mut IMPIVSInterface);
}
#[doc = " Motion detection algorithm input parameter structure"]
#[repr(C)]
#[derive(Debug)]
pub struct IMP_IVS_MoveParam {
    #[doc = "< Sensitivity of motion detection: the range to normal camera is 0-4, while to Panoramic camera is 0-8"]
    pub sense: [::std::os::raw::c_int; 52usize],
    pub skipFrameCnt: ::std::os::raw::c_int,
    #[doc = "< frame information, only need to assign width and height"]
    pub frameInfo: IMPFrameInfo,
    pub roiRect: [IMPRect; 52usize],
    pub roiRectCnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMP_IVS_MoveParam() {
    const UNINIT: ::std::mem::MaybeUninit<IMP_IVS_MoveParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMP_IVS_MoveParam>(),
        1104usize,
        concat!("Size of: ", stringify!(IMP_IVS_MoveParam))
    );
    assert_eq!(
        ::std::mem::align_of::<IMP_IVS_MoveParam>(),
        8usize,
        concat!("Alignment of ", stringify!(IMP_IVS_MoveParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sense) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_MoveParam),
            "::",
            stringify!(sense)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skipFrameCnt) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_MoveParam),
            "::",
            stringify!(skipFrameCnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameInfo) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_MoveParam),
            "::",
            stringify!(frameInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roiRect) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_MoveParam),
            "::",
            stringify!(roiRect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roiRectCnt) as usize - ptr as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_MoveParam),
            "::",
            stringify!(roiRectCnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMP_IVS_MoveOutput {
    pub retRoi: [::std::os::raw::c_int; 52usize],
}
#[test]
fn bindgen_test_layout_IMP_IVS_MoveOutput() {
    const UNINIT: ::std::mem::MaybeUninit<IMP_IVS_MoveOutput> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMP_IVS_MoveOutput>(),
        208usize,
        concat!("Size of: ", stringify!(IMP_IVS_MoveOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<IMP_IVS_MoveOutput>(),
        4usize,
        concat!("Alignment of ", stringify!(IMP_IVS_MoveOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retRoi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMP_IVS_MoveOutput),
            "::",
            stringify!(retRoi)
        )
    );
}
extern "C" {
    #[doc = " Create motion detection interface\n\n @fn IMPIVSInterface *IMP_IVS_CreateMoveInterface(IMP_IVS_MoveParam *param);\n\n @param[in] param motion detection algorithm input parameter structure\n\n @retval not NULL success, returns the motion detection interface handler pointer\n @retval NULL failed\n\n @attention null"]
    pub fn IMP_IVS_CreateMoveInterface(param: *mut IMP_IVS_MoveParam) -> *mut IMPIVSInterface;
}
extern "C" {
    #[doc = " Destroy move detection interface\n\n @fn void IMP_IVS_DestroyMoveInterface(IMPIVSInterface *moveInterface);\n\n @param[in] moveInterface motion detection interface handler pointer\n\n @retval no return"]
    pub fn IMP_IVS_DestroyMoveInterface(moveInterface: *mut IMPIVSInterface);
}
pub const IMP_LOG_LEVEL_UNKNOWN: _bindgen_ty_11 = 0;
pub const IMP_LOG_LEVEL_RESERVED: _bindgen_ty_11 = 1;
pub const IMP_LOG_LEVEL_VERBOSE: _bindgen_ty_11 = 2;
pub const IMP_LOG_LEVEL_DEBUG: _bindgen_ty_11 = 3;
pub const IMP_LOG_LEVEL_INFO: _bindgen_ty_11 = 4;
pub const IMP_LOG_LEVEL_WARN: _bindgen_ty_11 = 5;
pub const IMP_LOG_LEVEL_ERROR: _bindgen_ty_11 = 6;
pub const IMP_LOG_LEVEL_FATAL: _bindgen_ty_11 = 7;
pub const IMP_LOG_LEVEL_SILENT: _bindgen_ty_11 = 8;
#[doc = " define log level"]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " used internal"]
    pub fn imp_log_fun(
        le: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        out: ::std::os::raw::c_int,
        tag: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Set printing options\n\n @fn void IMP_Log_Set_Option(int op);\n\n @param[in] op set printing options\n"]
    pub fn IMP_Log_Set_Option(op: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get printing options\n\n @fn int IMP_Log_Get_Option(void );\n\n @retval returns the system's printing options\n"]
    pub fn IMP_Log_Get_Option() -> ::std::os::raw::c_int;
}
#[doc = " OSD region handle"]
pub type IMPRgnHandle = ::std::os::raw::c_int;
#[doc = "< black"]
pub const IMPOsdColour_OSD_BLACK: IMPOsdColour = 4278190080;
#[doc = "< white"]
pub const IMPOsdColour_OSD_WHITE: IMPOsdColour = 4294967295;
#[doc = "< red"]
pub const IMPOsdColour_OSD_RED: IMPOsdColour = 4294901760;
#[doc = "< green"]
pub const IMPOsdColour_OSD_GREEN: IMPOsdColour = 4278255360;
#[doc = "< blue"]
pub const IMPOsdColour_OSD_BLUE: IMPOsdColour = 4278190335;
#[doc = " OSD color type, color format is bgra"]
pub type IMPOsdColour = ::std::os::raw::c_uint;
#[doc = "< undefined region type"]
pub const IMPOsdRgnType_OSD_REG_INV: IMPOsdRgnType = 0;
#[doc = "< line"]
pub const IMPOsdRgnType_OSD_REG_LINE: IMPOsdRgnType = 1;
#[doc = "< rectangle"]
pub const IMPOsdRgnType_OSD_REG_RECT: IMPOsdRgnType = 2;
#[doc = "< dot matrix image"]
pub const IMPOsdRgnType_OSD_REG_BITMAP: IMPOsdRgnType = 3;
#[doc = "< rectangle cover"]
pub const IMPOsdRgnType_OSD_REG_COVER: IMPOsdRgnType = 4;
#[doc = "< picture, suitable for Logo or time stamp"]
pub const IMPOsdRgnType_OSD_REG_PIC: IMPOsdRgnType = 5;
#[doc = "< picture, suitable for Logo or time stamp,use RMEM memory"]
pub const IMPOsdRgnType_OSD_REG_PIC_RMEM: IMPOsdRgnType = 6;
#[doc = " OSD region type"]
pub type IMPOsdRgnType = ::std::os::raw::c_uint;
#[doc = " OSD region line and rectangle data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lineRectData {
    #[doc = "< color,only supports OSD_WHITE，OSD_BLACK，OSD_RED three formats"]
    pub color: u32,
    #[doc = "< line width"]
    pub linewidth: u32,
}
#[test]
fn bindgen_test_layout_lineRectData() {
    const UNINIT: ::std::mem::MaybeUninit<lineRectData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lineRectData>(),
        8usize,
        concat!("Size of: ", stringify!(lineRectData))
    );
    assert_eq!(
        ::std::mem::align_of::<lineRectData>(),
        4usize,
        concat!("Alignment of ", stringify!(lineRectData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lineRectData),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linewidth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lineRectData),
            "::",
            stringify!(linewidth)
        )
    );
}
#[doc = " OSD region cover data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct coverData {
    #[doc = "< color, only supports bgra color format"]
    pub color: u32,
}
#[test]
fn bindgen_test_layout_coverData() {
    const UNINIT: ::std::mem::MaybeUninit<coverData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<coverData>(),
        4usize,
        concat!("Size of: ", stringify!(coverData))
    );
    assert_eq!(
        ::std::mem::align_of::<coverData>(),
        4usize,
        concat!("Alignment of ", stringify!(coverData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(coverData),
            "::",
            stringify!(color)
        )
    );
}
#[doc = " OSD region picture data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct picData {
    #[doc = "< picture data pointer"]
    pub pData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_picData() {
    const UNINIT: ::std::mem::MaybeUninit<picData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<picData>(),
        8usize,
        concat!("Size of: ", stringify!(picData))
    );
    assert_eq!(
        ::std::mem::align_of::<picData>(),
        8usize,
        concat!("Alignment of ", stringify!(picData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(picData),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " OSD region attribute data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPOSDRgnAttrData {
    #[doc = "< bitmapData data"]
    pub bitmapData: *mut ::std::os::raw::c_void,
    #[doc = "< line, rectangle data"]
    pub lineRectData: lineRectData,
    #[doc = "< cover data"]
    pub coverData: coverData,
    #[doc = "< picture data"]
    pub picData: picData,
}
#[test]
fn bindgen_test_layout_IMPOSDRgnAttrData() {
    const UNINIT: ::std::mem::MaybeUninit<IMPOSDRgnAttrData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPOSDRgnAttrData>(),
        8usize,
        concat!("Size of: ", stringify!(IMPOSDRgnAttrData))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPOSDRgnAttrData>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPOSDRgnAttrData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmapData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnAttrData),
            "::",
            stringify!(bitmapData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lineRectData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnAttrData),
            "::",
            stringify!(lineRectData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coverData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnAttrData),
            "::",
            stringify!(coverData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).picData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnAttrData),
            "::",
            stringify!(picData)
        )
    );
}
#[doc = " OSD region attribute data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPOSDRgnAttr {
    #[doc = "< OSD region type"]
    pub type_: IMPOsdRgnType,
    #[doc = "< rectangle data"]
    pub rect: IMPRect,
    #[doc = "< point format"]
    pub fmt: IMPPixelFormat,
    #[doc = "< OSD region attribute data"]
    pub data: IMPOSDRgnAttrData,
}
#[test]
fn bindgen_test_layout_IMPOSDRgnAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPOSDRgnAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPOSDRgnAttr>(),
        32usize,
        concat!("Size of: ", stringify!(IMPOSDRgnAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPOSDRgnAttr>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPOSDRgnAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnAttr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rect) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnAttr),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fmt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnAttr),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnAttr),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " OSD Rgn vaild timestamp"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPOSDRgnTimestamp {
    #[doc = "< timestamp"]
    pub ts: u64,
    #[doc = "< mix to timestamp"]
    pub minus: u64,
    #[doc = "< max to timestamp"]
    pub plus: u64,
}
#[test]
fn bindgen_test_layout_IMPOSDRgnTimestamp() {
    const UNINIT: ::std::mem::MaybeUninit<IMPOSDRgnTimestamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPOSDRgnTimestamp>(),
        24usize,
        concat!("Size of: ", stringify!(IMPOSDRgnTimestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPOSDRgnTimestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(IMPOSDRgnTimestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ts) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnTimestamp),
            "::",
            stringify!(ts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnTimestamp),
            "::",
            stringify!(minus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDRgnTimestamp),
            "::",
            stringify!(plus)
        )
    );
}
#[doc = " OSD group region attribute"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPOSDGrpRgnAttr {
    #[doc = "< display variable"]
    pub show: ::std::os::raw::c_int,
    #[doc = "< display start coordinates"]
    pub offPos: IMPPoint,
    #[doc = "< zoom x parameters"]
    pub scalex: f32,
    #[doc = "< zoom y parameters"]
    pub scaley: f32,
    #[doc = "< Alpha switch"]
    pub gAlphaEn: ::std::os::raw::c_int,
    #[doc = "< prospect Alpha"]
    pub fgAlhpa: ::std::os::raw::c_int,
    #[doc = "< background Alpha"]
    pub bgAlhpa: ::std::os::raw::c_int,
    #[doc = "< display layer"]
    pub layer: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_IMPOSDGrpRgnAttr() {
    const UNINIT: ::std::mem::MaybeUninit<IMPOSDGrpRgnAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPOSDGrpRgnAttr>(),
        36usize,
        concat!("Size of: ", stringify!(IMPOSDGrpRgnAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPOSDGrpRgnAttr>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPOSDGrpRgnAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDGrpRgnAttr),
            "::",
            stringify!(show)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offPos) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDGrpRgnAttr),
            "::",
            stringify!(offPos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scalex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDGrpRgnAttr),
            "::",
            stringify!(scalex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaley) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDGrpRgnAttr),
            "::",
            stringify!(scaley)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gAlphaEn) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDGrpRgnAttr),
            "::",
            stringify!(gAlphaEn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fgAlhpa) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDGrpRgnAttr),
            "::",
            stringify!(fgAlhpa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bgAlhpa) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDGrpRgnAttr),
            "::",
            stringify!(bgAlhpa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPOSDGrpRgnAttr),
            "::",
            stringify!(layer)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_OSD_CreateGroup(int grpNum)\n\n create OSD group\n\n @param[in] grpNum OSD group number, range: [0, @ref NR_MAX_OSD_GROUPS - 1]\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks no。\n\n @attention no."]
    pub fn IMP_OSD_CreateGroup(grpNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_DestroyGroup(int grpNum)\n\n destory OSD group\n\n @param[in] grpNum OSD group number, range: [0, @ref NR_MAX_OSD_GROUPS - 1]\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks When this is called the corresponding group should be created.\n\n @attention no."]
    pub fn IMP_OSD_DestroyGroup(grpNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_AttachToGroup(IMPCell *from, IMPCell *to)\n\n Adding OSD group to the system.\n\n @param[in] from OSD unit\n @param[in] to Other unit in the system\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks The new version of SDK is recommended to use Bind in order to string OSD into the system's data stream, Attach is no longer recommended to use, but API reservations, easy to be compatible with the previous version of the software.\n reference :  @ref bind\n\n @attention no."]
    pub fn IMP_OSD_AttachToGroup(from: *mut IMPCell, to: *mut IMPCell) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn IMPRgnHandle IMP_OSD_CreateRgn(IMPOSDRgnAttr *prAttr)\n\n Create OSD region\n\n @param[in] prAttr OSD region attribute\n\n @retval greater than or equal to 0 success\n @retval less than 0 failure\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_OSD_CreateRgn(prAttr: *mut IMPOSDRgnAttr) -> IMPRgnHandle;
}
extern "C" {
    #[doc = " @fn void IMP_OSD_DestroyRgn(IMPRgnHandle handle)\n\n Destory OSD region\n\n @param[in] prAttr region handle, IMP_OSD_CreateRgn return value\n\n @retval no\n\n @remarks no.\n\n @attention no."]
    pub fn IMP_OSD_DestroyRgn(handle: IMPRgnHandle);
}
extern "C" {
    #[doc = " @fn int IMP_OSD_RegisterRgn(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n Register OSD region\n\n @param[in] handle region handle, IMP_OSD_CreateRgn return value\n @param[in] grpNum OSD group number\n @param[in] pgrAttr OSD group display attribute\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks The corresponding OSD group should be already created before calling this function.\n\n @attention no."]
    pub fn IMP_OSD_RegisterRgn(
        handle: IMPRgnHandle,
        grpNum: ::std::os::raw::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_UnRegisterRgn(IMPRgnHandle handle, int grpNum)\n\n Register OSD region\n\n @param[in] handle region handle, IMP_OSD_CreateRgn return value\n @param[in] grpNum OSD group number\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks The corresponding OSD group should be already created and registered before calling this function.\n\n @attention no."]
    pub fn IMP_OSD_UnRegisterRgn(
        handle: IMPRgnHandle,
        grpNum: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttr(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr)\n\n Set region properties\n\n @param[in] handle region handle, IMP_OSD_CreateRgn return value\n @param[in] prAttr OSD region attribute\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks The corresponding OSD group should be already created before calling this function.\n\n @attention no."]
    pub fn IMP_OSD_SetRgnAttr(
        handle: IMPRgnHandle,
        prAttr: *mut IMPOSDRgnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetRgnAttrWithTimestamp(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr, IMPOSDRgnTimestamp *prTs)\n\n Set region properties and effective time\n\n @param[in] handle region handle, IMP_OSD_CreateRgn return value\n @param[in] prAttr OSD region attribute\n @param[in] prTs effective time\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks The corresponding OSD group should be already created before calling this function.\n\n @attention none."]
    pub fn IMP_OSD_SetRgnAttrWithTimestamp(
        handle: IMPRgnHandle,
        prAttr: *mut IMPOSDRgnAttr,
        prTs: *mut IMPOSDRgnTimestamp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetRgnAttr(IMPRgnHandle handle, IMPOSDRgnAttr *prAttr)\n\n Get region attribute\n\n @param[in] handle region handle, IMP_OSD_CreateRgn return value\n @param[out] prAttr OSD region attribute\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks The corresponding OSD group should be already created before calling this function.\n\n @attention no."]
    pub fn IMP_OSD_GetRgnAttr(
        handle: IMPRgnHandle,
        prAttr: *mut IMPOSDRgnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_UpdateRgnAttrData(IMPRgnHandle handle, IMPOSDRgnAttrData *prAttrData)\n\n Update the regional data attribute, only for OSD_REG_BITMAP and OSD_REG_PIC regional types\n\n @param[in] handle       region handle, IMP_OSD_CreateRgn return value\n @param[in] prAttrData   OSD regional data attributes\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks Before calling this function, the corresponding OSD group should be already created and region attributes already set to OSD_REG_BITMAP or OSD_REG_PIC.\n\n @attention no."]
    pub fn IMP_OSD_UpdateRgnAttrData(
        handle: IMPRgnHandle,
        prAttrData: *mut IMPOSDRgnAttrData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_SetGrpRgnAttr(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n Set OSD group region attributes\n\n @param[in] handle \tregion handle, IMP_OSD_CreateRgn return value\n @param[in] grpNum \tOSD group number\n @param[in] pgrAttr \tOSD group region attributes\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks Before calling this function, the corresponding OSD group should be already created and the region should be created and registered.\n\n @attention no."]
    pub fn IMP_OSD_SetGrpRgnAttr(
        handle: IMPRgnHandle,
        grpNum: ::std::os::raw::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_GetGrpRgnAttr(IMPRgnHandle handle, int grpNum, IMPOSDGrpRgnAttr *pgrAttr)\n\n Get OSD group region attributes\n\n @param[in] handle region handle, IMP_OSD_CreateRgn return value\n @param[in] grpNum OSD group number\n @param[out] pgrAttr OSD group region attributes\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks Before calling this function, the corresponding OSD group should be already created and the region should be created and registered.\n\n @attention no."]
    pub fn IMP_OSD_GetGrpRgnAttr(
        handle: IMPRgnHandle,
        grpNum: ::std::os::raw::c_int,
        pgrAttr: *mut IMPOSDGrpRgnAttr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_ShowRgn(IMPRgnHandle handle, int grpNum, int showFlag)\n\n Set whether the group region is displayed or not.\n\n @param[in] handle \tregion handle, IMP_OSD_CreateRgn return value\n @param[in] grpNum \tOSD group number\n @param[in] showFlag \tOSD group region display switch\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks Before calling this function, the corresponding OSD group should be already created and the region should be created and registered.\n\n @attention no."]
    pub fn IMP_OSD_ShowRgn(
        handle: IMPRgnHandle,
        grpNum: ::std::os::raw::c_int,
        showFlag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_Start(int grpNum)\n\n Set start OSD group display\n\n @param[in] grpNum OSD group number\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks Before calling this function, the corresponding OSD group should be already created.\n\n @attention no."]
    pub fn IMP_OSD_Start(grpNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_OSD_Stop(int grpNum)\n\n Set the display to stop the OSD group\n\n @param[in] grpNum OSD group number\n\n @retval 0 success\n @retval non-0 failure\n\n @remarks Before calling this function, the corresponding OSD group should be already created.\n\n @attention no."]
    pub fn IMP_OSD_Stop(grpNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " IMP Version definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMPVersion {
    #[doc = "< IMP Version"]
    pub aVersion: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_IMPVersion() {
    const UNINIT: ::std::mem::MaybeUninit<IMPVersion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IMPVersion>(),
        64usize,
        concat!("Size of: ", stringify!(IMPVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(IMPVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPVersion),
            "::",
            stringify!(aVersion)
        )
    );
}
extern "C" {
    #[doc = " @fn int IMP_System_Init(void)\n\n Initialize the IMP.\n\n @param None.\n\n @retval 0 Success.\n @retval OtherValues Failure.\n\n @remarks After calling this API, the basis of data structure will be initialized, but does not initialize the hardware unit.\n\n @attention This interface must be initialized before any operation in IMP is required."]
    pub fn IMP_System_Init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_Exit(void)\n\n Deinitialize the IMP.\n\n @param None.\n\n @retval 0 Success.\n @retval OtherValues Failure.\n\n @remarks Memory and handlers will be freed after calling this API, also hardware will be closed.\n\n @attention After calling this API, if you want to use the IMP again, you need to reinitialize the IMP system"]
    pub fn IMP_System_Exit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int64_t IMP_System_GetTimeStamp(void)\n\n Get the current timestamp(unit is usec).\n\n @param None.\n\n @retval timestamp(usec).\n\n @remarks After the system initialization, the time stamp is initialized automatically.\n\n @attention None."]
    pub fn IMP_System_GetTimeStamp() -> i64;
}
extern "C" {
    #[doc = " @fn int IMP_System_RebaseTimeStamp(int64_t basets)\n\n Set the timestamp(usec).\n\n @param[in] basets Base timestamp.\n\n @retval 0 Success.\n @retval OtherValues Failure.\n\n @remarks None.\n\n @attention None."]
    pub fn IMP_System_RebaseTimeStamp(basets: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn uint32_t IMP_System_ReadReg32(uint32_t u32Addr)\n\n Read the register(32bit) value.\n\n @param[in] regAddr Physical address register\n\n @retval Value of the the register(32bit).\n\n @remarks None.\n\n @attention None."]
    pub fn IMP_System_ReadReg32(regAddr: u32) -> u32;
}
extern "C" {
    #[doc = " @fn void IMP_System_WriteReg32(uint32_t regAddr, uint32_t value)\n\n Write the value to register(32bit).\n\n @param[in] regAddr Physical address\n @param[in] value    Value to be written\n\n @retval None.\n\n @remarks None.\n\n @attention If you are not clear on the meaning of the register, please call this API carefully, or you may cause a system error."]
    pub fn IMP_System_WriteReg32(regAddr: u32, value: u32);
}
extern "C" {
    #[doc = " @fn int IMP_System_GetVersion(IMPVersion *pstVersion)\n\n Get the version of IMP library.\n\n @param[out] pstVersion Pointer to IMPVersion.\n\n @retval 0 Success.\n @retval OtherValues Failure.\n\n @remarks None.\n\n @attention None."]
    pub fn IMP_System_GetVersion(pstVersion: *mut IMPVersion) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn const char* IMP_System_GetCPUInfo(void)\n\n Get the infomation of CPU.\n\n @param None.\n\n @retval String of IMPVersion.\n\n @remarks The return value is a string of the CPU model type  e.g. \"T10\", \"T10-Lite\" etc.\n\n @attention None."]
    pub fn IMP_System_GetCPUInfo() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @fn int IMP_System_Bind(IMPCell *srcCell, IMPCell *dstCell)\n\n Bind the source Cell and the destination Cell.\n\n @param[in] srcCell The source Cell pointer.\n @param[in] dstCell The destination Cell pointer.\n\n @retval 0 Success.\n @retval OtherValues Failure.\n\n @remarks According to the concepts of Device, Group and Output, Every Device might have several Groups, every Group several Outputs,\n Group is the Device input interface, Output is the output interface, so Binding will be the process of linking the Device's Outputs to the Device's inputs.\n @remarks After Bindding successfully the source Cell will deliver the data to the destination Cell automatically.\n\n @attention None."]
    pub fn IMP_System_Bind(srcCell: *mut IMPCell, dstCell: *mut IMPCell) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_UnBind(IMPCell *srcCell, IMPCell *dstCell)\n\n UnBind source Cell and the destination Cell.\n\n @param[in] srcCell The source Cell pointer.\n @param[in] dstCell The destination Cell pointer.\n\n\n @retval 0 Success.\n @retval OtherValues Failure.\n\n @remarks None.\n\n @attention None."]
    pub fn IMP_System_UnBind(srcCell: *mut IMPCell, dstCell: *mut IMPCell)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int IMP_System_GetBindbyDest(IMPCell *dstCell, IMPCell *srcCell)\n\n Gets the source Cell information that is bound to the destination Cell.\n\n @param[out] srcCell The source Cell pointer.\n @param[in] dstCell The destination Cell pointer.\n\n\n @retval 0 Success.\n @retval OtherValues Failure.\n\n @remarks None.\n\n @attention None."]
    pub fn IMP_System_GetBindbyDest(
        dstCell: *mut IMPCell,
        srcCell: *mut IMPCell,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_System_MemPoolRequest(int poolId, size_t size, const char *name);\n\n Request memory pool on Rmem\n\n @param[in] poolId     ID of the application.\n @param[in] size\t\t Request mempool size.\n @param[in] name\t\t The Pool name.\n\n @retval\t0\t\t\tsuccess.\n @retval  OtherValues Failure.\n\n @remarks\n Video memory pool mainly provides large physical continuous memory management function\n for media business, which is responsible for memory allocation and recovery, and gives\n full play to the role of memory buffer pool, so that physical memory resources can be\n used reasonably in various media processing modules. The video memory pool is based on\n the original reserved memory rmem (the page table is not created by the kernel) for\n large memory management. Each application for a memory pool is physical continuous\n memory, and then applying for memory on this memory pool is also applying for physical\n continuous memory. If a memory pool is used, the size of the memory pool must be\n configured before system initialization. The size and number of memory pool\n applications vary according to different services.\n\n @attention\tnone."]
    pub fn IMP_System_MemPoolRequest(
        poolId: ::std::os::raw::c_int,
        size: usize,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief IMP_System_MemPoolFree\n\n @param[in] poolId:  release mempool rmem area memory\n\n @retval:  0, success\n @retval:  OhterValues,  failure\n\n @attention: Memory pool release: it is forbidden to release when the code stream is running. It can be released only after all resources exit\n In addition, in the SDK, the related memory applications do not go to the memory pool. If frequent applications are released,\n the applications may be caused by memory fragmentation\n In case of failure, it is generally recommended to release the memory pool only when rmem memory is required for other purposes"]
    pub fn IMP_System_MemPoolFree(poolId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn IMPPixfmtToString(pixfmt: IMPPixelFormat) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @fn int SU_ADC_Init(void);\n\n 初始化ADC模块\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 使用ADC之前，一定要调用这个函数。\n\n @attention 无。"]
    pub fn SU_ADC_Init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_Exit(void);\n\n 去初始化ADC模块\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 不使用ADC之后，一定要调用这个函数。\n\n @attention 无。"]
    pub fn SU_ADC_Exit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_EnableChn(uint32_t chn_num);\n\n 启动通道\n\n @param[in] chn_num 启动第几路通道\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 无."]
    pub fn SU_ADC_EnableChn(chn_num: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_DisableChn(uint32_t chn_num);\n\n 关闭通道\n\n @param[in] chn_num 停止第几路通道\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 无"]
    pub fn SU_ADC_DisableChn(chn_num: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_ADC_GetChnValue(uint32_t chn_num, int *value);\n\n 得到第chn_num通道的ADC值\n\n @param[in] chn_num 第几路通道\n\n @param[out] value 得到的ADC值\n\n @retval 0 成功\n @retval 非0 失败，返回错误码\n\n @remark 无\n\n @attention 无"]
    pub fn SU_ADC_GetChnValue(
        chn_num: u32,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " 设备型号."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SUModelNum {
    #[doc = "< 设备型号字符串"]
    pub chr: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_SUModelNum() {
    const UNINIT: ::std::mem::MaybeUninit<SUModelNum> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SUModelNum>(),
        64usize,
        concat!("Size of: ", stringify!(SUModelNum))
    );
    assert_eq!(
        ::std::mem::align_of::<SUModelNum>(),
        1usize,
        concat!("Alignment of ", stringify!(SUModelNum))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUModelNum),
            "::",
            stringify!(chr)
        )
    );
}
#[doc = " 设备软件版本."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SUVersion {
    #[doc = "< 设备软件版本字符串"]
    pub chr: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_SUVersion() {
    const UNINIT: ::std::mem::MaybeUninit<SUVersion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SUVersion>(),
        64usize,
        concat!("Size of: ", stringify!(SUVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<SUVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(SUVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUVersion),
            "::",
            stringify!(chr)
        )
    );
}
#[doc = " 设备ID.设备ID为唯一值，不同的CPU芯片间的值有差异"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUDevID {
    #[doc = "< 设备ID字符串"]
    pub chr: [::std::os::raw::c_char; 64usize],
    #[doc = "< 设备ID二进制"]
    pub hex: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_SUDevID() {
    const UNINIT: ::std::mem::MaybeUninit<SUDevID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SUDevID>(),
        64usize,
        concat!("Size of: ", stringify!(SUDevID))
    );
    assert_eq!(
        ::std::mem::align_of::<SUDevID>(),
        1usize,
        concat!("Alignment of ", stringify!(SUDevID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUDevID),
            "::",
            stringify!(chr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUDevID),
            "::",
            stringify!(hex)
        )
    );
}
#[doc = " 系统时间结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SUTime {
    #[doc = "< 秒数，范围：0~59"]
    pub sec: ::std::os::raw::c_int,
    #[doc = "< 分钟数，范围：0~59"]
    pub min: ::std::os::raw::c_int,
    #[doc = "< 小时数，范围：0~23"]
    pub hour: ::std::os::raw::c_int,
    #[doc = "< 一个月中的第几天，范围：1~31"]
    pub mday: ::std::os::raw::c_int,
    #[doc = "< 月份，范围：1~12"]
    pub mon: ::std::os::raw::c_int,
    #[doc = "< 年份，范围：>1900"]
    pub year: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SUTime() {
    const UNINIT: ::std::mem::MaybeUninit<SUTime> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SUTime>(),
        24usize,
        concat!("Size of: ", stringify!(SUTime))
    );
    assert_eq!(
        ::std::mem::align_of::<SUTime>(),
        4usize,
        concat!("Alignment of ", stringify!(SUTime))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUTime),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SUTime),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SUTime),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SUTime),
            "::",
            stringify!(mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SUTime),
            "::",
            stringify!(mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SUTime),
            "::",
            stringify!(year)
        )
    );
}
extern "C" {
    #[doc = " @fn int SU_Base_GetModelNumber(SUModelNum *modelNum)\n\n 获取设备型号.\n\n @param[out] modelNum 设备型号结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_GetModelNumber(modelNum: *mut SUModelNum) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetVersion(SUVersion *version)\n\n 获取设备版本.\n\n @param[out] version 设备版本结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_GetVersion(version: *mut SUVersion) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetDevID(SUDevID *devID)\n\n 获取设备ID.\n\n @param[out] devID 设备ID结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 每颗CPU芯片的设备ID是唯一的.\n\n @attention 无."]
    pub fn SU_Base_GetDevID(devID: *mut SUDevID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetTime(SUTime *time)\n\n 获得系统时间.\n\n @param[in] time 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_GetTime(time: *mut SUTime) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SetTime(SUTime *time)\n\n 设置系统时间.\n\n @param[out] time 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 系统时间参数需在合理范围，否则函数调用失败."]
    pub fn SU_Base_SetTime(time: *mut SUTime) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SUTime2Raw(SUTime *suTime, uint32_t *rawTime)\n\n 将SUTime类型的时间转换为以秒为单位的Raw时间.\n\n @param[in] suTime 系统时间结构体指针.\n @param[out] rawTime Raw时间(从1970-01-01 00:00:00开始算起).\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 此函数可以用在设置相对秒数的Alarm.\n\n @attention 无."]
    pub fn SU_Base_SUTime2Raw(suTime: *mut SUTime, rawTime: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Raw2SUTime(uint32_t *rawTime, SUTime *suTime)\n\n 将以秒为单位的Raw时间转换为SUTime类型的时间.\n\n @param[in] rawTime Raw时间(从1970-01-01 00:00:00开始算起).\n @param[out] suTime 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 此函数可以用在设置相对秒数的Alarm.\n\n @attention 无."]
    pub fn SU_Base_Raw2SUTime(rawTime: *mut u32, suTime: *mut SUTime) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_SetAlarm(SUTime *time)\n\n 设定闹钟时间.\n\n @param[in] time 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 暂支持24小时内的闹钟设定.\n\n @attention 系统时间参数需在合理范围，否则函数调用失败."]
    pub fn SU_Base_SetAlarm(time: *mut SUTime) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_GetAlarm(SUTime *time)\n\n 获得闹钟定时时间.\n\n @param[out] time 系统时间结构体指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_GetAlarm(time: *mut SUTime) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_EnableAlarm()\n\n 使能闹钟.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数之前，请调用SU_Base_GetAlarm（SUTime *time）设定闹钟时间.\n\n @attention 如果闹钟时间在当前系统时间之前返回失败."]
    pub fn SU_Base_EnableAlarm() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_DisableAlarm()\n\n 关闭闹钟.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Base_DisableAlarm() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_PollingAlarm(uint32_t timeoutMsec)\n\n 等待闹钟.\n\n @param[in] 超时时间，单位：毫秒.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数后，程序会进入阻塞状态，一直到闹钟响应退出或超时退出.\n\n @attention 无."]
    pub fn SU_Base_PollingAlarm(timeoutMsec: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Shutdown(void)\n\n 设备关机.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数后设备会立即关机并关闭主电源.\n\n @attention 在调用此函数之前请确保已保存所有文件."]
    pub fn SU_Base_Shutdown() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Reboot(void)\n\n 设备重启.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数后设备会立即重启.\n\n @attention 在调用此函数之前请确保已保存所有文件."]
    pub fn SU_Base_Reboot() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Base_Suspend(void)\n\n 设备休眠.\n\n @param 无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 调用该函数后设备会立即进入休眠,函数正常退出后说明系统已经唤醒.\n\n @attention 无."]
    pub fn SU_Base_Suspend() -> ::std::os::raw::c_int;
}
#[doc = "< 未知状态或者没有电池"]
pub const SUBatStatus_Unknown: SUBatStatus = -1;
#[doc = "< 充电中"]
pub const SUBatStatus_Charging: SUBatStatus = 0;
#[doc = "< 未充电"]
pub const SUBatStatus_Discharging: SUBatStatus = 1;
#[doc = "< 充满电"]
pub const SUBatStatus_Full: SUBatStatus = 2;
#[doc = " 电池状态."]
pub type SUBatStatus = ::std::os::raw::c_int;
#[doc = "< AC Adapter插入"]
pub const SUBatEvent_AC_ONLINE: SUBatEvent = 0;
#[doc = "< AC Adapter拔出"]
pub const SUBatEvent_AC_OFFLINE: SUBatEvent = 1;
#[doc = "< USB插入"]
pub const SUBatEvent_USB_ONLINE: SUBatEvent = 2;
#[doc = "< USB拔出"]
pub const SUBatEvent_USB_OFFLINE: SUBatEvent = 3;
#[doc = " 电池事件."]
pub type SUBatEvent = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @fn int SU_Battery_GetStatus(SUBatStatus *status)\n\n 获取电池状态.\n\n @param[in] status 电池状态指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 该函数直接返回,无阻塞.\n\n @attention 无."]
    pub fn SU_Battery_GetStatus(status: *mut SUBatStatus) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetEvent(SUBatEvent *event)\n\n 获取电池事件.\n\n @param[out] event 电池事件指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 该函数阻塞,直到有事件发生返回.\n\n @attention 无."]
    pub fn SU_Battery_GetEvent(event: *mut SUBatEvent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetCapacity(void)\n\n 获取电池电量百分比.\n\n @param 无.\n\n @retval >=0 电池电量百分比.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Battery_GetCapacity() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Battery_GetVoltageUV(void)\n\n 获取电池当前电压.\n\n @param 无.\n\n @retval >=0 电池电压,单位uV.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_Battery_GetVoltageUV() -> ::std::os::raw::c_int;
}
pub const IN_UNF_CIPHER_ALG_E_IN_UNF_CIPHER_ALG_AES: IN_UNF_CIPHER_ALG_E = 0;
pub const IN_UNF_CIPHER_ALG_E_IN_UNF_CIPHER_ALG_DES: IN_UNF_CIPHER_ALG_E = 1;
#[doc = " 选择加密算法.\n @remarks 支持AES和DES两种加密算法."]
pub type IN_UNF_CIPHER_ALG_E = ::std::os::raw::c_uint;
#[doc = " 选择加密算法.\n @remarks 支持AES和DES两种加密算法."]
pub use self::IN_UNF_CIPHER_ALG_E as IN_UNF_CIPHER_ALG;
pub const IN_UNF_CIPHER_WORK_MODE_E_IN_UNF_CIPHER_WORK_MODE_ECB: IN_UNF_CIPHER_WORK_MODE_E = 0;
pub const IN_UNF_CIPHER_WORK_MODE_E_IN_UNF_CIPHER_WORK_MODE_CBC: IN_UNF_CIPHER_WORK_MODE_E = 1;
pub const IN_UNF_CIPHER_WORK_MODE_E_IN_UNF_CIPHER_WORK_MODE_OTHER: IN_UNF_CIPHER_WORK_MODE_E = 2;
#[doc = " 选择加密模式.\n @remarks 支持CBC和ECB两种加密模式."]
pub type IN_UNF_CIPHER_WORK_MODE_E = ::std::os::raw::c_uint;
#[doc = " 选择加密模式.\n @remarks 支持CBC和ECB两种加密模式."]
pub use self::IN_UNF_CIPHER_WORK_MODE_E as IN_UNF_CIPHER_WORK_MODE;
pub const IN_UNF_CIPHER_KEY_LENGTH_E_IN_UNF_CIPHER_KEY_AES_128BIT: IN_UNF_CIPHER_KEY_LENGTH_E = 0;
#[doc = " 选择加密使用的密钥长度.\n @remarks 受硬件的限制,现阶段只支持128bit长度的KEY."]
pub type IN_UNF_CIPHER_KEY_LENGTH_E = ::std::os::raw::c_uint;
#[doc = " 选择加密使用的密钥长度.\n @remarks 受硬件的限制,现阶段只支持128bit长度的KEY."]
pub use self::IN_UNF_CIPHER_KEY_LENGTH_E as IN_UNF_CIPHER_KEY_LENGTH;
pub const IN_UNF_CIPHER_BIT_WIDTH_E_IN_UNF_CIPHER_BIT_WIDTH_128BIT: IN_UNF_CIPHER_BIT_WIDTH_E = 0;
#[doc = " 选择加密算法一次处理的数据长度.\n @remarks 受硬件的限制,现阶段只支持一次处理128bit长度的数据."]
pub type IN_UNF_CIPHER_BIT_WIDTH_E = ::std::os::raw::c_uint;
#[doc = " 选择加密算法一次处理的数据长度.\n @remarks 受硬件的限制,现阶段只支持一次处理128bit长度的数据."]
pub use self::IN_UNF_CIPHER_BIT_WIDTH_E as IN_UNF_CIPHER_BIT_WIDTH;
#[doc = " 选择加密处理控制结构体."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IN_UNF_CIPHER_CTRL_S {
    #[doc = "< 加密时使用的密钥"]
    pub key: [::std::os::raw::c_uint; 4usize],
    #[doc = "< 加密时使用的IV向量"]
    pub IV: [::std::os::raw::c_uint; 4usize],
    #[doc = "< 需要处理的数据总长度"]
    pub enDataLen: ::std::os::raw::c_uint,
    #[doc = "< 处理数据使用的加密算法"]
    pub enAlg: IN_UNF_CIPHER_ALG,
    #[doc = "< 加密算法一次处理的数据长度"]
    pub enBitWidth: IN_UNF_CIPHER_BIT_WIDTH,
    #[doc = "< 处理数据使用的加密算法的模式"]
    pub enWorkMode: IN_UNF_CIPHER_WORK_MODE,
    #[doc = "< 加密算法使用的KEY的长度"]
    pub enKeyLen: IN_UNF_CIPHER_KEY_LENGTH,
}
#[test]
fn bindgen_test_layout_IN_UNF_CIPHER_CTRL_S() {
    const UNINIT: ::std::mem::MaybeUninit<IN_UNF_CIPHER_CTRL_S> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IN_UNF_CIPHER_CTRL_S>(),
        52usize,
        concat!("Size of: ", stringify!(IN_UNF_CIPHER_CTRL_S))
    );
    assert_eq!(
        ::std::mem::align_of::<IN_UNF_CIPHER_CTRL_S>(),
        4usize,
        concat!("Alignment of ", stringify!(IN_UNF_CIPHER_CTRL_S))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IN_UNF_CIPHER_CTRL_S),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IV) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IN_UNF_CIPHER_CTRL_S),
            "::",
            stringify!(IV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enDataLen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IN_UNF_CIPHER_CTRL_S),
            "::",
            stringify!(enDataLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enAlg) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(IN_UNF_CIPHER_CTRL_S),
            "::",
            stringify!(enAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enBitWidth) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IN_UNF_CIPHER_CTRL_S),
            "::",
            stringify!(enBitWidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enWorkMode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(IN_UNF_CIPHER_CTRL_S),
            "::",
            stringify!(enWorkMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enKeyLen) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IN_UNF_CIPHER_CTRL_S),
            "::",
            stringify!(enKeyLen)
        )
    );
}
#[doc = " 选择加密处理控制结构体."]
pub type IN_UNF_CIPHER_CTRL = IN_UNF_CIPHER_CTRL_S;
extern "C" {
    #[doc = " @fn int SU_CIPHER_Init(void)\n\n 加密模块打开接口.\n\n @param\t无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_CIPHER_Init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_DES_Init(void)\n\n DES模块打开接口.\n\n @param\t无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_CIPHER_DES_Init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Exit(void)\n\n 加密模块关闭接口.\n\n @param\t无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_CIPHER_Exit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_DES_Exit(void)\n\n DES模块关闭接口.\n\n @param\t无.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 无."]
    pub fn SU_CIPHER_DES_Exit() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_DES_Test(void)\n\n 调用DES模块接口测试.\n\n @param\tNone.\n\n @retval 0 Success.\n @retval Non-0 Failure.\n\n @remarks None.\n\n @attention None."]
    pub fn SU_CIPHER_DES_Test() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_CreateHandle(void)\n\n 获得加密模块句柄接口.\n\n @param\t无.\n\n @retval  成功: 返回句柄.\n @retval  失败: retval <  0.\n\n @remarks 无.\n\n @attention 该函数可以多次调用,每调用一次都会返回一个句柄.\n 当调用的N次该函数之后,需要调用N次SU_CIPHER_DestroyHandle()才可以\n 将所有的句柄销毁.\n"]
    pub fn SU_CIPHER_CreateHandle() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_DestroyHandle(int fd)\n\n 销毁加密模块句柄.\n\n @param[in] fd 需要销毁的句柄\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention 该函数可以多次调用,每调用一次都会销毁一个句柄.\n"]
    pub fn SU_CIPHER_DestroyHandle(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_ConfigHandle(int hCipher, IN_UNF_CIPHER_CTRL* Ctrl)\n\n 对加密模块进行配置.\n\n @param[in] hCipher 需要进行配置的句柄.\n @param[in] Ctrl 带有配置信息的结构体.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention  无.\n"]
    pub fn SU_CIPHER_ConfigHandle(
        hCipher: ::std::os::raw::c_int,
        Ctrl: *mut IN_UNF_CIPHER_CTRL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Encrypt(int hCipher, unsigned int * srcAddr, unsigned int * dstAddr, unsigned int dataLen)\n\n 开始进行数据的加密.\n\n @param[in] hCipher 需要进行操作的句柄.\n @param[in] srcAddr 需要进行加密的数据源地址.\n @param[in] dstAddr 加密完成之后的数据存放地址.\n @param[in] dataLen 需要处理的数据长度.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention  加密的数据长度dataLen最大不要超过1Mbyte (1024*1024).\n"]
    pub fn SU_CIPHER_Encrypt(
        hCipher: ::std::os::raw::c_int,
        srcAddr: *mut ::std::os::raw::c_uint,
        dstAddr: *mut ::std::os::raw::c_uint,
        dataLen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_CIPHER_Decrypt(int hCipher, unsigned int * srcAddr, unsigned int * dstAddr, unsigned int dataLen);\n\n 开始进行数据的解密.\n\n @param[in] hCipher 需要进行操作的句柄.\n @param[in] srcAddr 需要进行解密的数据源地址.\n @param[in] dstAddr 解密完成之后的数据存放地址.\n @param[in] dataLen 需要处理的数据长度.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无.\n\n @attention  解密的数据长度dataLen最大不要超过1Mbyte (1024*1024).\n"]
    pub fn SU_CIPHER_Decrypt(
        hCipher: ::std::os::raw::c_int,
        srcAddr: *mut ::std::os::raw::c_uint,
        dstAddr: *mut ::std::os::raw::c_uint,
        dataLen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< 按键抬起"]
pub const SUKeyEvent_KEY_RELEASED: SUKeyEvent = 0;
#[doc = "< 按键按下"]
pub const SUKeyEvent_KEY_PRESSED: SUKeyEvent = 1;
#[doc = " 按键事件."]
pub type SUKeyEvent = ::std::os::raw::c_uint;
#[doc = "< LED关闭"]
pub const SULedCmd_LED_OFF: SULedCmd = 0;
#[doc = "< LED打开"]
pub const SULedCmd_LED_ON: SULedCmd = 1;
#[doc = " LED行为命令."]
pub type SULedCmd = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @fn int SU_Key_OpenEvent(void)\n\n 获得按键事件句柄.\n\n @param 无\n\n @retval >0 按键事件句柄.\n @retval <=0 失败.\n\n @remarks 在成功获得一个按键事件句柄之后，即开始“记录”按键事件，直到关闭这个按键事件。\n @remarks 若打开多个句柄，则每个按键事件会记录一份按键事件。\n @remarks 例如，两个线程分别打开了一个按键事件，每个线程持有一个句柄，则这两个线程会读取到相同的事件序列。\n 但是如果两个线程共享同一个句柄，则每个按键事件只能被读取到一次。\n\n @attention 无。"]
    pub fn SU_Key_OpenEvent() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_CloseEvent(int evfd)\n\n 关闭按键事件.\n\n @param[in] evfd 按键事件句柄\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 无\n\n @attention 无。"]
    pub fn SU_Key_CloseEvent(evfd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_ReadEvent(int evfd, int *keyCode, SUKeyEvent *event)\n\n 读取按键事件.\n\n @param[in] evfd 按键事件句柄\n @param[in] keyCode 按键码\n @param[out] event 按键事件指针.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 该函数阻塞，直到有按键事件发生返回.\n @remarks 按键码的定义在linux/input.h中，与GPIO的映射关系定义在kernel板级文件中。\n @remarks 例如几个常用的按键：\n @code\n#define KEY_HOME                102 //HOME键\n#define KEY_POWER               116 //开关机键，一般也可用来作为唤醒键\n#define KEY_WAKEUP              143 //唤醒键，除POWER键之外用来唤醒系统的按键\n#define KEY_F13                 183 //当PIR作为按键使用时被定义为F13键\n @endcode\n\n @remarks 按键键码与GPIO号的定义，是否作为唤醒源，有效电平等信息均定义在内核板级文件中，如下所示：\n\n @code\nstruct gpio_keys_button __attribute__((weak)) board_buttons[] = {\n#ifdef GPIO_HOME\n{\n.gpio           = GPIO_HOME,\t\t//定义GPIO号\n.code           = KEY_HOME,\t\t\t//定义按键码\n.desc           = \"home key\",\n.active_low     = ACTIVE_LOW_HOME,\t//定义有效电平\n#ifdef WAKEUP_HOME\n.wakeup         = WAKEUP_HOME,\t\t//定义是否可做为唤醒源，1为可唤醒suspend\n#endif\n#ifdef CAN_DISABLE_HOME\n.can_disable    = CAN_DISABLE_HOME,\t//定义是否可以被Disable\n#endif\n},\n#endif\n#ifdef GPIO_POWER\n{\n.gpio           = GPIO_POWER,\n.code           = KEY_POWER,\n.desc           = \"power key\",\n.active_low     = ACTIVE_LOW_POWER,\n#ifdef WAKEUP_POWER\n.wakeup         = WAKEUP_POWER,\n#endif\n#ifdef CAN_DISABLE_POWER\n.can_disable    = CAN_DISABLE_POWER,\n#endif\n},\n#endif\n}\n @endcode\n @remarks 对于数字PIR，一种使用方式是把PIR作为一个按键定义，PIR触发相当于按键按下事件(@ref KEY_PRESSED)，\n PIR恢复相当于按键抬起事件(@ref KEY_RELEASED)。若需要PIR唤醒功能，则把PIR对应的按键定义为唤醒源即可。\n @remarks API详细使用方法请参考sample-keyevent.c.\n\n @attention 无。"]
    pub fn SU_Key_ReadEvent(
        evfd: ::std::os::raw::c_int,
        keyCode: *mut ::std::os::raw::c_int,
        event: *mut SUKeyEvent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_DisableEvent(int keyCode)\n\n Disable按键事件.\n\n @param[in] keyCode 按键码\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 如果按键被配置为唤醒源，那么在系统suspend时，(无论该按键是否被Open)按下按键会使系统唤醒。\n 在Disable按键事件后，系统会关闭按键事件的中断，该按键也就无法唤醒系统\n @remarks 该API可用来Disable PIR\"按键\"唤醒系统。\n\n @attention 无。"]
    pub fn SU_Key_DisableEvent(keyCode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_Key_EnableEvent(int keyCode)\n\n Enable按键事件.\n\n @param[in] keyCode 按键码\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks 作为Disable按键事件的反过程。详见@ref SU_Key_DisableEvent(int keyCode)\n\n @attention 无。"]
    pub fn SU_Key_EnableEvent(keyCode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @fn int SU_LED_Command(int ledNum, SULedCmd cmd)\n\n 发送LED命令.\n\n @param[in] ledNum LED号.\n @param[in] cmd LED行为命令.\n\n @retval 0 成功.\n @retval 非0 失败.\n\n @remarks LED号根据开发板的不同而不同。LED号定义在内核板级文件中，注册为Linux标\n 准Fixed Regulator设备。在板级文件中需定义LED的GPIO号，有效电平，电源递归关系等\n 信息。下面是定义了两个LED fixed regulator的例子：\n @code\nFIXED_REGULATOR_DEF(  //定义fixed regulator\nled0,\n\"LED0\",         3300000,        GPIO_PA(14),\nHIGH_ENABLE,    UN_AT_BOOT,     0,\n\"ldo7\",         \"vled0\",        NULL);\n\nFIXED_REGULATOR_DEF(\nled1,\n\"LED1\",         3300000,        GPIO_PA(15),\nHIGH_ENABLE,    UN_AT_BOOT,     0,\n\"ldo7\",         \"vled1\",        NULL);\n\nstatic struct platform_device *fixed_regulator_devices[] __initdata = {\n&gsensor_regulator_device,\n&led0_regulator_device,\n&led1_regulator_device,\n};\n\nstatic int __init fix_regulator_init(void)  //在subsys_initcall_sync中注册regulator\n{\nint i;\n\nfor (i = 0; i < ARRAY_SIZE(fixed_regulator_devices); i++)\nfixed_regulator_devices[i]->id = i;\n\nreturn platform_add_devices(fixed_regulator_devices,\nARRAY_SIZE(fixed_regulator_devices));\n}\nsubsys_initcall_sync(fix_regulator_init);\n @endcode\n @remarks 此API的使用示例：\n @code\nif (SU_LED_Command(0, LED_ON) < 0)  //使能LED0\nprintf(\"LED0 turn on error\\n\");\nif (SU_LED_Command(1, LED_ON) < 0)  //使能LED1\nprintf(\"LED0 turn on error\\n\");\nif (SU_LED_Command(0, LED_OFF) < 0)  //关闭LED0\nprintf(\"LED1 turn off error\\n\");\nif (SU_LED_Command(1, LED_OFF) < 0)  //关闭LED1\nprintf(\"LED1 turn off error\\n\");\n @endcode\n @attention 无。"]
    pub fn SU_LED_Command(ledNum: ::std::os::raw::c_int, cmd: SULedCmd) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
